function K2(t,e){for(var n=0;n<e.length;n++){const r=e[n];if(typeof r!="string"&&!Array.isArray(r)){for(const o in r)if(o!=="default"&&!(o in t)){const i=Object.getOwnPropertyDescriptor(r,o);i&&Object.defineProperty(t,o,i.get?i:{enumerable:!0,get:()=>r[o]})}}}return Object.freeze(Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}))}(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const o of document.querySelectorAll('link[rel="modulepreload"]'))r(o);new MutationObserver(o=>{for(const i of o)if(i.type==="childList")for(const a of i.addedNodes)a.tagName==="LINK"&&a.rel==="modulepreload"&&r(a)}).observe(document,{childList:!0,subtree:!0});function n(o){const i={};return o.integrity&&(i.integrity=o.integrity),o.referrerPolicy&&(i.referrerPolicy=o.referrerPolicy),o.crossOrigin==="use-credentials"?i.credentials="include":o.crossOrigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function r(o){if(o.ep)return;o.ep=!0;const i=n(o);fetch(o.href,i)}})();function Ef(t){return t&&t.__esModule&&Object.prototype.hasOwnProperty.call(t,"default")?t.default:t}var wd={exports:{}},Si={};/*
object-assign
(c) Sindre Sorhus
@license MIT
*/var Sd,Og;function _f(){if(Og)return Sd;Og=1;var t=Object.getOwnPropertySymbols,e=Object.prototype.hasOwnProperty,n=Object.prototype.propertyIsEnumerable;function r(i){if(i==null)throw new TypeError("Object.assign cannot be called with null or undefined");return Object(i)}function o(){try{if(!Object.assign)return!1;var i=new String("abc");if(i[5]="de",Object.getOwnPropertyNames(i)[0]==="5")return!1;for(var a={},u=0;u<10;u++)a["_"+String.fromCharCode(u)]=u;var l=Object.getOwnPropertyNames(a).map(function(f){return a[f]});if(l.join("")!=="0123456789")return!1;var d={};return"abcdefghijklmnopqrst".split("").forEach(function(f){d[f]=f}),Object.keys(Object.assign({},d)).join("")==="abcdefghijklmnopqrst"}catch{return!1}}return Sd=o()?Object.assign:function(i,a){for(var u,l=r(i),d,f=1;f<arguments.length;f++){u=Object(arguments[f]);for(var p in u)e.call(u,p)&&(l[p]=u[p]);if(t){d=t(u);for(var h=0;h<d.length;h++)n.call(u,d[h])&&(l[d[h]]=u[d[h]])}}return l},Sd}var bd={exports:{}},Ne={};/** @license React v17.0.2
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Dg;function Y2(){if(Dg)return Ne;Dg=1;var t=_f(),e=60103,n=60106;Ne.Fragment=60107,Ne.StrictMode=60108,Ne.Profiler=60114;var r=60109,o=60110,i=60112;Ne.Suspense=60113;var a=60115,u=60116;if(typeof Symbol=="function"&&Symbol.for){var l=Symbol.for;e=l("react.element"),n=l("react.portal"),Ne.Fragment=l("react.fragment"),Ne.StrictMode=l("react.strict_mode"),Ne.Profiler=l("react.profiler"),r=l("react.provider"),o=l("react.context"),i=l("react.forward_ref"),Ne.Suspense=l("react.suspense"),a=l("react.memo"),u=l("react.lazy")}var d=typeof Symbol=="function"&&Symbol.iterator;function f(L){return L===null||typeof L!="object"?null:(L=d&&L[d]||L["@@iterator"],typeof L=="function"?L:null)}function p(L){for(var X="https://reactjs.org/docs/error-decoder.html?invariant="+L,ne=1;ne<arguments.length;ne++)X+="&args[]="+encodeURIComponent(arguments[ne]);return"Minified React error #"+L+"; visit "+X+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var h={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},g={};function y(L,X,ne){this.props=L,this.context=X,this.refs=g,this.updater=ne||h}y.prototype.isReactComponent={},y.prototype.setState=function(L,X){if(typeof L!="object"&&typeof L!="function"&&L!=null)throw Error(p(85));this.updater.enqueueSetState(this,L,X,"setState")},y.prototype.forceUpdate=function(L){this.updater.enqueueForceUpdate(this,L,"forceUpdate")};function x(){}x.prototype=y.prototype;function v(L,X,ne){this.props=L,this.context=X,this.refs=g,this.updater=ne||h}var w=v.prototype=new x;w.constructor=v,t(w,y.prototype),w.isPureReactComponent=!0;var S={current:null},I=Object.prototype.hasOwnProperty,E={key:!0,ref:!0,__self:!0,__source:!0};function R(L,X,ne){var Q,H={},K=null,J=null;if(X!=null)for(Q in X.ref!==void 0&&(J=X.ref),X.key!==void 0&&(K=""+X.key),X)I.call(X,Q)&&!E.hasOwnProperty(Q)&&(H[Q]=X[Q]);var ge=arguments.length-2;if(ge===1)H.children=ne;else if(1<ge){for(var ve=Array(ge),We=0;We<ge;We++)ve[We]=arguments[We+2];H.children=ve}if(L&&L.defaultProps)for(Q in ge=L.defaultProps,ge)H[Q]===void 0&&(H[Q]=ge[Q]);return{$$typeof:e,type:L,key:K,ref:J,props:H,_owner:S.current}}function T(L,X){return{$$typeof:e,type:L.type,key:X,ref:L.ref,props:L.props,_owner:L._owner}}function k(L){return typeof L=="object"&&L!==null&&L.$$typeof===e}function D(L){var X={"=":"=0",":":"=2"};return"$"+L.replace(/[=:]/g,function(ne){return X[ne]})}var N=/\/+/g;function O(L,X){return typeof L=="object"&&L!==null&&L.key!=null?D(""+L.key):X.toString(36)}function _(L,X,ne,Q,H){var K=typeof L;(K==="undefined"||K==="boolean")&&(L=null);var J=!1;if(L===null)J=!0;else switch(K){case"string":case"number":J=!0;break;case"object":switch(L.$$typeof){case e:case n:J=!0}}if(J)return J=L,H=H(J),L=Q===""?"."+O(J,0):Q,Array.isArray(H)?(ne="",L!=null&&(ne=L.replace(N,"$&/")+"/"),_(H,X,ne,"",function(We){return We})):H!=null&&(k(H)&&(H=T(H,ne+(!H.key||J&&J.key===H.key?"":(""+H.key).replace(N,"$&/")+"/")+L)),X.push(H)),1;if(J=0,Q=Q===""?".":Q+":",Array.isArray(L))for(var ge=0;ge<L.length;ge++){K=L[ge];var ve=Q+O(K,ge);J+=_(K,X,ne,ve,H)}else if(ve=f(L),typeof ve=="function")for(L=ve.call(L),ge=0;!(K=L.next()).done;)K=K.value,ve=Q+O(K,ge++),J+=_(K,X,ne,ve,H);else if(K==="object")throw X=""+L,Error(p(31,X==="[object Object]"?"object with keys {"+Object.keys(L).join(", ")+"}":X));return J}function F(L,X,ne){if(L==null)return L;var Q=[],H=0;return _(L,Q,"","",function(K){return X.call(ne,K,H++)}),Q}function U(L){if(L._status===-1){var X=L._result;X=X(),L._status=0,L._result=X,X.then(function(ne){L._status===0&&(ne=ne.default,L._status=1,L._result=ne)},function(ne){L._status===0&&(L._status=2,L._result=ne)})}if(L._status===1)return L._result;throw L._result}var G={current:null};function j(){var L=G.current;if(L===null)throw Error(p(321));return L}var Z={ReactCurrentDispatcher:G,ReactCurrentBatchConfig:{transition:0},ReactCurrentOwner:S,IsSomeRendererActing:{current:!1},assign:t};return Ne.Children={map:F,forEach:function(L,X,ne){F(L,function(){X.apply(this,arguments)},ne)},count:function(L){var X=0;return F(L,function(){X++}),X},toArray:function(L){return F(L,function(X){return X})||[]},only:function(L){if(!k(L))throw Error(p(143));return L}},Ne.Component=y,Ne.PureComponent=v,Ne.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=Z,Ne.cloneElement=function(L,X,ne){if(L==null)throw Error(p(267,L));var Q=t({},L.props),H=L.key,K=L.ref,J=L._owner;if(X!=null){if(X.ref!==void 0&&(K=X.ref,J=S.current),X.key!==void 0&&(H=""+X.key),L.type&&L.type.defaultProps)var ge=L.type.defaultProps;for(ve in X)I.call(X,ve)&&!E.hasOwnProperty(ve)&&(Q[ve]=X[ve]===void 0&&ge!==void 0?ge[ve]:X[ve])}var ve=arguments.length-2;if(ve===1)Q.children=ne;else if(1<ve){ge=Array(ve);for(var We=0;We<ve;We++)ge[We]=arguments[We+2];Q.children=ge}return{$$typeof:e,type:L.type,key:H,ref:K,props:Q,_owner:J}},Ne.createContext=function(L,X){return X===void 0&&(X=null),L={$$typeof:o,_calculateChangedBits:X,_currentValue:L,_currentValue2:L,_threadCount:0,Provider:null,Consumer:null},L.Provider={$$typeof:r,_context:L},L.Consumer=L},Ne.createElement=R,Ne.createFactory=function(L){var X=R.bind(null,L);return X.type=L,X},Ne.createRef=function(){return{current:null}},Ne.forwardRef=function(L){return{$$typeof:i,render:L}},Ne.isValidElement=k,Ne.lazy=function(L){return{$$typeof:u,_payload:{_status:-1,_result:L},_init:U}},Ne.memo=function(L,X){return{$$typeof:a,type:L,compare:X===void 0?null:X}},Ne.useCallback=function(L,X){return j().useCallback(L,X)},Ne.useContext=function(L,X){return j().useContext(L,X)},Ne.useDebugValue=function(){},Ne.useEffect=function(L,X){return j().useEffect(L,X)},Ne.useImperativeHandle=function(L,X,ne){return j().useImperativeHandle(L,X,ne)},Ne.useLayoutEffect=function(L,X){return j().useLayoutEffect(L,X)},Ne.useMemo=function(L,X){return j().useMemo(L,X)},Ne.useReducer=function(L,X,ne){return j().useReducer(L,X,ne)},Ne.useRef=function(L){return j().useRef(L)},Ne.useState=function(L){return j().useState(L)},Ne.version="17.0.2",Ne}var Fg;function wt(){return Fg||(Fg=1,bd.exports=Y2()),bd.exports}/** @license React v17.0.2
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Lg;function Q2(){if(Lg)return Si;Lg=1,_f();var t=wt(),e=60103;if(Si.Fragment=60107,typeof Symbol=="function"&&Symbol.for){var n=Symbol.for;e=n("react.element"),Si.Fragment=n("react.fragment")}var r=t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,o=Object.prototype.hasOwnProperty,i={key:!0,ref:!0,__self:!0,__source:!0};function a(u,l,d){var f,p={},h=null,g=null;d!==void 0&&(h=""+d),l.key!==void 0&&(h=""+l.key),l.ref!==void 0&&(g=l.ref);for(f in l)o.call(l,f)&&!i.hasOwnProperty(f)&&(p[f]=l[f]);if(u&&u.defaultProps)for(f in l=u.defaultProps,l)p[f]===void 0&&(p[f]=l[f]);return{$$typeof:e,type:u,key:h,ref:g,props:p,_owner:r.current}}return Si.jsx=a,Si.jsxs=a,Si}var Mg;function Z2(){return Mg||(Mg=1,wd.exports=Q2()),wd.exports}var Be=Z2(),Yu=wt();const J2=Ef(Yu);var Id={exports:{}},Ut={},$d={exports:{}},Rd={};/** @license React v0.20.2
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Bg;function eI(){return Bg||(Bg=1,function(t){var e,n,r,o;if(typeof performance=="object"&&typeof performance.now=="function"){var i=performance;t.unstable_now=function(){return i.now()}}else{var a=Date,u=a.now();t.unstable_now=function(){return a.now()-u}}if(typeof window>"u"||typeof MessageChannel!="function"){var l=null,d=null,f=function(){if(l!==null)try{var H=t.unstable_now();l(!0,H),l=null}catch(K){throw setTimeout(f,0),K}};e=function(H){l!==null?setTimeout(e,0,H):(l=H,setTimeout(f,0))},n=function(H,K){d=setTimeout(H,K)},r=function(){clearTimeout(d)},t.unstable_shouldYield=function(){return!1},o=t.unstable_forceFrameRate=function(){}}else{var p=window.setTimeout,h=window.clearTimeout;if(typeof console<"u"){var g=window.cancelAnimationFrame;typeof window.requestAnimationFrame!="function"&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"),typeof g!="function"&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills")}var y=!1,x=null,v=-1,w=5,S=0;t.unstable_shouldYield=function(){return t.unstable_now()>=S},o=function(){},t.unstable_forceFrameRate=function(H){0>H||125<H?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):w=0<H?Math.floor(1e3/H):5};var I=new MessageChannel,E=I.port2;I.port1.onmessage=function(){if(x!==null){var H=t.unstable_now();S=H+w;try{x(!0,H)?E.postMessage(null):(y=!1,x=null)}catch(K){throw E.postMessage(null),K}}else y=!1},e=function(H){x=H,y||(y=!0,E.postMessage(null))},n=function(H,K){v=p(function(){H(t.unstable_now())},K)},r=function(){h(v),v=-1}}function R(H,K){var J=H.length;H.push(K);e:for(;;){var ge=J-1>>>1,ve=H[ge];if(ve!==void 0&&0<D(ve,K))H[ge]=K,H[J]=ve,J=ge;else break e}}function T(H){return H=H[0],H===void 0?null:H}function k(H){var K=H[0];if(K!==void 0){var J=H.pop();if(J!==K){H[0]=J;e:for(var ge=0,ve=H.length;ge<ve;){var We=2*(ge+1)-1,Lt=H[We],Ln=We+1,rn=H[Ln];if(Lt!==void 0&&0>D(Lt,J))rn!==void 0&&0>D(rn,Lt)?(H[ge]=rn,H[Ln]=J,ge=Ln):(H[ge]=Lt,H[We]=J,ge=We);else if(rn!==void 0&&0>D(rn,J))H[ge]=rn,H[Ln]=J,ge=Ln;else break e}}return K}return null}function D(H,K){var J=H.sortIndex-K.sortIndex;return J!==0?J:H.id-K.id}var N=[],O=[],_=1,F=null,U=3,G=!1,j=!1,Z=!1;function L(H){for(var K=T(O);K!==null;){if(K.callback===null)k(O);else if(K.startTime<=H)k(O),K.sortIndex=K.expirationTime,R(N,K);else break;K=T(O)}}function X(H){if(Z=!1,L(H),!j)if(T(N)!==null)j=!0,e(ne);else{var K=T(O);K!==null&&n(X,K.startTime-H)}}function ne(H,K){j=!1,Z&&(Z=!1,r()),G=!0;var J=U;try{for(L(K),F=T(N);F!==null&&(!(F.expirationTime>K)||H&&!t.unstable_shouldYield());){var ge=F.callback;if(typeof ge=="function"){F.callback=null,U=F.priorityLevel;var ve=ge(F.expirationTime<=K);K=t.unstable_now(),typeof ve=="function"?F.callback=ve:F===T(N)&&k(N),L(K)}else k(N);F=T(N)}if(F!==null)var We=!0;else{var Lt=T(O);Lt!==null&&n(X,Lt.startTime-K),We=!1}return We}finally{F=null,U=J,G=!1}}var Q=o;t.unstable_IdlePriority=5,t.unstable_ImmediatePriority=1,t.unstable_LowPriority=4,t.unstable_NormalPriority=3,t.unstable_Profiling=null,t.unstable_UserBlockingPriority=2,t.unstable_cancelCallback=function(H){H.callback=null},t.unstable_continueExecution=function(){j||G||(j=!0,e(ne))},t.unstable_getCurrentPriorityLevel=function(){return U},t.unstable_getFirstCallbackNode=function(){return T(N)},t.unstable_next=function(H){switch(U){case 1:case 2:case 3:var K=3;break;default:K=U}var J=U;U=K;try{return H()}finally{U=J}},t.unstable_pauseExecution=function(){},t.unstable_requestPaint=Q,t.unstable_runWithPriority=function(H,K){switch(H){case 1:case 2:case 3:case 4:case 5:break;default:H=3}var J=U;U=H;try{return K()}finally{U=J}},t.unstable_scheduleCallback=function(H,K,J){var ge=t.unstable_now();switch(typeof J=="object"&&J!==null?(J=J.delay,J=typeof J=="number"&&0<J?ge+J:ge):J=ge,H){case 1:var ve=-1;break;case 2:ve=250;break;case 5:ve=1073741823;break;case 4:ve=1e4;break;default:ve=5e3}return ve=J+ve,H={id:_++,callback:K,priorityLevel:H,startTime:J,expirationTime:ve,sortIndex:-1},J>ge?(H.sortIndex=J,R(O,H),T(N)===null&&H===T(O)&&(Z?r():Z=!0,n(X,J-ge))):(H.sortIndex=ve,R(N,H),j||G||(j=!0,e(ne))),H},t.unstable_wrapCallback=function(H){var K=U;return function(){var J=U;U=K;try{return H.apply(this,arguments)}finally{U=J}}}}(Rd)),Rd}var Ug;function tI(){return Ug||(Ug=1,$d.exports=eI()),$d.exports}/** @license React v17.0.2
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Wg;function nI(){if(Wg)return Ut;Wg=1;var t=wt(),e=_f(),n=tI();function r(s){for(var c="https://reactjs.org/docs/error-decoder.html?invariant="+s,m=1;m<arguments.length;m++)c+="&args[]="+encodeURIComponent(arguments[m]);return"Minified React error #"+s+"; visit "+c+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}if(!t)throw Error(r(227));var o=new Set,i={};function a(s,c){u(s,c),u(s+"Capture",c)}function u(s,c){for(i[s]=c,s=0;s<c.length;s++)o.add(c[s])}var l=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),d=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,f=Object.prototype.hasOwnProperty,p={},h={};function g(s){return f.call(h,s)?!0:f.call(p,s)?!1:d.test(s)?h[s]=!0:(p[s]=!0,!1)}function y(s,c,m,C){if(m!==null&&m.type===0)return!1;switch(typeof c){case"function":case"symbol":return!0;case"boolean":return C?!1:m!==null?!m.acceptsBooleans:(s=s.toLowerCase().slice(0,5),s!=="data-"&&s!=="aria-");default:return!1}}function x(s,c,m,C){if(c===null||typeof c>"u"||y(s,c,m,C))return!0;if(C)return!1;if(m!==null)switch(m.type){case 3:return!c;case 4:return c===!1;case 5:return isNaN(c);case 6:return isNaN(c)||1>c}return!1}function v(s,c,m,C,b,$,P){this.acceptsBooleans=c===2||c===3||c===4,this.attributeName=C,this.attributeNamespace=b,this.mustUseProperty=m,this.propertyName=s,this.type=c,this.sanitizeURL=$,this.removeEmptyString=P}var w={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(s){w[s]=new v(s,0,!1,s,null,!1,!1)}),[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(s){var c=s[0];w[c]=new v(c,1,!1,s[1],null,!1,!1)}),["contentEditable","draggable","spellCheck","value"].forEach(function(s){w[s]=new v(s,2,!1,s.toLowerCase(),null,!1,!1)}),["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(s){w[s]=new v(s,2,!1,s,null,!1,!1)}),"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(s){w[s]=new v(s,3,!1,s.toLowerCase(),null,!1,!1)}),["checked","multiple","muted","selected"].forEach(function(s){w[s]=new v(s,3,!0,s,null,!1,!1)}),["capture","download"].forEach(function(s){w[s]=new v(s,4,!1,s,null,!1,!1)}),["cols","rows","size","span"].forEach(function(s){w[s]=new v(s,6,!1,s,null,!1,!1)}),["rowSpan","start"].forEach(function(s){w[s]=new v(s,5,!1,s.toLowerCase(),null,!1,!1)});var S=/[\-:]([a-z])/g;function I(s){return s[1].toUpperCase()}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(s){var c=s.replace(S,I);w[c]=new v(c,1,!1,s,null,!1,!1)}),"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(s){var c=s.replace(S,I);w[c]=new v(c,1,!1,s,"http://www.w3.org/1999/xlink",!1,!1)}),["xml:base","xml:lang","xml:space"].forEach(function(s){var c=s.replace(S,I);w[c]=new v(c,1,!1,s,"http://www.w3.org/XML/1998/namespace",!1,!1)}),["tabIndex","crossOrigin"].forEach(function(s){w[s]=new v(s,1,!1,s.toLowerCase(),null,!1,!1)}),w.xlinkHref=new v("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1),["src","href","action","formAction"].forEach(function(s){w[s]=new v(s,1,!1,s.toLowerCase(),null,!0,!0)});function E(s,c,m,C){var b=w.hasOwnProperty(c)?w[c]:null,$=b!==null?b.type===0:C?!1:!(!(2<c.length)||c[0]!=="o"&&c[0]!=="O"||c[1]!=="n"&&c[1]!=="N");$||(x(c,m,b,C)&&(m=null),C||b===null?g(c)&&(m===null?s.removeAttribute(c):s.setAttribute(c,""+m)):b.mustUseProperty?s[b.propertyName]=m===null?b.type===3?!1:"":m:(c=b.attributeName,C=b.attributeNamespace,m===null?s.removeAttribute(c):(b=b.type,m=b===3||b===4&&m===!0?"":""+m,C?s.setAttributeNS(C,c,m):s.setAttribute(c,m))))}var R=t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,T=60103,k=60106,D=60107,N=60108,O=60114,_=60109,F=60110,U=60112,G=60113,j=60120,Z=60115,L=60116,X=60121,ne=60128,Q=60129,H=60130,K=60131;if(typeof Symbol=="function"&&Symbol.for){var J=Symbol.for;T=J("react.element"),k=J("react.portal"),D=J("react.fragment"),N=J("react.strict_mode"),O=J("react.profiler"),_=J("react.provider"),F=J("react.context"),U=J("react.forward_ref"),G=J("react.suspense"),j=J("react.suspense_list"),Z=J("react.memo"),L=J("react.lazy"),X=J("react.block"),J("react.scope"),ne=J("react.opaque.id"),Q=J("react.debug_trace_mode"),H=J("react.offscreen"),K=J("react.legacy_hidden")}var ge=typeof Symbol=="function"&&Symbol.iterator;function ve(s){return s===null||typeof s!="object"?null:(s=ge&&s[ge]||s["@@iterator"],typeof s=="function"?s:null)}var We;function Lt(s){if(We===void 0)try{throw Error()}catch(m){var c=m.stack.trim().match(/\n( *(at )?)/);We=c&&c[1]||""}return`
`+We+s}var Ln=!1;function rn(s,c){if(!s||Ln)return"";Ln=!0;var m=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(c)if(c=function(){throw Error()},Object.defineProperty(c.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(c,[])}catch(M){var C=M}Reflect.construct(s,[],c)}else{try{c.call()}catch(M){C=M}s.call(c.prototype)}else{try{throw Error()}catch(M){C=M}s()}}catch(M){if(M&&C&&typeof M.stack=="string"){for(var b=M.stack.split(`
`),$=C.stack.split(`
`),P=b.length-1,A=$.length-1;1<=P&&0<=A&&b[P]!==$[A];)A--;for(;1<=P&&0<=A;P--,A--)if(b[P]!==$[A]){if(P!==1||A!==1)do if(P--,A--,0>A||b[P]!==$[A])return`
`+b[P].replace(" at new "," at ");while(1<=P&&0<=A);break}}}finally{Ln=!1,Error.prepareStackTrace=m}return(s=s?s.displayName||s.name:"")?Lt(s):""}function rb(s){switch(s.tag){case 5:return Lt(s.type);case 16:return Lt("Lazy");case 13:return Lt("Suspense");case 19:return Lt("SuspenseList");case 0:case 2:case 15:return s=rn(s.type,!1),s;case 11:return s=rn(s.type.render,!1),s;case 22:return s=rn(s.type._render,!1),s;case 1:return s=rn(s.type,!0),s;default:return""}}function Ko(s){if(s==null)return null;if(typeof s=="function")return s.displayName||s.name||null;if(typeof s=="string")return s;switch(s){case D:return"Fragment";case k:return"Portal";case O:return"Profiler";case N:return"StrictMode";case G:return"Suspense";case j:return"SuspenseList"}if(typeof s=="object")switch(s.$$typeof){case F:return(s.displayName||"Context")+".Consumer";case _:return(s._context.displayName||"Context")+".Provider";case U:var c=s.render;return c=c.displayName||c.name||"",s.displayName||(c!==""?"ForwardRef("+c+")":"ForwardRef");case Z:return Ko(s.type);case X:return Ko(s._render);case L:c=s._payload,s=s._init;try{return Ko(s(c))}catch{}}return null}function rr(s){switch(typeof s){case"boolean":case"number":case"object":case"string":case"undefined":return s;default:return""}}function eh(s){var c=s.type;return(s=s.nodeName)&&s.toLowerCase()==="input"&&(c==="checkbox"||c==="radio")}function ob(s){var c=eh(s)?"checked":"value",m=Object.getOwnPropertyDescriptor(s.constructor.prototype,c),C=""+s[c];if(!s.hasOwnProperty(c)&&typeof m<"u"&&typeof m.get=="function"&&typeof m.set=="function"){var b=m.get,$=m.set;return Object.defineProperty(s,c,{configurable:!0,get:function(){return b.call(this)},set:function(P){C=""+P,$.call(this,P)}}),Object.defineProperty(s,c,{enumerable:m.enumerable}),{getValue:function(){return C},setValue:function(P){C=""+P},stopTracking:function(){s._valueTracker=null,delete s[c]}}}}function Ma(s){s._valueTracker||(s._valueTracker=ob(s))}function th(s){if(!s)return!1;var c=s._valueTracker;if(!c)return!0;var m=c.getValue(),C="";return s&&(C=eh(s)?s.checked?"true":"false":s.value),s=C,s!==m?(c.setValue(s),!0):!1}function Ba(s){if(s=s||(typeof document<"u"?document:void 0),typeof s>"u")return null;try{return s.activeElement||s.body}catch{return s.body}}function Ol(s,c){var m=c.checked;return e({},c,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:m??s._wrapperState.initialChecked})}function nh(s,c){var m=c.defaultValue==null?"":c.defaultValue,C=c.checked!=null?c.checked:c.defaultChecked;m=rr(c.value!=null?c.value:m),s._wrapperState={initialChecked:C,initialValue:m,controlled:c.type==="checkbox"||c.type==="radio"?c.checked!=null:c.value!=null}}function rh(s,c){c=c.checked,c!=null&&E(s,"checked",c,!1)}function Dl(s,c){rh(s,c);var m=rr(c.value),C=c.type;if(m!=null)C==="number"?(m===0&&s.value===""||s.value!=m)&&(s.value=""+m):s.value!==""+m&&(s.value=""+m);else if(C==="submit"||C==="reset"){s.removeAttribute("value");return}c.hasOwnProperty("value")?Fl(s,c.type,m):c.hasOwnProperty("defaultValue")&&Fl(s,c.type,rr(c.defaultValue)),c.checked==null&&c.defaultChecked!=null&&(s.defaultChecked=!!c.defaultChecked)}function oh(s,c,m){if(c.hasOwnProperty("value")||c.hasOwnProperty("defaultValue")){var C=c.type;if(!(C!=="submit"&&C!=="reset"||c.value!==void 0&&c.value!==null))return;c=""+s._wrapperState.initialValue,m||c===s.value||(s.value=c),s.defaultValue=c}m=s.name,m!==""&&(s.name=""),s.defaultChecked=!!s._wrapperState.initialChecked,m!==""&&(s.name=m)}function Fl(s,c,m){(c!=="number"||Ba(s.ownerDocument)!==s)&&(m==null?s.defaultValue=""+s._wrapperState.initialValue:s.defaultValue!==""+m&&(s.defaultValue=""+m))}function ib(s){var c="";return t.Children.forEach(s,function(m){m!=null&&(c+=m)}),c}function Ll(s,c){return s=e({children:void 0},c),(c=ib(c.children))&&(s.children=c),s}function Yo(s,c,m,C){if(s=s.options,c){c={};for(var b=0;b<m.length;b++)c["$"+m[b]]=!0;for(m=0;m<s.length;m++)b=c.hasOwnProperty("$"+s[m].value),s[m].selected!==b&&(s[m].selected=b),b&&C&&(s[m].defaultSelected=!0)}else{for(m=""+rr(m),c=null,b=0;b<s.length;b++){if(s[b].value===m){s[b].selected=!0,C&&(s[b].defaultSelected=!0);return}c!==null||s[b].disabled||(c=s[b])}c!==null&&(c.selected=!0)}}function Ml(s,c){if(c.dangerouslySetInnerHTML!=null)throw Error(r(91));return e({},c,{value:void 0,defaultValue:void 0,children:""+s._wrapperState.initialValue})}function ih(s,c){var m=c.value;if(m==null){if(m=c.children,c=c.defaultValue,m!=null){if(c!=null)throw Error(r(92));if(Array.isArray(m)){if(!(1>=m.length))throw Error(r(93));m=m[0]}c=m}c==null&&(c=""),m=c}s._wrapperState={initialValue:rr(m)}}function sh(s,c){var m=rr(c.value),C=rr(c.defaultValue);m!=null&&(m=""+m,m!==s.value&&(s.value=m),c.defaultValue==null&&s.defaultValue!==m&&(s.defaultValue=m)),C!=null&&(s.defaultValue=""+C)}function ah(s){var c=s.textContent;c===s._wrapperState.initialValue&&c!==""&&c!==null&&(s.value=c)}var Bl={html:"http://www.w3.org/1999/xhtml",svg:"http://www.w3.org/2000/svg"};function uh(s){switch(s){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Ul(s,c){return s==null||s==="http://www.w3.org/1999/xhtml"?uh(c):s==="http://www.w3.org/2000/svg"&&c==="foreignObject"?"http://www.w3.org/1999/xhtml":s}var Ua,lh=function(s){return typeof MSApp<"u"&&MSApp.execUnsafeLocalFunction?function(c,m,C,b){MSApp.execUnsafeLocalFunction(function(){return s(c,m,C,b)})}:s}(function(s,c){if(s.namespaceURI!==Bl.svg||"innerHTML"in s)s.innerHTML=c;else{for(Ua=Ua||document.createElement("div"),Ua.innerHTML="<svg>"+c.valueOf().toString()+"</svg>",c=Ua.firstChild;s.firstChild;)s.removeChild(s.firstChild);for(;c.firstChild;)s.appendChild(c.firstChild)}});function ns(s,c){if(c){var m=s.firstChild;if(m&&m===s.lastChild&&m.nodeType===3){m.nodeValue=c;return}}s.textContent=c}var rs={animationIterationCount:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},sb=["Webkit","ms","Moz","O"];Object.keys(rs).forEach(function(s){sb.forEach(function(c){c=c+s.charAt(0).toUpperCase()+s.substring(1),rs[c]=rs[s]})});function ch(s,c,m){return c==null||typeof c=="boolean"||c===""?"":m||typeof c!="number"||c===0||rs.hasOwnProperty(s)&&rs[s]?(""+c).trim():c+"px"}function dh(s,c){s=s.style;for(var m in c)if(c.hasOwnProperty(m)){var C=m.indexOf("--")===0,b=ch(m,c[m],C);m==="float"&&(m="cssFloat"),C?s.setProperty(m,b):s[m]=b}}var ab=e({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function Wl(s,c){if(c){if(ab[s]&&(c.children!=null||c.dangerouslySetInnerHTML!=null))throw Error(r(137,s));if(c.dangerouslySetInnerHTML!=null){if(c.children!=null)throw Error(r(60));if(!(typeof c.dangerouslySetInnerHTML=="object"&&"__html"in c.dangerouslySetInnerHTML))throw Error(r(61))}if(c.style!=null&&typeof c.style!="object")throw Error(r(62))}}function Vl(s,c){if(s.indexOf("-")===-1)return typeof c.is=="string";switch(s){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}function zl(s){return s=s.target||s.srcElement||window,s.correspondingUseElement&&(s=s.correspondingUseElement),s.nodeType===3?s.parentNode:s}var Gl=null,Qo=null,Zo=null;function fh(s){if(s=Ss(s)){if(typeof Gl!="function")throw Error(r(280));var c=s.stateNode;c&&(c=ou(c),Gl(s.stateNode,s.type,c))}}function ph(s){Qo?Zo?Zo.push(s):Zo=[s]:Qo=s}function hh(){if(Qo){var s=Qo,c=Zo;if(Zo=Qo=null,fh(s),c)for(s=0;s<c.length;s++)fh(c[s])}}function Hl(s,c){return s(c)}function mh(s,c,m,C,b){return s(c,m,C,b)}function jl(){}var gh=Hl,Br=!1,Xl=!1;function ql(){(Qo!==null||Zo!==null)&&(jl(),hh())}function ub(s,c,m){if(Xl)return s(c,m);Xl=!0;try{return gh(s,c,m)}finally{Xl=!1,ql()}}function os(s,c){var m=s.stateNode;if(m===null)return null;var C=ou(m);if(C===null)return null;m=C[c];e:switch(c){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(C=!C.disabled)||(s=s.type,C=!(s==="button"||s==="input"||s==="select"||s==="textarea")),s=!C;break e;default:s=!1}if(s)return null;if(m&&typeof m!="function")throw Error(r(231,c,typeof m));return m}var Kl=!1;if(l)try{var is={};Object.defineProperty(is,"passive",{get:function(){Kl=!0}}),window.addEventListener("test",is,is),window.removeEventListener("test",is,is)}catch{Kl=!1}function lb(s,c,m,C,b,$,P,A,M){var q=Array.prototype.slice.call(arguments,3);try{c.apply(m,q)}catch(de){this.onError(de)}}var ss=!1,Wa=null,Va=!1,Yl=null,cb={onError:function(s){ss=!0,Wa=s}};function db(s,c,m,C,b,$,P,A,M){ss=!1,Wa=null,lb.apply(cb,arguments)}function fb(s,c,m,C,b,$,P,A,M){if(db.apply(this,arguments),ss){if(ss){var q=Wa;ss=!1,Wa=null}else throw Error(r(198));Va||(Va=!0,Yl=q)}}function Ur(s){var c=s,m=s;if(s.alternate)for(;c.return;)c=c.return;else{s=c;do c=s,(c.flags&1026)!==0&&(m=c.return),s=c.return;while(s)}return c.tag===3?m:null}function yh(s){if(s.tag===13){var c=s.memoizedState;if(c===null&&(s=s.alternate,s!==null&&(c=s.memoizedState)),c!==null)return c.dehydrated}return null}function xh(s){if(Ur(s)!==s)throw Error(r(188))}function pb(s){var c=s.alternate;if(!c){if(c=Ur(s),c===null)throw Error(r(188));return c!==s?null:s}for(var m=s,C=c;;){var b=m.return;if(b===null)break;var $=b.alternate;if($===null){if(C=b.return,C!==null){m=C;continue}break}if(b.child===$.child){for($=b.child;$;){if($===m)return xh(b),s;if($===C)return xh(b),c;$=$.sibling}throw Error(r(188))}if(m.return!==C.return)m=b,C=$;else{for(var P=!1,A=b.child;A;){if(A===m){P=!0,m=b,C=$;break}if(A===C){P=!0,C=b,m=$;break}A=A.sibling}if(!P){for(A=$.child;A;){if(A===m){P=!0,m=$,C=b;break}if(A===C){P=!0,C=$,m=b;break}A=A.sibling}if(!P)throw Error(r(189))}}if(m.alternate!==C)throw Error(r(190))}if(m.tag!==3)throw Error(r(188));return m.stateNode.current===m?s:c}function vh(s){if(s=pb(s),!s)return null;for(var c=s;;){if(c.tag===5||c.tag===6)return c;if(c.child)c.child.return=c,c=c.child;else{if(c===s)break;for(;!c.sibling;){if(!c.return||c.return===s)return null;c=c.return}c.sibling.return=c.return,c=c.sibling}}return null}function Ch(s,c){for(var m=s.alternate;c!==null;){if(c===s||c===m)return!0;c=c.return}return!1}var wh,Ql,Sh,bh,Zl=!1,Sn=[],or=null,ir=null,sr=null,as=new Map,us=new Map,ls=[],Ih="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function Jl(s,c,m,C,b){return{blockedOn:s,domEventName:c,eventSystemFlags:m|16,nativeEvent:b,targetContainers:[C]}}function $h(s,c){switch(s){case"focusin":case"focusout":or=null;break;case"dragenter":case"dragleave":ir=null;break;case"mouseover":case"mouseout":sr=null;break;case"pointerover":case"pointerout":as.delete(c.pointerId);break;case"gotpointercapture":case"lostpointercapture":us.delete(c.pointerId)}}function cs(s,c,m,C,b,$){return s===null||s.nativeEvent!==$?(s=Jl(c,m,C,b,$),c!==null&&(c=Ss(c),c!==null&&Ql(c)),s):(s.eventSystemFlags|=C,c=s.targetContainers,b!==null&&c.indexOf(b)===-1&&c.push(b),s)}function hb(s,c,m,C,b){switch(c){case"focusin":return or=cs(or,s,c,m,C,b),!0;case"dragenter":return ir=cs(ir,s,c,m,C,b),!0;case"mouseover":return sr=cs(sr,s,c,m,C,b),!0;case"pointerover":var $=b.pointerId;return as.set($,cs(as.get($)||null,s,c,m,C,b)),!0;case"gotpointercapture":return $=b.pointerId,us.set($,cs(us.get($)||null,s,c,m,C,b)),!0}return!1}function mb(s){var c=Wr(s.target);if(c!==null){var m=Ur(c);if(m!==null){if(c=m.tag,c===13){if(c=yh(m),c!==null){s.blockedOn=c,bh(s.lanePriority,function(){n.unstable_runWithPriority(s.priority,function(){Sh(m)})});return}}else if(c===3&&m.stateNode.hydrate){s.blockedOn=m.tag===3?m.stateNode.containerInfo:null;return}}}s.blockedOn=null}function za(s){if(s.blockedOn!==null)return!1;for(var c=s.targetContainers;0<c.length;){var m=ic(s.domEventName,s.eventSystemFlags,c[0],s.nativeEvent);if(m!==null)return c=Ss(m),c!==null&&Ql(c),s.blockedOn=m,!1;c.shift()}return!0}function Rh(s,c,m){za(s)&&m.delete(c)}function gb(){for(Zl=!1;0<Sn.length;){var s=Sn[0];if(s.blockedOn!==null){s=Ss(s.blockedOn),s!==null&&wh(s);break}for(var c=s.targetContainers;0<c.length;){var m=ic(s.domEventName,s.eventSystemFlags,c[0],s.nativeEvent);if(m!==null){s.blockedOn=m;break}c.shift()}s.blockedOn===null&&Sn.shift()}or!==null&&za(or)&&(or=null),ir!==null&&za(ir)&&(ir=null),sr!==null&&za(sr)&&(sr=null),as.forEach(Rh),us.forEach(Rh)}function ds(s,c){s.blockedOn===c&&(s.blockedOn=null,Zl||(Zl=!0,n.unstable_scheduleCallback(n.unstable_NormalPriority,gb)))}function Eh(s){function c(b){return ds(b,s)}if(0<Sn.length){ds(Sn[0],s);for(var m=1;m<Sn.length;m++){var C=Sn[m];C.blockedOn===s&&(C.blockedOn=null)}}for(or!==null&&ds(or,s),ir!==null&&ds(ir,s),sr!==null&&ds(sr,s),as.forEach(c),us.forEach(c),m=0;m<ls.length;m++)C=ls[m],C.blockedOn===s&&(C.blockedOn=null);for(;0<ls.length&&(m=ls[0],m.blockedOn===null);)mb(m),m.blockedOn===null&&ls.shift()}function Ga(s,c){var m={};return m[s.toLowerCase()]=c.toLowerCase(),m["Webkit"+s]="webkit"+c,m["Moz"+s]="moz"+c,m}var Jo={animationend:Ga("Animation","AnimationEnd"),animationiteration:Ga("Animation","AnimationIteration"),animationstart:Ga("Animation","AnimationStart"),transitionend:Ga("Transition","TransitionEnd")},ec={},_h={};l&&(_h=document.createElement("div").style,"AnimationEvent"in window||(delete Jo.animationend.animation,delete Jo.animationiteration.animation,delete Jo.animationstart.animation),"TransitionEvent"in window||delete Jo.transitionend.transition);function Ha(s){if(ec[s])return ec[s];if(!Jo[s])return s;var c=Jo[s],m;for(m in c)if(c.hasOwnProperty(m)&&m in _h)return ec[s]=c[m];return s}var Ph=Ha("animationend"),kh=Ha("animationiteration"),Th=Ha("animationstart"),Ah=Ha("transitionend"),Nh=new Map,tc=new Map,yb=["abort","abort",Ph,"animationEnd",kh,"animationIteration",Th,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata","loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",Ah,"transitionEnd","waiting","waiting"];function nc(s,c){for(var m=0;m<s.length;m+=2){var C=s[m],b=s[m+1];b="on"+(b[0].toUpperCase()+b.slice(1)),tc.set(C,c),Nh.set(C,b),a(b,[C])}}var xb=n.unstable_now;xb();var Ve=8;function ei(s){if((1&s)!==0)return Ve=15,1;if((2&s)!==0)return Ve=14,2;if((4&s)!==0)return Ve=13,4;var c=24&s;return c!==0?(Ve=12,c):(s&32)!==0?(Ve=11,32):(c=192&s,c!==0?(Ve=10,c):(s&256)!==0?(Ve=9,256):(c=3584&s,c!==0?(Ve=8,c):(s&4096)!==0?(Ve=7,4096):(c=4186112&s,c!==0?(Ve=6,c):(c=62914560&s,c!==0?(Ve=5,c):s&67108864?(Ve=4,67108864):(s&134217728)!==0?(Ve=3,134217728):(c=805306368&s,c!==0?(Ve=2,c):(1073741824&s)!==0?(Ve=1,1073741824):(Ve=8,s))))))}function vb(s){switch(s){case 99:return 15;case 98:return 10;case 97:case 96:return 8;case 95:return 2;default:return 0}}function Cb(s){switch(s){case 15:case 14:return 99;case 13:case 12:case 11:case 10:return 98;case 9:case 8:case 7:case 6:case 4:case 5:return 97;case 3:case 2:case 1:return 95;case 0:return 90;default:throw Error(r(358,s))}}function fs(s,c){var m=s.pendingLanes;if(m===0)return Ve=0;var C=0,b=0,$=s.expiredLanes,P=s.suspendedLanes,A=s.pingedLanes;if($!==0)C=$,b=Ve=15;else if($=m&134217727,$!==0){var M=$&~P;M!==0?(C=ei(M),b=Ve):(A&=$,A!==0&&(C=ei(A),b=Ve))}else $=m&~P,$!==0?(C=ei($),b=Ve):A!==0&&(C=ei(A),b=Ve);if(C===0)return 0;if(C=31-ar(C),C=m&((0>C?0:1<<C)<<1)-1,c!==0&&c!==C&&(c&P)===0){if(ei(c),b<=Ve)return c;Ve=b}if(c=s.entangledLanes,c!==0)for(s=s.entanglements,c&=C;0<c;)m=31-ar(c),b=1<<m,C|=s[m],c&=~b;return C}function Oh(s){return s=s.pendingLanes&-1073741825,s!==0?s:s&1073741824?1073741824:0}function ja(s,c){switch(s){case 15:return 1;case 14:return 2;case 12:return s=ti(24&~c),s===0?ja(10,c):s;case 10:return s=ti(192&~c),s===0?ja(8,c):s;case 8:return s=ti(3584&~c),s===0&&(s=ti(4186112&~c),s===0&&(s=512)),s;case 2:return c=ti(805306368&~c),c===0&&(c=268435456),c}throw Error(r(358,s))}function ti(s){return s&-s}function rc(s){for(var c=[],m=0;31>m;m++)c.push(s);return c}function Xa(s,c,m){s.pendingLanes|=c;var C=c-1;s.suspendedLanes&=C,s.pingedLanes&=C,s=s.eventTimes,c=31-ar(c),s[c]=m}var ar=Math.clz32?Math.clz32:bb,wb=Math.log,Sb=Math.LN2;function bb(s){return s===0?32:31-(wb(s)/Sb|0)|0}var Ib=n.unstable_UserBlockingPriority,$b=n.unstable_runWithPriority,qa=!0;function Rb(s,c,m,C){Br||jl();var b=oc,$=Br;Br=!0;try{mh(b,s,c,m,C)}finally{(Br=$)||ql()}}function Eb(s,c,m,C){$b(Ib,oc.bind(null,s,c,m,C))}function oc(s,c,m,C){if(qa){var b;if((b=(c&4)===0)&&0<Sn.length&&-1<Ih.indexOf(s))s=Jl(null,s,c,m,C),Sn.push(s);else{var $=ic(s,c,m,C);if($===null)b&&$h(s,C);else{if(b){if(-1<Ih.indexOf(s)){s=Jl($,s,c,m,C),Sn.push(s);return}if(hb($,s,c,m,C))return;$h(s,C)}lm(s,c,C,null,m)}}}}function ic(s,c,m,C){var b=zl(C);if(b=Wr(b),b!==null){var $=Ur(b);if($===null)b=null;else{var P=$.tag;if(P===13){if(b=yh($),b!==null)return b;b=null}else if(P===3){if($.stateNode.hydrate)return $.tag===3?$.stateNode.containerInfo:null;b=null}else $!==b&&(b=null)}}return lm(s,c,C,b,m),null}var ur=null,sc=null,Ka=null;function Dh(){if(Ka)return Ka;var s,c=sc,m=c.length,C,b="value"in ur?ur.value:ur.textContent,$=b.length;for(s=0;s<m&&c[s]===b[s];s++);var P=m-s;for(C=1;C<=P&&c[m-C]===b[$-C];C++);return Ka=b.slice(s,1<C?1-C:void 0)}function Ya(s){var c=s.keyCode;return"charCode"in s?(s=s.charCode,s===0&&c===13&&(s=13)):s=c,s===10&&(s=13),32<=s||s===13?s:0}function Qa(){return!0}function Fh(){return!1}function Mt(s){function c(m,C,b,$,P){this._reactName=m,this._targetInst=b,this.type=C,this.nativeEvent=$,this.target=P,this.currentTarget=null;for(var A in s)s.hasOwnProperty(A)&&(m=s[A],this[A]=m?m($):$[A]);return this.isDefaultPrevented=($.defaultPrevented!=null?$.defaultPrevented:$.returnValue===!1)?Qa:Fh,this.isPropagationStopped=Fh,this}return e(c.prototype,{preventDefault:function(){this.defaultPrevented=!0;var m=this.nativeEvent;m&&(m.preventDefault?m.preventDefault():typeof m.returnValue!="unknown"&&(m.returnValue=!1),this.isDefaultPrevented=Qa)},stopPropagation:function(){var m=this.nativeEvent;m&&(m.stopPropagation?m.stopPropagation():typeof m.cancelBubble!="unknown"&&(m.cancelBubble=!0),this.isPropagationStopped=Qa)},persist:function(){},isPersistent:Qa}),c}var ni={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(s){return s.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},ac=Mt(ni),ps=e({},ni,{view:0,detail:0}),_b=Mt(ps),uc,lc,hs,Za=e({},ps,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:dc,button:0,buttons:0,relatedTarget:function(s){return s.relatedTarget===void 0?s.fromElement===s.srcElement?s.toElement:s.fromElement:s.relatedTarget},movementX:function(s){return"movementX"in s?s.movementX:(s!==hs&&(hs&&s.type==="mousemove"?(uc=s.screenX-hs.screenX,lc=s.screenY-hs.screenY):lc=uc=0,hs=s),uc)},movementY:function(s){return"movementY"in s?s.movementY:lc}}),Lh=Mt(Za),Pb=e({},Za,{dataTransfer:0}),kb=Mt(Pb),Tb=e({},ps,{relatedTarget:0}),cc=Mt(Tb),Ab=e({},ni,{animationName:0,elapsedTime:0,pseudoElement:0}),Nb=Mt(Ab),Ob=e({},ni,{clipboardData:function(s){return"clipboardData"in s?s.clipboardData:window.clipboardData}}),Db=Mt(Ob),Fb=e({},ni,{data:0}),Mh=Mt(Fb),Lb={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},Mb={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},Bb={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function Ub(s){var c=this.nativeEvent;return c.getModifierState?c.getModifierState(s):(s=Bb[s])?!!c[s]:!1}function dc(){return Ub}var Wb=e({},ps,{key:function(s){if(s.key){var c=Lb[s.key]||s.key;if(c!=="Unidentified")return c}return s.type==="keypress"?(s=Ya(s),s===13?"Enter":String.fromCharCode(s)):s.type==="keydown"||s.type==="keyup"?Mb[s.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:dc,charCode:function(s){return s.type==="keypress"?Ya(s):0},keyCode:function(s){return s.type==="keydown"||s.type==="keyup"?s.keyCode:0},which:function(s){return s.type==="keypress"?Ya(s):s.type==="keydown"||s.type==="keyup"?s.keyCode:0}}),Vb=Mt(Wb),zb=e({},Za,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),Bh=Mt(zb),Gb=e({},ps,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:dc}),Hb=Mt(Gb),jb=e({},ni,{propertyName:0,elapsedTime:0,pseudoElement:0}),Xb=Mt(jb),qb=e({},Za,{deltaX:function(s){return"deltaX"in s?s.deltaX:"wheelDeltaX"in s?-s.wheelDeltaX:0},deltaY:function(s){return"deltaY"in s?s.deltaY:"wheelDeltaY"in s?-s.wheelDeltaY:"wheelDelta"in s?-s.wheelDelta:0},deltaZ:0,deltaMode:0}),Kb=Mt(qb),Yb=[9,13,27,32],fc=l&&"CompositionEvent"in window,ms=null;l&&"documentMode"in document&&(ms=document.documentMode);var Qb=l&&"TextEvent"in window&&!ms,Uh=l&&(!fc||ms&&8<ms&&11>=ms),Wh=" ",Vh=!1;function zh(s,c){switch(s){case"keyup":return Yb.indexOf(c.keyCode)!==-1;case"keydown":return c.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function Gh(s){return s=s.detail,typeof s=="object"&&"data"in s?s.data:null}var ri=!1;function Zb(s,c){switch(s){case"compositionend":return Gh(c);case"keypress":return c.which!==32?null:(Vh=!0,Wh);case"textInput":return s=c.data,s===Wh&&Vh?null:s;default:return null}}function Jb(s,c){if(ri)return s==="compositionend"||!fc&&zh(s,c)?(s=Dh(),Ka=sc=ur=null,ri=!1,s):null;switch(s){case"paste":return null;case"keypress":if(!(c.ctrlKey||c.altKey||c.metaKey)||c.ctrlKey&&c.altKey){if(c.char&&1<c.char.length)return c.char;if(c.which)return String.fromCharCode(c.which)}return null;case"compositionend":return Uh&&c.locale!=="ko"?null:c.data;default:return null}}var e2={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function Hh(s){var c=s&&s.nodeName&&s.nodeName.toLowerCase();return c==="input"?!!e2[s.type]:c==="textarea"}function jh(s,c,m,C){ph(C),c=eu(c,"onChange"),0<c.length&&(m=new ac("onChange","change",null,m,C),s.push({event:m,listeners:c}))}var gs=null,ys=null;function t2(s){om(s,0)}function Ja(s){var c=ui(s);if(th(c))return s}function n2(s,c){if(s==="change")return c}var Xh=!1;if(l){var pc;if(l){var hc="oninput"in document;if(!hc){var qh=document.createElement("div");qh.setAttribute("oninput","return;"),hc=typeof qh.oninput=="function"}pc=hc}else pc=!1;Xh=pc&&(!document.documentMode||9<document.documentMode)}function Kh(){gs&&(gs.detachEvent("onpropertychange",Yh),ys=gs=null)}function Yh(s){if(s.propertyName==="value"&&Ja(ys)){var c=[];if(jh(c,ys,s,zl(s)),s=t2,Br)s(c);else{Br=!0;try{Hl(s,c)}finally{Br=!1,ql()}}}}function r2(s,c,m){s==="focusin"?(Kh(),gs=c,ys=m,gs.attachEvent("onpropertychange",Yh)):s==="focusout"&&Kh()}function o2(s){if(s==="selectionchange"||s==="keyup"||s==="keydown")return Ja(ys)}function i2(s,c){if(s==="click")return Ja(c)}function s2(s,c){if(s==="input"||s==="change")return Ja(c)}function a2(s,c){return s===c&&(s!==0||1/s===1/c)||s!==s&&c!==c}var Xt=typeof Object.is=="function"?Object.is:a2,u2=Object.prototype.hasOwnProperty;function xs(s,c){if(Xt(s,c))return!0;if(typeof s!="object"||s===null||typeof c!="object"||c===null)return!1;var m=Object.keys(s),C=Object.keys(c);if(m.length!==C.length)return!1;for(C=0;C<m.length;C++)if(!u2.call(c,m[C])||!Xt(s[m[C]],c[m[C]]))return!1;return!0}function Qh(s){for(;s&&s.firstChild;)s=s.firstChild;return s}function Zh(s,c){var m=Qh(s);s=0;for(var C;m;){if(m.nodeType===3){if(C=s+m.textContent.length,s<=c&&C>=c)return{node:m,offset:c-s};s=C}e:{for(;m;){if(m.nextSibling){m=m.nextSibling;break e}m=m.parentNode}m=void 0}m=Qh(m)}}function Jh(s,c){return s&&c?s===c?!0:s&&s.nodeType===3?!1:c&&c.nodeType===3?Jh(s,c.parentNode):"contains"in s?s.contains(c):s.compareDocumentPosition?!!(s.compareDocumentPosition(c)&16):!1:!1}function em(){for(var s=window,c=Ba();c instanceof s.HTMLIFrameElement;){try{var m=typeof c.contentWindow.location.href=="string"}catch{m=!1}if(m)s=c.contentWindow;else break;c=Ba(s.document)}return c}function mc(s){var c=s&&s.nodeName&&s.nodeName.toLowerCase();return c&&(c==="input"&&(s.type==="text"||s.type==="search"||s.type==="tel"||s.type==="url"||s.type==="password")||c==="textarea"||s.contentEditable==="true")}var l2=l&&"documentMode"in document&&11>=document.documentMode,oi=null,gc=null,vs=null,yc=!1;function tm(s,c,m){var C=m.window===m?m.document:m.nodeType===9?m:m.ownerDocument;yc||oi==null||oi!==Ba(C)||(C=oi,"selectionStart"in C&&mc(C)?C={start:C.selectionStart,end:C.selectionEnd}:(C=(C.ownerDocument&&C.ownerDocument.defaultView||window).getSelection(),C={anchorNode:C.anchorNode,anchorOffset:C.anchorOffset,focusNode:C.focusNode,focusOffset:C.focusOffset}),vs&&xs(vs,C)||(vs=C,C=eu(gc,"onSelect"),0<C.length&&(c=new ac("onSelect","select",null,c,m),s.push({event:c,listeners:C}),c.target=oi)))}nc("cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focusin focus focusout blur input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),0),nc("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1),nc(yb,2);for(var nm="change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),xc=0;xc<nm.length;xc++)tc.set(nm[xc],0);u("onMouseEnter",["mouseout","mouseover"]),u("onMouseLeave",["mouseout","mouseover"]),u("onPointerEnter",["pointerout","pointerover"]),u("onPointerLeave",["pointerout","pointerover"]),a("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),a("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),a("onBeforeInput",["compositionend","keypress","textInput","paste"]),a("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),a("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),a("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var Cs="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),c2=new Set("cancel close invalid load scroll toggle".split(" ").concat(Cs));function rm(s,c,m){var C=s.type||"unknown-event";s.currentTarget=m,fb(C,c,void 0,s),s.currentTarget=null}function om(s,c){c=(c&4)!==0;for(var m=0;m<s.length;m++){var C=s[m],b=C.event;C=C.listeners;e:{var $=void 0;if(c)for(var P=C.length-1;0<=P;P--){var A=C[P],M=A.instance,q=A.currentTarget;if(A=A.listener,M!==$&&b.isPropagationStopped())break e;rm(b,A,q),$=M}else for(P=0;P<C.length;P++){if(A=C[P],M=A.instance,q=A.currentTarget,A=A.listener,M!==$&&b.isPropagationStopped())break e;rm(b,A,q),$=M}}}if(Va)throw s=Yl,Va=!1,Yl=null,s}function ze(s,c){var m=mm(c),C=s+"__bubble";m.has(C)||(um(c,s,2,!1),m.add(C))}var im="_reactListening"+Math.random().toString(36).slice(2);function sm(s){s[im]||(s[im]=!0,o.forEach(function(c){c2.has(c)||am(c,!1,s,null),am(c,!0,s,null)}))}function am(s,c,m,C){var b=4<arguments.length&&arguments[4]!==void 0?arguments[4]:0,$=m;s==="selectionchange"&&m.nodeType!==9&&($=m.ownerDocument);var P=mm($),A=s+"__"+(c?"capture":"bubble");P.has(A)||(c&&(b|=4),um($,s,b,c),P.add(A))}function um(s,c,m,C){var b=tc.get(c);switch(b===void 0?2:b){case 0:b=Rb;break;case 1:b=Eb;break;default:b=oc}m=b.bind(null,c,m,s),b=void 0,!Kl||c!=="touchstart"&&c!=="touchmove"&&c!=="wheel"||(b=!0),C?b!==void 0?s.addEventListener(c,m,{capture:!0,passive:b}):s.addEventListener(c,m,!0):b!==void 0?s.addEventListener(c,m,{passive:b}):s.addEventListener(c,m,!1)}function lm(s,c,m,C,b){var $=C;if((c&1)===0&&(c&2)===0&&C!==null)e:for(;;){if(C===null)return;var P=C.tag;if(P===3||P===4){var A=C.stateNode.containerInfo;if(A===b||A.nodeType===8&&A.parentNode===b)break;if(P===4)for(P=C.return;P!==null;){var M=P.tag;if((M===3||M===4)&&(M=P.stateNode.containerInfo,M===b||M.nodeType===8&&M.parentNode===b))return;P=P.return}for(;A!==null;){if(P=Wr(A),P===null)return;if(M=P.tag,M===5||M===6){C=$=P;continue e}A=A.parentNode}}C=C.return}ub(function(){var q=$,de=zl(m),Ie=[];e:{var oe=Nh.get(s);if(oe!==void 0){var ye=ac,be=s;switch(s){case"keypress":if(Ya(m)===0)break e;case"keydown":case"keyup":ye=Vb;break;case"focusin":be="focus",ye=cc;break;case"focusout":be="blur",ye=cc;break;case"beforeblur":case"afterblur":ye=cc;break;case"click":if(m.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":ye=Lh;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":ye=kb;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":ye=Hb;break;case Ph:case kh:case Th:ye=Nb;break;case Ah:ye=Xb;break;case"scroll":ye=_b;break;case"wheel":ye=Kb;break;case"copy":case"cut":case"paste":ye=Db;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":ye=Bh}var we=(c&4)!==0,z=!we&&s==="scroll",B=we?oe!==null?oe+"Capture":null:oe;we=[];for(var W=q,ee;W!==null;){ee=W;var te=ee.stateNode;if(ee.tag===5&&te!==null&&(ee=te,B!==null&&(te=os(W,B),te!=null&&we.push(ws(W,te,ee)))),z)break;W=W.return}0<we.length&&(oe=new ye(oe,be,null,m,de),Ie.push({event:oe,listeners:we}))}}if((c&7)===0){e:{if(oe=s==="mouseover"||s==="pointerover",ye=s==="mouseout"||s==="pointerout",oe&&(c&16)===0&&(be=m.relatedTarget||m.fromElement)&&(Wr(be)||be[ai]))break e;if((ye||oe)&&(oe=de.window===de?de:(oe=de.ownerDocument)?oe.defaultView||oe.parentWindow:window,ye?(be=m.relatedTarget||m.toElement,ye=q,be=be?Wr(be):null,be!==null&&(z=Ur(be),be!==z||be.tag!==5&&be.tag!==6)&&(be=null)):(ye=null,be=q),ye!==be)){if(we=Lh,te="onMouseLeave",B="onMouseEnter",W="mouse",(s==="pointerout"||s==="pointerover")&&(we=Bh,te="onPointerLeave",B="onPointerEnter",W="pointer"),z=ye==null?oe:ui(ye),ee=be==null?oe:ui(be),oe=new we(te,W+"leave",ye,m,de),oe.target=z,oe.relatedTarget=ee,te=null,Wr(de)===q&&(we=new we(B,W+"enter",be,m,de),we.target=ee,we.relatedTarget=z,te=we),z=te,ye&&be)t:{for(we=ye,B=be,W=0,ee=we;ee;ee=ii(ee))W++;for(ee=0,te=B;te;te=ii(te))ee++;for(;0<W-ee;)we=ii(we),W--;for(;0<ee-W;)B=ii(B),ee--;for(;W--;){if(we===B||B!==null&&we===B.alternate)break t;we=ii(we),B=ii(B)}we=null}else we=null;ye!==null&&cm(Ie,oe,ye,we,!1),be!==null&&z!==null&&cm(Ie,z,be,we,!0)}}e:{if(oe=q?ui(q):window,ye=oe.nodeName&&oe.nodeName.toLowerCase(),ye==="select"||ye==="input"&&oe.type==="file")var $e=n2;else if(Hh(oe))if(Xh)$e=s2;else{$e=o2;var me=r2}else(ye=oe.nodeName)&&ye.toLowerCase()==="input"&&(oe.type==="checkbox"||oe.type==="radio")&&($e=i2);if($e&&($e=$e(s,q))){jh(Ie,$e,m,de);break e}me&&me(s,oe,q),s==="focusout"&&(me=oe._wrapperState)&&me.controlled&&oe.type==="number"&&Fl(oe,"number",oe.value)}switch(me=q?ui(q):window,s){case"focusin":(Hh(me)||me.contentEditable==="true")&&(oi=me,gc=q,vs=null);break;case"focusout":vs=gc=oi=null;break;case"mousedown":yc=!0;break;case"contextmenu":case"mouseup":case"dragend":yc=!1,tm(Ie,m,de);break;case"selectionchange":if(l2)break;case"keydown":case"keyup":tm(Ie,m,de)}var Re;if(fc)e:{switch(s){case"compositionstart":var Pe="onCompositionStart";break e;case"compositionend":Pe="onCompositionEnd";break e;case"compositionupdate":Pe="onCompositionUpdate";break e}Pe=void 0}else ri?zh(s,m)&&(Pe="onCompositionEnd"):s==="keydown"&&m.keyCode===229&&(Pe="onCompositionStart");Pe&&(Uh&&m.locale!=="ko"&&(ri||Pe!=="onCompositionStart"?Pe==="onCompositionEnd"&&ri&&(Re=Dh()):(ur=de,sc="value"in ur?ur.value:ur.textContent,ri=!0)),me=eu(q,Pe),0<me.length&&(Pe=new Mh(Pe,s,null,m,de),Ie.push({event:Pe,listeners:me}),Re?Pe.data=Re:(Re=Gh(m),Re!==null&&(Pe.data=Re)))),(Re=Qb?Zb(s,m):Jb(s,m))&&(q=eu(q,"onBeforeInput"),0<q.length&&(de=new Mh("onBeforeInput","beforeinput",null,m,de),Ie.push({event:de,listeners:q}),de.data=Re))}om(Ie,c)})}function ws(s,c,m){return{instance:s,listener:c,currentTarget:m}}function eu(s,c){for(var m=c+"Capture",C=[];s!==null;){var b=s,$=b.stateNode;b.tag===5&&$!==null&&(b=$,$=os(s,m),$!=null&&C.unshift(ws(s,$,b)),$=os(s,c),$!=null&&C.push(ws(s,$,b))),s=s.return}return C}function ii(s){if(s===null)return null;do s=s.return;while(s&&s.tag!==5);return s||null}function cm(s,c,m,C,b){for(var $=c._reactName,P=[];m!==null&&m!==C;){var A=m,M=A.alternate,q=A.stateNode;if(M!==null&&M===C)break;A.tag===5&&q!==null&&(A=q,b?(M=os(m,$),M!=null&&P.unshift(ws(m,M,A))):b||(M=os(m,$),M!=null&&P.push(ws(m,M,A)))),m=m.return}P.length!==0&&s.push({event:c,listeners:P})}function tu(){}var vc=null,Cc=null;function dm(s,c){switch(s){case"button":case"input":case"select":case"textarea":return!!c.autoFocus}return!1}function wc(s,c){return s==="textarea"||s==="option"||s==="noscript"||typeof c.children=="string"||typeof c.children=="number"||typeof c.dangerouslySetInnerHTML=="object"&&c.dangerouslySetInnerHTML!==null&&c.dangerouslySetInnerHTML.__html!=null}var fm=typeof setTimeout=="function"?setTimeout:void 0,d2=typeof clearTimeout=="function"?clearTimeout:void 0;function Sc(s){s.nodeType===1?s.textContent="":s.nodeType===9&&(s=s.body,s!=null&&(s.textContent=""))}function si(s){for(;s!=null;s=s.nextSibling){var c=s.nodeType;if(c===1||c===3)break}return s}function pm(s){s=s.previousSibling;for(var c=0;s;){if(s.nodeType===8){var m=s.data;if(m==="$"||m==="$!"||m==="$?"){if(c===0)return s;c--}else m==="/$"&&c++}s=s.previousSibling}return null}var bc=0;function f2(s){return{$$typeof:ne,toString:s,valueOf:s}}var nu=Math.random().toString(36).slice(2),lr="__reactFiber$"+nu,ru="__reactProps$"+nu,ai="__reactContainer$"+nu,hm="__reactEvents$"+nu;function Wr(s){var c=s[lr];if(c)return c;for(var m=s.parentNode;m;){if(c=m[ai]||m[lr]){if(m=c.alternate,c.child!==null||m!==null&&m.child!==null)for(s=pm(s);s!==null;){if(m=s[lr])return m;s=pm(s)}return c}s=m,m=s.parentNode}return null}function Ss(s){return s=s[lr]||s[ai],!s||s.tag!==5&&s.tag!==6&&s.tag!==13&&s.tag!==3?null:s}function ui(s){if(s.tag===5||s.tag===6)return s.stateNode;throw Error(r(33))}function ou(s){return s[ru]||null}function mm(s){var c=s[hm];return c===void 0&&(c=s[hm]=new Set),c}var Ic=[],li=-1;function cr(s){return{current:s}}function Ge(s){0>li||(s.current=Ic[li],Ic[li]=null,li--)}function Ye(s,c){li++,Ic[li]=s.current,s.current=c}var dr={},ht=cr(dr),Pt=cr(!1),Vr=dr;function ci(s,c){var m=s.type.contextTypes;if(!m)return dr;var C=s.stateNode;if(C&&C.__reactInternalMemoizedUnmaskedChildContext===c)return C.__reactInternalMemoizedMaskedChildContext;var b={},$;for($ in m)b[$]=c[$];return C&&(s=s.stateNode,s.__reactInternalMemoizedUnmaskedChildContext=c,s.__reactInternalMemoizedMaskedChildContext=b),b}function kt(s){return s=s.childContextTypes,s!=null}function iu(){Ge(Pt),Ge(ht)}function gm(s,c,m){if(ht.current!==dr)throw Error(r(168));Ye(ht,c),Ye(Pt,m)}function ym(s,c,m){var C=s.stateNode;if(s=c.childContextTypes,typeof C.getChildContext!="function")return m;C=C.getChildContext();for(var b in C)if(!(b in s))throw Error(r(108,Ko(c)||"Unknown",b));return e({},m,C)}function su(s){return s=(s=s.stateNode)&&s.__reactInternalMemoizedMergedChildContext||dr,Vr=ht.current,Ye(ht,s),Ye(Pt,Pt.current),!0}function xm(s,c,m){var C=s.stateNode;if(!C)throw Error(r(169));m?(s=ym(s,c,Vr),C.__reactInternalMemoizedMergedChildContext=s,Ge(Pt),Ge(ht),Ye(ht,s)):Ge(Pt),Ye(Pt,m)}var $c=null,zr=null,p2=n.unstable_runWithPriority,Rc=n.unstable_scheduleCallback,Ec=n.unstable_cancelCallback,h2=n.unstable_shouldYield,vm=n.unstable_requestPaint,_c=n.unstable_now,m2=n.unstable_getCurrentPriorityLevel,au=n.unstable_ImmediatePriority,Cm=n.unstable_UserBlockingPriority,wm=n.unstable_NormalPriority,Sm=n.unstable_LowPriority,bm=n.unstable_IdlePriority,Pc={},g2=vm!==void 0?vm:function(){},Mn=null,uu=null,kc=!1,Im=_c(),mt=1e4>Im?_c:function(){return _c()-Im};function di(){switch(m2()){case au:return 99;case Cm:return 98;case wm:return 97;case Sm:return 96;case bm:return 95;default:throw Error(r(332))}}function $m(s){switch(s){case 99:return au;case 98:return Cm;case 97:return wm;case 96:return Sm;case 95:return bm;default:throw Error(r(332))}}function Gr(s,c){return s=$m(s),p2(s,c)}function bs(s,c,m){return s=$m(s),Rc(s,c,m)}function bn(){if(uu!==null){var s=uu;uu=null,Ec(s)}Rm()}function Rm(){if(!kc&&Mn!==null){kc=!0;var s=0;try{var c=Mn;Gr(99,function(){for(;s<c.length;s++){var m=c[s];do m=m(!0);while(m!==null)}}),Mn=null}catch(m){throw Mn!==null&&(Mn=Mn.slice(s+1)),Rc(au,bn),m}finally{kc=!1}}}var y2=R.ReactCurrentBatchConfig;function on(s,c){if(s&&s.defaultProps){c=e({},c),s=s.defaultProps;for(var m in s)c[m]===void 0&&(c[m]=s[m]);return c}return c}var lu=cr(null),cu=null,fi=null,du=null;function Tc(){du=fi=cu=null}function Ac(s){var c=lu.current;Ge(lu),s.type._context._currentValue=c}function Em(s,c){for(;s!==null;){var m=s.alternate;if((s.childLanes&c)===c){if(m===null||(m.childLanes&c)===c)break;m.childLanes|=c}else s.childLanes|=c,m!==null&&(m.childLanes|=c);s=s.return}}function pi(s,c){cu=s,du=fi=null,s=s.dependencies,s!==null&&s.firstContext!==null&&((s.lanes&c)!==0&&(sn=!0),s.firstContext=null)}function qt(s,c){if(du!==s&&c!==!1&&c!==0)if((typeof c!="number"||c===1073741823)&&(du=s,c=1073741823),c={context:s,observedBits:c,next:null},fi===null){if(cu===null)throw Error(r(308));fi=c,cu.dependencies={lanes:0,firstContext:c,responders:null}}else fi=fi.next=c;return s._currentValue}var fr=!1;function Nc(s){s.updateQueue={baseState:s.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null},effects:null}}function _m(s,c){s=s.updateQueue,c.updateQueue===s&&(c.updateQueue={baseState:s.baseState,firstBaseUpdate:s.firstBaseUpdate,lastBaseUpdate:s.lastBaseUpdate,shared:s.shared,effects:s.effects})}function pr(s,c){return{eventTime:s,lane:c,tag:0,payload:null,callback:null,next:null}}function hr(s,c){if(s=s.updateQueue,s!==null){s=s.shared;var m=s.pending;m===null?c.next=c:(c.next=m.next,m.next=c),s.pending=c}}function Pm(s,c){var m=s.updateQueue,C=s.alternate;if(C!==null&&(C=C.updateQueue,m===C)){var b=null,$=null;if(m=m.firstBaseUpdate,m!==null){do{var P={eventTime:m.eventTime,lane:m.lane,tag:m.tag,payload:m.payload,callback:m.callback,next:null};$===null?b=$=P:$=$.next=P,m=m.next}while(m!==null);$===null?b=$=c:$=$.next=c}else b=$=c;m={baseState:C.baseState,firstBaseUpdate:b,lastBaseUpdate:$,shared:C.shared,effects:C.effects},s.updateQueue=m;return}s=m.lastBaseUpdate,s===null?m.firstBaseUpdate=c:s.next=c,m.lastBaseUpdate=c}function Is(s,c,m,C){var b=s.updateQueue;fr=!1;var $=b.firstBaseUpdate,P=b.lastBaseUpdate,A=b.shared.pending;if(A!==null){b.shared.pending=null;var M=A,q=M.next;M.next=null,P===null?$=q:P.next=q,P=M;var de=s.alternate;if(de!==null){de=de.updateQueue;var Ie=de.lastBaseUpdate;Ie!==P&&(Ie===null?de.firstBaseUpdate=q:Ie.next=q,de.lastBaseUpdate=M)}}if($!==null){Ie=b.baseState,P=0,de=q=M=null;do{A=$.lane;var oe=$.eventTime;if((C&A)===A){de!==null&&(de=de.next={eventTime:oe,lane:0,tag:$.tag,payload:$.payload,callback:$.callback,next:null});e:{var ye=s,be=$;switch(A=c,oe=m,be.tag){case 1:if(ye=be.payload,typeof ye=="function"){Ie=ye.call(oe,Ie,A);break e}Ie=ye;break e;case 3:ye.flags=ye.flags&-4097|64;case 0:if(ye=be.payload,A=typeof ye=="function"?ye.call(oe,Ie,A):ye,A==null)break e;Ie=e({},Ie,A);break e;case 2:fr=!0}}$.callback!==null&&(s.flags|=32,A=b.effects,A===null?b.effects=[$]:A.push($))}else oe={eventTime:oe,lane:A,tag:$.tag,payload:$.payload,callback:$.callback,next:null},de===null?(q=de=oe,M=Ie):de=de.next=oe,P|=A;if($=$.next,$===null){if(A=b.shared.pending,A===null)break;$=A.next,A.next=null,b.lastBaseUpdate=A,b.shared.pending=null}}while(!0);de===null&&(M=Ie),b.baseState=M,b.firstBaseUpdate=q,b.lastBaseUpdate=de,Fs|=P,s.lanes=P,s.memoizedState=Ie}}function km(s,c,m){if(s=c.effects,c.effects=null,s!==null)for(c=0;c<s.length;c++){var C=s[c],b=C.callback;if(b!==null){if(C.callback=null,C=m,typeof b!="function")throw Error(r(191,b));b.call(C)}}}var Tm=new t.Component().refs;function fu(s,c,m,C){c=s.memoizedState,m=m(C,c),m=m==null?c:e({},c,m),s.memoizedState=m,s.lanes===0&&(s.updateQueue.baseState=m)}var pu={isMounted:function(s){return(s=s._reactInternals)?Ur(s)===s:!1},enqueueSetState:function(s,c,m){s=s._reactInternals;var C=Bt(),b=yr(s),$=pr(C,b);$.payload=c,m!=null&&($.callback=m),hr(s,$),xr(s,b,C)},enqueueReplaceState:function(s,c,m){s=s._reactInternals;var C=Bt(),b=yr(s),$=pr(C,b);$.tag=1,$.payload=c,m!=null&&($.callback=m),hr(s,$),xr(s,b,C)},enqueueForceUpdate:function(s,c){s=s._reactInternals;var m=Bt(),C=yr(s),b=pr(m,C);b.tag=2,c!=null&&(b.callback=c),hr(s,b),xr(s,C,m)}};function Am(s,c,m,C,b,$,P){return s=s.stateNode,typeof s.shouldComponentUpdate=="function"?s.shouldComponentUpdate(C,$,P):c.prototype&&c.prototype.isPureReactComponent?!xs(m,C)||!xs(b,$):!0}function Nm(s,c,m){var C=!1,b=dr,$=c.contextType;return typeof $=="object"&&$!==null?$=qt($):(b=kt(c)?Vr:ht.current,C=c.contextTypes,$=(C=C!=null)?ci(s,b):dr),c=new c(m,$),s.memoizedState=c.state!==null&&c.state!==void 0?c.state:null,c.updater=pu,s.stateNode=c,c._reactInternals=s,C&&(s=s.stateNode,s.__reactInternalMemoizedUnmaskedChildContext=b,s.__reactInternalMemoizedMaskedChildContext=$),c}function Om(s,c,m,C){s=c.state,typeof c.componentWillReceiveProps=="function"&&c.componentWillReceiveProps(m,C),typeof c.UNSAFE_componentWillReceiveProps=="function"&&c.UNSAFE_componentWillReceiveProps(m,C),c.state!==s&&pu.enqueueReplaceState(c,c.state,null)}function Oc(s,c,m,C){var b=s.stateNode;b.props=m,b.state=s.memoizedState,b.refs=Tm,Nc(s);var $=c.contextType;typeof $=="object"&&$!==null?b.context=qt($):($=kt(c)?Vr:ht.current,b.context=ci(s,$)),Is(s,m,b,C),b.state=s.memoizedState,$=c.getDerivedStateFromProps,typeof $=="function"&&(fu(s,c,$,m),b.state=s.memoizedState),typeof c.getDerivedStateFromProps=="function"||typeof b.getSnapshotBeforeUpdate=="function"||typeof b.UNSAFE_componentWillMount!="function"&&typeof b.componentWillMount!="function"||(c=b.state,typeof b.componentWillMount=="function"&&b.componentWillMount(),typeof b.UNSAFE_componentWillMount=="function"&&b.UNSAFE_componentWillMount(),c!==b.state&&pu.enqueueReplaceState(b,b.state,null),Is(s,m,b,C),b.state=s.memoizedState),typeof b.componentDidMount=="function"&&(s.flags|=4)}var hu=Array.isArray;function $s(s,c,m){if(s=m.ref,s!==null&&typeof s!="function"&&typeof s!="object"){if(m._owner){if(m=m._owner,m){if(m.tag!==1)throw Error(r(309));var C=m.stateNode}if(!C)throw Error(r(147,s));var b=""+s;return c!==null&&c.ref!==null&&typeof c.ref=="function"&&c.ref._stringRef===b?c.ref:(c=function($){var P=C.refs;P===Tm&&(P=C.refs={}),$===null?delete P[b]:P[b]=$},c._stringRef=b,c)}if(typeof s!="string")throw Error(r(284));if(!m._owner)throw Error(r(290,s))}return s}function mu(s,c){if(s.type!=="textarea")throw Error(r(31,Object.prototype.toString.call(c)==="[object Object]"?"object with keys {"+Object.keys(c).join(", ")+"}":c))}function Dm(s){function c(z,B){if(s){var W=z.lastEffect;W!==null?(W.nextEffect=B,z.lastEffect=B):z.firstEffect=z.lastEffect=B,B.nextEffect=null,B.flags=8}}function m(z,B){if(!s)return null;for(;B!==null;)c(z,B),B=B.sibling;return null}function C(z,B){for(z=new Map;B!==null;)B.key!==null?z.set(B.key,B):z.set(B.index,B),B=B.sibling;return z}function b(z,B){return z=wr(z,B),z.index=0,z.sibling=null,z}function $(z,B,W){return z.index=W,s?(W=z.alternate,W!==null?(W=W.index,W<B?(z.flags=2,B):W):(z.flags=2,B)):B}function P(z){return s&&z.alternate===null&&(z.flags=2),z}function A(z,B,W,ee){return B===null||B.tag!==6?(B=gd(W,z.mode,ee),B.return=z,B):(B=b(B,W),B.return=z,B)}function M(z,B,W,ee){return B!==null&&B.elementType===W.type?(ee=b(B,W.props),ee.ref=$s(z,B,W),ee.return=z,ee):(ee=Nu(W.type,W.key,W.props,null,z.mode,ee),ee.ref=$s(z,B,W),ee.return=z,ee)}function q(z,B,W,ee){return B===null||B.tag!==4||B.stateNode.containerInfo!==W.containerInfo||B.stateNode.implementation!==W.implementation?(B=yd(W,z.mode,ee),B.return=z,B):(B=b(B,W.children||[]),B.return=z,B)}function de(z,B,W,ee,te){return B===null||B.tag!==7?(B=wi(W,z.mode,ee,te),B.return=z,B):(B=b(B,W),B.return=z,B)}function Ie(z,B,W){if(typeof B=="string"||typeof B=="number")return B=gd(""+B,z.mode,W),B.return=z,B;if(typeof B=="object"&&B!==null){switch(B.$$typeof){case T:return W=Nu(B.type,B.key,B.props,null,z.mode,W),W.ref=$s(z,null,B),W.return=z,W;case k:return B=yd(B,z.mode,W),B.return=z,B}if(hu(B)||ve(B))return B=wi(B,z.mode,W,null),B.return=z,B;mu(z,B)}return null}function oe(z,B,W,ee){var te=B!==null?B.key:null;if(typeof W=="string"||typeof W=="number")return te!==null?null:A(z,B,""+W,ee);if(typeof W=="object"&&W!==null){switch(W.$$typeof){case T:return W.key===te?W.type===D?de(z,B,W.props.children,ee,te):M(z,B,W,ee):null;case k:return W.key===te?q(z,B,W,ee):null}if(hu(W)||ve(W))return te!==null?null:de(z,B,W,ee,null);mu(z,W)}return null}function ye(z,B,W,ee,te){if(typeof ee=="string"||typeof ee=="number")return z=z.get(W)||null,A(B,z,""+ee,te);if(typeof ee=="object"&&ee!==null){switch(ee.$$typeof){case T:return z=z.get(ee.key===null?W:ee.key)||null,ee.type===D?de(B,z,ee.props.children,te,ee.key):M(B,z,ee,te);case k:return z=z.get(ee.key===null?W:ee.key)||null,q(B,z,ee,te)}if(hu(ee)||ve(ee))return z=z.get(W)||null,de(B,z,ee,te,null);mu(B,ee)}return null}function be(z,B,W,ee){for(var te=null,$e=null,me=B,Re=B=0,Pe=null;me!==null&&Re<W.length;Re++){me.index>Re?(Pe=me,me=null):Pe=me.sibling;var Ee=oe(z,me,W[Re],ee);if(Ee===null){me===null&&(me=Pe);break}s&&me&&Ee.alternate===null&&c(z,me),B=$(Ee,B,Re),$e===null?te=Ee:$e.sibling=Ee,$e=Ee,me=Pe}if(Re===W.length)return m(z,me),te;if(me===null){for(;Re<W.length;Re++)me=Ie(z,W[Re],ee),me!==null&&(B=$(me,B,Re),$e===null?te=me:$e.sibling=me,$e=me);return te}for(me=C(z,me);Re<W.length;Re++)Pe=ye(me,z,Re,W[Re],ee),Pe!==null&&(s&&Pe.alternate!==null&&me.delete(Pe.key===null?Re:Pe.key),B=$(Pe,B,Re),$e===null?te=Pe:$e.sibling=Pe,$e=Pe);return s&&me.forEach(function(Sr){return c(z,Sr)}),te}function we(z,B,W,ee){var te=ve(W);if(typeof te!="function")throw Error(r(150));if(W=te.call(W),W==null)throw Error(r(151));for(var $e=te=null,me=B,Re=B=0,Pe=null,Ee=W.next();me!==null&&!Ee.done;Re++,Ee=W.next()){me.index>Re?(Pe=me,me=null):Pe=me.sibling;var Sr=oe(z,me,Ee.value,ee);if(Sr===null){me===null&&(me=Pe);break}s&&me&&Sr.alternate===null&&c(z,me),B=$(Sr,B,Re),$e===null?te=Sr:$e.sibling=Sr,$e=Sr,me=Pe}if(Ee.done)return m(z,me),te;if(me===null){for(;!Ee.done;Re++,Ee=W.next())Ee=Ie(z,Ee.value,ee),Ee!==null&&(B=$(Ee,B,Re),$e===null?te=Ee:$e.sibling=Ee,$e=Ee);return te}for(me=C(z,me);!Ee.done;Re++,Ee=W.next())Ee=ye(me,z,Re,Ee.value,ee),Ee!==null&&(s&&Ee.alternate!==null&&me.delete(Ee.key===null?Re:Ee.key),B=$(Ee,B,Re),$e===null?te=Ee:$e.sibling=Ee,$e=Ee);return s&&me.forEach(function(q2){return c(z,q2)}),te}return function(z,B,W,ee){var te=typeof W=="object"&&W!==null&&W.type===D&&W.key===null;te&&(W=W.props.children);var $e=typeof W=="object"&&W!==null;if($e)switch(W.$$typeof){case T:e:{for($e=W.key,te=B;te!==null;){if(te.key===$e){switch(te.tag){case 7:if(W.type===D){m(z,te.sibling),B=b(te,W.props.children),B.return=z,z=B;break e}break;default:if(te.elementType===W.type){m(z,te.sibling),B=b(te,W.props),B.ref=$s(z,te,W),B.return=z,z=B;break e}}m(z,te);break}else c(z,te);te=te.sibling}W.type===D?(B=wi(W.props.children,z.mode,ee,W.key),B.return=z,z=B):(ee=Nu(W.type,W.key,W.props,null,z.mode,ee),ee.ref=$s(z,B,W),ee.return=z,z=ee)}return P(z);case k:e:{for(te=W.key;B!==null;){if(B.key===te)if(B.tag===4&&B.stateNode.containerInfo===W.containerInfo&&B.stateNode.implementation===W.implementation){m(z,B.sibling),B=b(B,W.children||[]),B.return=z,z=B;break e}else{m(z,B);break}else c(z,B);B=B.sibling}B=yd(W,z.mode,ee),B.return=z,z=B}return P(z)}if(typeof W=="string"||typeof W=="number")return W=""+W,B!==null&&B.tag===6?(m(z,B.sibling),B=b(B,W),B.return=z,z=B):(m(z,B),B=gd(W,z.mode,ee),B.return=z,z=B),P(z);if(hu(W))return be(z,B,W,ee);if(ve(W))return we(z,B,W,ee);if($e&&mu(z,W),typeof W>"u"&&!te)switch(z.tag){case 1:case 22:case 0:case 11:case 15:throw Error(r(152,Ko(z.type)||"Component"))}return m(z,B)}}var gu=Dm(!0),Fm=Dm(!1),Rs={},In=cr(Rs),Es=cr(Rs),_s=cr(Rs);function Hr(s){if(s===Rs)throw Error(r(174));return s}function Dc(s,c){switch(Ye(_s,c),Ye(Es,s),Ye(In,Rs),s=c.nodeType,s){case 9:case 11:c=(c=c.documentElement)?c.namespaceURI:Ul(null,"");break;default:s=s===8?c.parentNode:c,c=s.namespaceURI||null,s=s.tagName,c=Ul(c,s)}Ge(In),Ye(In,c)}function hi(){Ge(In),Ge(Es),Ge(_s)}function Lm(s){Hr(_s.current);var c=Hr(In.current),m=Ul(c,s.type);c!==m&&(Ye(Es,s),Ye(In,m))}function Fc(s){Es.current===s&&(Ge(In),Ge(Es))}var Qe=cr(0);function yu(s){for(var c=s;c!==null;){if(c.tag===13){var m=c.memoizedState;if(m!==null&&(m=m.dehydrated,m===null||m.data==="$?"||m.data==="$!"))return c}else if(c.tag===19&&c.memoizedProps.revealOrder!==void 0){if((c.flags&64)!==0)return c}else if(c.child!==null){c.child.return=c,c=c.child;continue}if(c===s)break;for(;c.sibling===null;){if(c.return===null||c.return===s)return null;c=c.return}c.sibling.return=c.return,c=c.sibling}return null}var Bn=null,mr=null,$n=!1;function Mm(s,c){var m=Qt(5,null,null,0);m.elementType="DELETED",m.type="DELETED",m.stateNode=c,m.return=s,m.flags=8,s.lastEffect!==null?(s.lastEffect.nextEffect=m,s.lastEffect=m):s.firstEffect=s.lastEffect=m}function Bm(s,c){switch(s.tag){case 5:var m=s.type;return c=c.nodeType!==1||m.toLowerCase()!==c.nodeName.toLowerCase()?null:c,c!==null?(s.stateNode=c,!0):!1;case 6:return c=s.pendingProps===""||c.nodeType!==3?null:c,c!==null?(s.stateNode=c,!0):!1;case 13:return!1;default:return!1}}function Lc(s){if($n){var c=mr;if(c){var m=c;if(!Bm(s,c)){if(c=si(m.nextSibling),!c||!Bm(s,c)){s.flags=s.flags&-1025|2,$n=!1,Bn=s;return}Mm(Bn,m)}Bn=s,mr=si(c.firstChild)}else s.flags=s.flags&-1025|2,$n=!1,Bn=s}}function Um(s){for(s=s.return;s!==null&&s.tag!==5&&s.tag!==3&&s.tag!==13;)s=s.return;Bn=s}function xu(s){if(s!==Bn)return!1;if(!$n)return Um(s),$n=!0,!1;var c=s.type;if(s.tag!==5||c!=="head"&&c!=="body"&&!wc(c,s.memoizedProps))for(c=mr;c;)Mm(s,c),c=si(c.nextSibling);if(Um(s),s.tag===13){if(s=s.memoizedState,s=s!==null?s.dehydrated:null,!s)throw Error(r(317));e:{for(s=s.nextSibling,c=0;s;){if(s.nodeType===8){var m=s.data;if(m==="/$"){if(c===0){mr=si(s.nextSibling);break e}c--}else m!=="$"&&m!=="$!"&&m!=="$?"||c++}s=s.nextSibling}mr=null}}else mr=Bn?si(s.stateNode.nextSibling):null;return!0}function Mc(){mr=Bn=null,$n=!1}var mi=[];function Bc(){for(var s=0;s<mi.length;s++)mi[s]._workInProgressVersionPrimary=null;mi.length=0}var Ps=R.ReactCurrentDispatcher,Kt=R.ReactCurrentBatchConfig,ks=0,et=null,gt=null,lt=null,vu=!1,Ts=!1;function Tt(){throw Error(r(321))}function Uc(s,c){if(c===null)return!1;for(var m=0;m<c.length&&m<s.length;m++)if(!Xt(s[m],c[m]))return!1;return!0}function Wc(s,c,m,C,b,$){if(ks=$,et=c,c.memoizedState=null,c.updateQueue=null,c.lanes=0,Ps.current=s===null||s.memoizedState===null?v2:C2,s=m(C,b),Ts){$=0;do{if(Ts=!1,!(25>$))throw Error(r(301));$+=1,lt=gt=null,c.updateQueue=null,Ps.current=w2,s=m(C,b)}while(Ts)}if(Ps.current=bu,c=gt!==null&&gt.next!==null,ks=0,lt=gt=et=null,vu=!1,c)throw Error(r(300));return s}function jr(){var s={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return lt===null?et.memoizedState=lt=s:lt=lt.next=s,lt}function Xr(){if(gt===null){var s=et.alternate;s=s!==null?s.memoizedState:null}else s=gt.next;var c=lt===null?et.memoizedState:lt.next;if(c!==null)lt=c,gt=s;else{if(s===null)throw Error(r(310));gt=s,s={memoizedState:gt.memoizedState,baseState:gt.baseState,baseQueue:gt.baseQueue,queue:gt.queue,next:null},lt===null?et.memoizedState=lt=s:lt=lt.next=s}return lt}function Rn(s,c){return typeof c=="function"?c(s):c}function As(s){var c=Xr(),m=c.queue;if(m===null)throw Error(r(311));m.lastRenderedReducer=s;var C=gt,b=C.baseQueue,$=m.pending;if($!==null){if(b!==null){var P=b.next;b.next=$.next,$.next=P}C.baseQueue=b=$,m.pending=null}if(b!==null){b=b.next,C=C.baseState;var A=P=$=null,M=b;do{var q=M.lane;if((ks&q)===q)A!==null&&(A=A.next={lane:0,action:M.action,eagerReducer:M.eagerReducer,eagerState:M.eagerState,next:null}),C=M.eagerReducer===s?M.eagerState:s(C,M.action);else{var de={lane:q,action:M.action,eagerReducer:M.eagerReducer,eagerState:M.eagerState,next:null};A===null?(P=A=de,$=C):A=A.next=de,et.lanes|=q,Fs|=q}M=M.next}while(M!==null&&M!==b);A===null?$=C:A.next=P,Xt(C,c.memoizedState)||(sn=!0),c.memoizedState=C,c.baseState=$,c.baseQueue=A,m.lastRenderedState=C}return[c.memoizedState,m.dispatch]}function Ns(s){var c=Xr(),m=c.queue;if(m===null)throw Error(r(311));m.lastRenderedReducer=s;var C=m.dispatch,b=m.pending,$=c.memoizedState;if(b!==null){m.pending=null;var P=b=b.next;do $=s($,P.action),P=P.next;while(P!==b);Xt($,c.memoizedState)||(sn=!0),c.memoizedState=$,c.baseQueue===null&&(c.baseState=$),m.lastRenderedState=$}return[$,C]}function Wm(s,c,m){var C=c._getVersion;C=C(c._source);var b=c._workInProgressVersionPrimary;if(b!==null?s=b===C:(s=s.mutableReadLanes,(s=(ks&s)===s)&&(c._workInProgressVersionPrimary=C,mi.push(c))),s)return m(c._source);throw mi.push(c),Error(r(350))}function Vm(s,c,m,C){var b=bt;if(b===null)throw Error(r(349));var $=c._getVersion,P=$(c._source),A=Ps.current,M=A.useState(function(){return Wm(b,c,m)}),q=M[1],de=M[0];M=lt;var Ie=s.memoizedState,oe=Ie.refs,ye=oe.getSnapshot,be=Ie.source;Ie=Ie.subscribe;var we=et;return s.memoizedState={refs:oe,source:c,subscribe:C},A.useEffect(function(){oe.getSnapshot=m,oe.setSnapshot=q;var z=$(c._source);if(!Xt(P,z)){z=m(c._source),Xt(de,z)||(q(z),z=yr(we),b.mutableReadLanes|=z&b.pendingLanes),z=b.mutableReadLanes,b.entangledLanes|=z;for(var B=b.entanglements,W=z;0<W;){var ee=31-ar(W),te=1<<ee;B[ee]|=z,W&=~te}}},[m,c,C]),A.useEffect(function(){return C(c._source,function(){var z=oe.getSnapshot,B=oe.setSnapshot;try{B(z(c._source));var W=yr(we);b.mutableReadLanes|=W&b.pendingLanes}catch(ee){B(function(){throw ee})}})},[c,C]),Xt(ye,m)&&Xt(be,c)&&Xt(Ie,C)||(s={pending:null,dispatch:null,lastRenderedReducer:Rn,lastRenderedState:de},s.dispatch=q=Hc.bind(null,et,s),M.queue=s,M.baseQueue=null,de=Wm(b,c,m),M.memoizedState=M.baseState=de),de}function zm(s,c,m){var C=Xr();return Vm(C,s,c,m)}function Os(s){var c=jr();return typeof s=="function"&&(s=s()),c.memoizedState=c.baseState=s,s=c.queue={pending:null,dispatch:null,lastRenderedReducer:Rn,lastRenderedState:s},s=s.dispatch=Hc.bind(null,et,s),[c.memoizedState,s]}function Cu(s,c,m,C){return s={tag:s,create:c,destroy:m,deps:C,next:null},c=et.updateQueue,c===null?(c={lastEffect:null},et.updateQueue=c,c.lastEffect=s.next=s):(m=c.lastEffect,m===null?c.lastEffect=s.next=s:(C=m.next,m.next=s,s.next=C,c.lastEffect=s)),s}function Gm(s){var c=jr();return s={current:s},c.memoizedState=s}function wu(){return Xr().memoizedState}function Vc(s,c,m,C){var b=jr();et.flags|=s,b.memoizedState=Cu(1|c,m,void 0,C===void 0?null:C)}function zc(s,c,m,C){var b=Xr();C=C===void 0?null:C;var $=void 0;if(gt!==null){var P=gt.memoizedState;if($=P.destroy,C!==null&&Uc(C,P.deps)){Cu(c,m,$,C);return}}et.flags|=s,b.memoizedState=Cu(1|c,m,$,C)}function Hm(s,c){return Vc(516,4,s,c)}function Su(s,c){return zc(516,4,s,c)}function jm(s,c){return zc(4,2,s,c)}function Xm(s,c){if(typeof c=="function")return s=s(),c(s),function(){c(null)};if(c!=null)return s=s(),c.current=s,function(){c.current=null}}function qm(s,c,m){return m=m!=null?m.concat([s]):null,zc(4,2,Xm.bind(null,c,s),m)}function Gc(){}function Km(s,c){var m=Xr();c=c===void 0?null:c;var C=m.memoizedState;return C!==null&&c!==null&&Uc(c,C[1])?C[0]:(m.memoizedState=[s,c],s)}function Ym(s,c){var m=Xr();c=c===void 0?null:c;var C=m.memoizedState;return C!==null&&c!==null&&Uc(c,C[1])?C[0]:(s=s(),m.memoizedState=[s,c],s)}function x2(s,c){var m=di();Gr(98>m?98:m,function(){s(!0)}),Gr(97<m?97:m,function(){var C=Kt.transition;Kt.transition=1;try{s(!1),c()}finally{Kt.transition=C}})}function Hc(s,c,m){var C=Bt(),b=yr(s),$={lane:b,action:m,eagerReducer:null,eagerState:null,next:null},P=c.pending;if(P===null?$.next=$:($.next=P.next,P.next=$),c.pending=$,P=s.alternate,s===et||P!==null&&P===et)Ts=vu=!0;else{if(s.lanes===0&&(P===null||P.lanes===0)&&(P=c.lastRenderedReducer,P!==null))try{var A=c.lastRenderedState,M=P(A,m);if($.eagerReducer=P,$.eagerState=M,Xt(M,A))return}catch{}finally{}xr(s,b,C)}}var bu={readContext:qt,useCallback:Tt,useContext:Tt,useEffect:Tt,useImperativeHandle:Tt,useLayoutEffect:Tt,useMemo:Tt,useReducer:Tt,useRef:Tt,useState:Tt,useDebugValue:Tt,useDeferredValue:Tt,useTransition:Tt,useMutableSource:Tt,useOpaqueIdentifier:Tt,unstable_isNewReconciler:!1},v2={readContext:qt,useCallback:function(s,c){return jr().memoizedState=[s,c===void 0?null:c],s},useContext:qt,useEffect:Hm,useImperativeHandle:function(s,c,m){return m=m!=null?m.concat([s]):null,Vc(4,2,Xm.bind(null,c,s),m)},useLayoutEffect:function(s,c){return Vc(4,2,s,c)},useMemo:function(s,c){var m=jr();return c=c===void 0?null:c,s=s(),m.memoizedState=[s,c],s},useReducer:function(s,c,m){var C=jr();return c=m!==void 0?m(c):c,C.memoizedState=C.baseState=c,s=C.queue={pending:null,dispatch:null,lastRenderedReducer:s,lastRenderedState:c},s=s.dispatch=Hc.bind(null,et,s),[C.memoizedState,s]},useRef:Gm,useState:Os,useDebugValue:Gc,useDeferredValue:function(s){var c=Os(s),m=c[0],C=c[1];return Hm(function(){var b=Kt.transition;Kt.transition=1;try{C(s)}finally{Kt.transition=b}},[s]),m},useTransition:function(){var s=Os(!1),c=s[0];return s=x2.bind(null,s[1]),Gm(s),[s,c]},useMutableSource:function(s,c,m){var C=jr();return C.memoizedState={refs:{getSnapshot:c,setSnapshot:null},source:s,subscribe:m},Vm(C,s,c,m)},useOpaqueIdentifier:function(){if($n){var s=!1,c=f2(function(){throw s||(s=!0,m("r:"+(bc++).toString(36))),Error(r(355))}),m=Os(c)[1];return(et.mode&2)===0&&(et.flags|=516,Cu(5,function(){m("r:"+(bc++).toString(36))},void 0,null)),c}return c="r:"+(bc++).toString(36),Os(c),c},unstable_isNewReconciler:!1},C2={readContext:qt,useCallback:Km,useContext:qt,useEffect:Su,useImperativeHandle:qm,useLayoutEffect:jm,useMemo:Ym,useReducer:As,useRef:wu,useState:function(){return As(Rn)},useDebugValue:Gc,useDeferredValue:function(s){var c=As(Rn),m=c[0],C=c[1];return Su(function(){var b=Kt.transition;Kt.transition=1;try{C(s)}finally{Kt.transition=b}},[s]),m},useTransition:function(){var s=As(Rn)[0];return[wu().current,s]},useMutableSource:zm,useOpaqueIdentifier:function(){return As(Rn)[0]},unstable_isNewReconciler:!1},w2={readContext:qt,useCallback:Km,useContext:qt,useEffect:Su,useImperativeHandle:qm,useLayoutEffect:jm,useMemo:Ym,useReducer:Ns,useRef:wu,useState:function(){return Ns(Rn)},useDebugValue:Gc,useDeferredValue:function(s){var c=Ns(Rn),m=c[0],C=c[1];return Su(function(){var b=Kt.transition;Kt.transition=1;try{C(s)}finally{Kt.transition=b}},[s]),m},useTransition:function(){var s=Ns(Rn)[0];return[wu().current,s]},useMutableSource:zm,useOpaqueIdentifier:function(){return Ns(Rn)[0]},unstable_isNewReconciler:!1},S2=R.ReactCurrentOwner,sn=!1;function At(s,c,m,C){c.child=s===null?Fm(c,null,m,C):gu(c,s.child,m,C)}function Qm(s,c,m,C,b){m=m.render;var $=c.ref;return pi(c,b),C=Wc(s,c,m,C,$,b),s!==null&&!sn?(c.updateQueue=s.updateQueue,c.flags&=-517,s.lanes&=~b,Un(s,c,b)):(c.flags|=1,At(s,c,C,b),c.child)}function Zm(s,c,m,C,b,$){if(s===null){var P=m.type;return typeof P=="function"&&!hd(P)&&P.defaultProps===void 0&&m.compare===null&&m.defaultProps===void 0?(c.tag=15,c.type=P,Jm(s,c,P,C,b,$)):(s=Nu(m.type,null,C,c,c.mode,$),s.ref=c.ref,s.return=c,c.child=s)}return P=s.child,(b&$)===0&&(b=P.memoizedProps,m=m.compare,m=m!==null?m:xs,m(b,C)&&s.ref===c.ref)?Un(s,c,$):(c.flags|=1,s=wr(P,C),s.ref=c.ref,s.return=c,c.child=s)}function Jm(s,c,m,C,b,$){if(s!==null&&xs(s.memoizedProps,C)&&s.ref===c.ref)if(sn=!1,($&b)!==0)(s.flags&16384)!==0&&(sn=!0);else return c.lanes=s.lanes,Un(s,c,$);return Xc(s,c,m,C,$)}function jc(s,c,m){var C=c.pendingProps,b=C.children,$=s!==null?s.memoizedState:null;if(C.mode==="hidden"||C.mode==="unstable-defer-without-hiding")if((c.mode&4)===0)c.memoizedState={baseLanes:0},Au(c,m);else if((m&1073741824)!==0)c.memoizedState={baseLanes:0},Au(c,$!==null?$.baseLanes:m);else return s=$!==null?$.baseLanes|m:m,c.lanes=c.childLanes=1073741824,c.memoizedState={baseLanes:s},Au(c,s),null;else $!==null?(C=$.baseLanes|m,c.memoizedState=null):C=m,Au(c,C);return At(s,c,b,m),c.child}function eg(s,c){var m=c.ref;(s===null&&m!==null||s!==null&&s.ref!==m)&&(c.flags|=128)}function Xc(s,c,m,C,b){var $=kt(m)?Vr:ht.current;return $=ci(c,$),pi(c,b),m=Wc(s,c,m,C,$,b),s!==null&&!sn?(c.updateQueue=s.updateQueue,c.flags&=-517,s.lanes&=~b,Un(s,c,b)):(c.flags|=1,At(s,c,m,b),c.child)}function tg(s,c,m,C,b){if(kt(m)){var $=!0;su(c)}else $=!1;if(pi(c,b),c.stateNode===null)s!==null&&(s.alternate=null,c.alternate=null,c.flags|=2),Nm(c,m,C),Oc(c,m,C,b),C=!0;else if(s===null){var P=c.stateNode,A=c.memoizedProps;P.props=A;var M=P.context,q=m.contextType;typeof q=="object"&&q!==null?q=qt(q):(q=kt(m)?Vr:ht.current,q=ci(c,q));var de=m.getDerivedStateFromProps,Ie=typeof de=="function"||typeof P.getSnapshotBeforeUpdate=="function";Ie||typeof P.UNSAFE_componentWillReceiveProps!="function"&&typeof P.componentWillReceiveProps!="function"||(A!==C||M!==q)&&Om(c,P,C,q),fr=!1;var oe=c.memoizedState;P.state=oe,Is(c,C,P,b),M=c.memoizedState,A!==C||oe!==M||Pt.current||fr?(typeof de=="function"&&(fu(c,m,de,C),M=c.memoizedState),(A=fr||Am(c,m,A,C,oe,M,q))?(Ie||typeof P.UNSAFE_componentWillMount!="function"&&typeof P.componentWillMount!="function"||(typeof P.componentWillMount=="function"&&P.componentWillMount(),typeof P.UNSAFE_componentWillMount=="function"&&P.UNSAFE_componentWillMount()),typeof P.componentDidMount=="function"&&(c.flags|=4)):(typeof P.componentDidMount=="function"&&(c.flags|=4),c.memoizedProps=C,c.memoizedState=M),P.props=C,P.state=M,P.context=q,C=A):(typeof P.componentDidMount=="function"&&(c.flags|=4),C=!1)}else{P=c.stateNode,_m(s,c),A=c.memoizedProps,q=c.type===c.elementType?A:on(c.type,A),P.props=q,Ie=c.pendingProps,oe=P.context,M=m.contextType,typeof M=="object"&&M!==null?M=qt(M):(M=kt(m)?Vr:ht.current,M=ci(c,M));var ye=m.getDerivedStateFromProps;(de=typeof ye=="function"||typeof P.getSnapshotBeforeUpdate=="function")||typeof P.UNSAFE_componentWillReceiveProps!="function"&&typeof P.componentWillReceiveProps!="function"||(A!==Ie||oe!==M)&&Om(c,P,C,M),fr=!1,oe=c.memoizedState,P.state=oe,Is(c,C,P,b);var be=c.memoizedState;A!==Ie||oe!==be||Pt.current||fr?(typeof ye=="function"&&(fu(c,m,ye,C),be=c.memoizedState),(q=fr||Am(c,m,q,C,oe,be,M))?(de||typeof P.UNSAFE_componentWillUpdate!="function"&&typeof P.componentWillUpdate!="function"||(typeof P.componentWillUpdate=="function"&&P.componentWillUpdate(C,be,M),typeof P.UNSAFE_componentWillUpdate=="function"&&P.UNSAFE_componentWillUpdate(C,be,M)),typeof P.componentDidUpdate=="function"&&(c.flags|=4),typeof P.getSnapshotBeforeUpdate=="function"&&(c.flags|=256)):(typeof P.componentDidUpdate!="function"||A===s.memoizedProps&&oe===s.memoizedState||(c.flags|=4),typeof P.getSnapshotBeforeUpdate!="function"||A===s.memoizedProps&&oe===s.memoizedState||(c.flags|=256),c.memoizedProps=C,c.memoizedState=be),P.props=C,P.state=be,P.context=M,C=q):(typeof P.componentDidUpdate!="function"||A===s.memoizedProps&&oe===s.memoizedState||(c.flags|=4),typeof P.getSnapshotBeforeUpdate!="function"||A===s.memoizedProps&&oe===s.memoizedState||(c.flags|=256),C=!1)}return qc(s,c,m,C,$,b)}function qc(s,c,m,C,b,$){eg(s,c);var P=(c.flags&64)!==0;if(!C&&!P)return b&&xm(c,m,!1),Un(s,c,$);C=c.stateNode,S2.current=c;var A=P&&typeof m.getDerivedStateFromError!="function"?null:C.render();return c.flags|=1,s!==null&&P?(c.child=gu(c,s.child,null,$),c.child=gu(c,null,A,$)):At(s,c,A,$),c.memoizedState=C.state,b&&xm(c,m,!0),c.child}function ng(s){var c=s.stateNode;c.pendingContext?gm(s,c.pendingContext,c.pendingContext!==c.context):c.context&&gm(s,c.context,!1),Dc(s,c.containerInfo)}var Iu={dehydrated:null,retryLane:0};function rg(s,c,m){var C=c.pendingProps,b=Qe.current,$=!1,P;return(P=(c.flags&64)!==0)||(P=s!==null&&s.memoizedState===null?!1:(b&2)!==0),P?($=!0,c.flags&=-65):s!==null&&s.memoizedState===null||C.fallback===void 0||C.unstable_avoidThisFallback===!0||(b|=1),Ye(Qe,b&1),s===null?(C.fallback!==void 0&&Lc(c),s=C.children,b=C.fallback,$?(s=og(c,s,b,m),c.child.memoizedState={baseLanes:m},c.memoizedState=Iu,s):typeof C.unstable_expectedLoadTime=="number"?(s=og(c,s,b,m),c.child.memoizedState={baseLanes:m},c.memoizedState=Iu,c.lanes=33554432,s):(m=md({mode:"visible",children:s},c.mode,m,null),m.return=c,c.child=m)):s.memoizedState!==null?$?(C=sg(s,c,C.children,C.fallback,m),$=c.child,b=s.child.memoizedState,$.memoizedState=b===null?{baseLanes:m}:{baseLanes:b.baseLanes|m},$.childLanes=s.childLanes&~m,c.memoizedState=Iu,C):(m=ig(s,c,C.children,m),c.memoizedState=null,m):$?(C=sg(s,c,C.children,C.fallback,m),$=c.child,b=s.child.memoizedState,$.memoizedState=b===null?{baseLanes:m}:{baseLanes:b.baseLanes|m},$.childLanes=s.childLanes&~m,c.memoizedState=Iu,C):(m=ig(s,c,C.children,m),c.memoizedState=null,m)}function og(s,c,m,C){var b=s.mode,$=s.child;return c={mode:"hidden",children:c},(b&2)===0&&$!==null?($.childLanes=0,$.pendingProps=c):$=md(c,b,0,null),m=wi(m,b,C,null),$.return=s,m.return=s,$.sibling=m,s.child=$,m}function ig(s,c,m,C){var b=s.child;return s=b.sibling,m=wr(b,{mode:"visible",children:m}),(c.mode&2)===0&&(m.lanes=C),m.return=c,m.sibling=null,s!==null&&(s.nextEffect=null,s.flags=8,c.firstEffect=c.lastEffect=s),c.child=m}function sg(s,c,m,C,b){var $=c.mode,P=s.child;s=P.sibling;var A={mode:"hidden",children:m};return($&2)===0&&c.child!==P?(m=c.child,m.childLanes=0,m.pendingProps=A,P=m.lastEffect,P!==null?(c.firstEffect=m.firstEffect,c.lastEffect=P,P.nextEffect=null):c.firstEffect=c.lastEffect=null):m=wr(P,A),s!==null?C=wr(s,C):(C=wi(C,$,b,null),C.flags|=2),C.return=c,m.return=c,m.sibling=C,c.child=m,C}function ag(s,c){s.lanes|=c;var m=s.alternate;m!==null&&(m.lanes|=c),Em(s.return,c)}function Kc(s,c,m,C,b,$){var P=s.memoizedState;P===null?s.memoizedState={isBackwards:c,rendering:null,renderingStartTime:0,last:C,tail:m,tailMode:b,lastEffect:$}:(P.isBackwards=c,P.rendering=null,P.renderingStartTime=0,P.last=C,P.tail=m,P.tailMode=b,P.lastEffect=$)}function ug(s,c,m){var C=c.pendingProps,b=C.revealOrder,$=C.tail;if(At(s,c,C.children,m),C=Qe.current,(C&2)!==0)C=C&1|2,c.flags|=64;else{if(s!==null&&(s.flags&64)!==0)e:for(s=c.child;s!==null;){if(s.tag===13)s.memoizedState!==null&&ag(s,m);else if(s.tag===19)ag(s,m);else if(s.child!==null){s.child.return=s,s=s.child;continue}if(s===c)break e;for(;s.sibling===null;){if(s.return===null||s.return===c)break e;s=s.return}s.sibling.return=s.return,s=s.sibling}C&=1}if(Ye(Qe,C),(c.mode&2)===0)c.memoizedState=null;else switch(b){case"forwards":for(m=c.child,b=null;m!==null;)s=m.alternate,s!==null&&yu(s)===null&&(b=m),m=m.sibling;m=b,m===null?(b=c.child,c.child=null):(b=m.sibling,m.sibling=null),Kc(c,!1,b,m,$,c.lastEffect);break;case"backwards":for(m=null,b=c.child,c.child=null;b!==null;){if(s=b.alternate,s!==null&&yu(s)===null){c.child=b;break}s=b.sibling,b.sibling=m,m=b,b=s}Kc(c,!0,m,null,$,c.lastEffect);break;case"together":Kc(c,!1,null,null,void 0,c.lastEffect);break;default:c.memoizedState=null}return c.child}function Un(s,c,m){if(s!==null&&(c.dependencies=s.dependencies),Fs|=c.lanes,(m&c.childLanes)!==0){if(s!==null&&c.child!==s.child)throw Error(r(153));if(c.child!==null){for(s=c.child,m=wr(s,s.pendingProps),c.child=m,m.return=c;s.sibling!==null;)s=s.sibling,m=m.sibling=wr(s,s.pendingProps),m.return=c;m.sibling=null}return c.child}return null}var lg,Yc,cg,dg;lg=function(s,c){for(var m=c.child;m!==null;){if(m.tag===5||m.tag===6)s.appendChild(m.stateNode);else if(m.tag!==4&&m.child!==null){m.child.return=m,m=m.child;continue}if(m===c)break;for(;m.sibling===null;){if(m.return===null||m.return===c)return;m=m.return}m.sibling.return=m.return,m=m.sibling}},Yc=function(){},cg=function(s,c,m,C){var b=s.memoizedProps;if(b!==C){s=c.stateNode,Hr(In.current);var $=null;switch(m){case"input":b=Ol(s,b),C=Ol(s,C),$=[];break;case"option":b=Ll(s,b),C=Ll(s,C),$=[];break;case"select":b=e({},b,{value:void 0}),C=e({},C,{value:void 0}),$=[];break;case"textarea":b=Ml(s,b),C=Ml(s,C),$=[];break;default:typeof b.onClick!="function"&&typeof C.onClick=="function"&&(s.onclick=tu)}Wl(m,C);var P;m=null;for(q in b)if(!C.hasOwnProperty(q)&&b.hasOwnProperty(q)&&b[q]!=null)if(q==="style"){var A=b[q];for(P in A)A.hasOwnProperty(P)&&(m||(m={}),m[P]="")}else q!=="dangerouslySetInnerHTML"&&q!=="children"&&q!=="suppressContentEditableWarning"&&q!=="suppressHydrationWarning"&&q!=="autoFocus"&&(i.hasOwnProperty(q)?$||($=[]):($=$||[]).push(q,null));for(q in C){var M=C[q];if(A=b?.[q],C.hasOwnProperty(q)&&M!==A&&(M!=null||A!=null))if(q==="style")if(A){for(P in A)!A.hasOwnProperty(P)||M&&M.hasOwnProperty(P)||(m||(m={}),m[P]="");for(P in M)M.hasOwnProperty(P)&&A[P]!==M[P]&&(m||(m={}),m[P]=M[P])}else m||($||($=[]),$.push(q,m)),m=M;else q==="dangerouslySetInnerHTML"?(M=M?M.__html:void 0,A=A?A.__html:void 0,M!=null&&A!==M&&($=$||[]).push(q,M)):q==="children"?typeof M!="string"&&typeof M!="number"||($=$||[]).push(q,""+M):q!=="suppressContentEditableWarning"&&q!=="suppressHydrationWarning"&&(i.hasOwnProperty(q)?(M!=null&&q==="onScroll"&&ze("scroll",s),$||A===M||($=[])):typeof M=="object"&&M!==null&&M.$$typeof===ne?M.toString():($=$||[]).push(q,M))}m&&($=$||[]).push("style",m);var q=$;(c.updateQueue=q)&&(c.flags|=4)}},dg=function(s,c,m,C){m!==C&&(c.flags|=4)};function Ds(s,c){if(!$n)switch(s.tailMode){case"hidden":c=s.tail;for(var m=null;c!==null;)c.alternate!==null&&(m=c),c=c.sibling;m===null?s.tail=null:m.sibling=null;break;case"collapsed":m=s.tail;for(var C=null;m!==null;)m.alternate!==null&&(C=m),m=m.sibling;C===null?c||s.tail===null?s.tail=null:s.tail.sibling=null:C.sibling=null}}function b2(s,c,m){var C=c.pendingProps;switch(c.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return kt(c.type)&&iu(),null;case 3:return hi(),Ge(Pt),Ge(ht),Bc(),C=c.stateNode,C.pendingContext&&(C.context=C.pendingContext,C.pendingContext=null),(s===null||s.child===null)&&(xu(c)?c.flags|=4:C.hydrate||(c.flags|=256)),Yc(c),null;case 5:Fc(c);var b=Hr(_s.current);if(m=c.type,s!==null&&c.stateNode!=null)cg(s,c,m,C,b),s.ref!==c.ref&&(c.flags|=128);else{if(!C){if(c.stateNode===null)throw Error(r(166));return null}if(s=Hr(In.current),xu(c)){C=c.stateNode,m=c.type;var $=c.memoizedProps;switch(C[lr]=c,C[ru]=$,m){case"dialog":ze("cancel",C),ze("close",C);break;case"iframe":case"object":case"embed":ze("load",C);break;case"video":case"audio":for(s=0;s<Cs.length;s++)ze(Cs[s],C);break;case"source":ze("error",C);break;case"img":case"image":case"link":ze("error",C),ze("load",C);break;case"details":ze("toggle",C);break;case"input":nh(C,$),ze("invalid",C);break;case"select":C._wrapperState={wasMultiple:!!$.multiple},ze("invalid",C);break;case"textarea":ih(C,$),ze("invalid",C)}Wl(m,$),s=null;for(var P in $)$.hasOwnProperty(P)&&(b=$[P],P==="children"?typeof b=="string"?C.textContent!==b&&(s=["children",b]):typeof b=="number"&&C.textContent!==""+b&&(s=["children",""+b]):i.hasOwnProperty(P)&&b!=null&&P==="onScroll"&&ze("scroll",C));switch(m){case"input":Ma(C),oh(C,$,!0);break;case"textarea":Ma(C),ah(C);break;case"select":case"option":break;default:typeof $.onClick=="function"&&(C.onclick=tu)}C=s,c.updateQueue=C,C!==null&&(c.flags|=4)}else{switch(P=b.nodeType===9?b:b.ownerDocument,s===Bl.html&&(s=uh(m)),s===Bl.html?m==="script"?(s=P.createElement("div"),s.innerHTML="<script><\/script>",s=s.removeChild(s.firstChild)):typeof C.is=="string"?s=P.createElement(m,{is:C.is}):(s=P.createElement(m),m==="select"&&(P=s,C.multiple?P.multiple=!0:C.size&&(P.size=C.size))):s=P.createElementNS(s,m),s[lr]=c,s[ru]=C,lg(s,c,!1,!1),c.stateNode=s,P=Vl(m,C),m){case"dialog":ze("cancel",s),ze("close",s),b=C;break;case"iframe":case"object":case"embed":ze("load",s),b=C;break;case"video":case"audio":for(b=0;b<Cs.length;b++)ze(Cs[b],s);b=C;break;case"source":ze("error",s),b=C;break;case"img":case"image":case"link":ze("error",s),ze("load",s),b=C;break;case"details":ze("toggle",s),b=C;break;case"input":nh(s,C),b=Ol(s,C),ze("invalid",s);break;case"option":b=Ll(s,C);break;case"select":s._wrapperState={wasMultiple:!!C.multiple},b=e({},C,{value:void 0}),ze("invalid",s);break;case"textarea":ih(s,C),b=Ml(s,C),ze("invalid",s);break;default:b=C}Wl(m,b);var A=b;for($ in A)if(A.hasOwnProperty($)){var M=A[$];$==="style"?dh(s,M):$==="dangerouslySetInnerHTML"?(M=M?M.__html:void 0,M!=null&&lh(s,M)):$==="children"?typeof M=="string"?(m!=="textarea"||M!=="")&&ns(s,M):typeof M=="number"&&ns(s,""+M):$!=="suppressContentEditableWarning"&&$!=="suppressHydrationWarning"&&$!=="autoFocus"&&(i.hasOwnProperty($)?M!=null&&$==="onScroll"&&ze("scroll",s):M!=null&&E(s,$,M,P))}switch(m){case"input":Ma(s),oh(s,C,!1);break;case"textarea":Ma(s),ah(s);break;case"option":C.value!=null&&s.setAttribute("value",""+rr(C.value));break;case"select":s.multiple=!!C.multiple,$=C.value,$!=null?Yo(s,!!C.multiple,$,!1):C.defaultValue!=null&&Yo(s,!!C.multiple,C.defaultValue,!0);break;default:typeof b.onClick=="function"&&(s.onclick=tu)}dm(m,C)&&(c.flags|=4)}c.ref!==null&&(c.flags|=128)}return null;case 6:if(s&&c.stateNode!=null)dg(s,c,s.memoizedProps,C);else{if(typeof C!="string"&&c.stateNode===null)throw Error(r(166));m=Hr(_s.current),Hr(In.current),xu(c)?(C=c.stateNode,m=c.memoizedProps,C[lr]=c,C.nodeValue!==m&&(c.flags|=4)):(C=(m.nodeType===9?m:m.ownerDocument).createTextNode(C),C[lr]=c,c.stateNode=C)}return null;case 13:return Ge(Qe),C=c.memoizedState,(c.flags&64)!==0?(c.lanes=m,c):(C=C!==null,m=!1,s===null?c.memoizedProps.fallback!==void 0&&xu(c):m=s.memoizedState!==null,C&&!m&&(c.mode&2)!==0&&(s===null&&c.memoizedProps.unstable_avoidThisFallback!==!0||(Qe.current&1)!==0?ct===0&&(ct=3):((ct===0||ct===3)&&(ct=4),bt===null||(Fs&134217727)===0&&(yi&134217727)===0||vi(bt,yt))),(C||m)&&(c.flags|=4),null);case 4:return hi(),Yc(c),s===null&&sm(c.stateNode.containerInfo),null;case 10:return Ac(c),null;case 17:return kt(c.type)&&iu(),null;case 19:if(Ge(Qe),C=c.memoizedState,C===null)return null;if($=(c.flags&64)!==0,P=C.rendering,P===null)if($)Ds(C,!1);else{if(ct!==0||s!==null&&(s.flags&64)!==0)for(s=c.child;s!==null;){if(P=yu(s),P!==null){for(c.flags|=64,Ds(C,!1),$=P.updateQueue,$!==null&&(c.updateQueue=$,c.flags|=4),C.lastEffect===null&&(c.firstEffect=null),c.lastEffect=C.lastEffect,C=m,m=c.child;m!==null;)$=m,s=C,$.flags&=2,$.nextEffect=null,$.firstEffect=null,$.lastEffect=null,P=$.alternate,P===null?($.childLanes=0,$.lanes=s,$.child=null,$.memoizedProps=null,$.memoizedState=null,$.updateQueue=null,$.dependencies=null,$.stateNode=null):($.childLanes=P.childLanes,$.lanes=P.lanes,$.child=P.child,$.memoizedProps=P.memoizedProps,$.memoizedState=P.memoizedState,$.updateQueue=P.updateQueue,$.type=P.type,s=P.dependencies,$.dependencies=s===null?null:{lanes:s.lanes,firstContext:s.firstContext}),m=m.sibling;return Ye(Qe,Qe.current&1|2),c.child}s=s.sibling}C.tail!==null&&mt()>ad&&(c.flags|=64,$=!0,Ds(C,!1),c.lanes=33554432)}else{if(!$)if(s=yu(P),s!==null){if(c.flags|=64,$=!0,m=s.updateQueue,m!==null&&(c.updateQueue=m,c.flags|=4),Ds(C,!0),C.tail===null&&C.tailMode==="hidden"&&!P.alternate&&!$n)return c=c.lastEffect=C.lastEffect,c!==null&&(c.nextEffect=null),null}else 2*mt()-C.renderingStartTime>ad&&m!==1073741824&&(c.flags|=64,$=!0,Ds(C,!1),c.lanes=33554432);C.isBackwards?(P.sibling=c.child,c.child=P):(m=C.last,m!==null?m.sibling=P:c.child=P,C.last=P)}return C.tail!==null?(m=C.tail,C.rendering=m,C.tail=m.sibling,C.lastEffect=c.lastEffect,C.renderingStartTime=mt(),m.sibling=null,c=Qe.current,Ye(Qe,$?c&1|2:c&1),m):null;case 23:case 24:return pd(),s!==null&&s.memoizedState!==null!=(c.memoizedState!==null)&&C.mode!=="unstable-defer-without-hiding"&&(c.flags|=4),null}throw Error(r(156,c.tag))}function I2(s){switch(s.tag){case 1:kt(s.type)&&iu();var c=s.flags;return c&4096?(s.flags=c&-4097|64,s):null;case 3:if(hi(),Ge(Pt),Ge(ht),Bc(),c=s.flags,(c&64)!==0)throw Error(r(285));return s.flags=c&-4097|64,s;case 5:return Fc(s),null;case 13:return Ge(Qe),c=s.flags,c&4096?(s.flags=c&-4097|64,s):null;case 19:return Ge(Qe),null;case 4:return hi(),null;case 10:return Ac(s),null;case 23:case 24:return pd(),null;default:return null}}function Qc(s,c){try{var m="",C=c;do m+=rb(C),C=C.return;while(C);var b=m}catch($){b=`
Error generating stack: `+$.message+`
`+$.stack}return{value:s,source:c,stack:b}}function Zc(s,c){try{console.error(c.value)}catch(m){setTimeout(function(){throw m})}}var $2=typeof WeakMap=="function"?WeakMap:Map;function fg(s,c,m){m=pr(-1,m),m.tag=3,m.payload={element:null};var C=c.value;return m.callback=function(){Eu||(Eu=!0,ud=C),Zc(s,c)},m}function pg(s,c,m){m=pr(-1,m),m.tag=3;var C=s.type.getDerivedStateFromError;if(typeof C=="function"){var b=c.value;m.payload=function(){return Zc(s,c),C(b)}}var $=s.stateNode;return $!==null&&typeof $.componentDidCatch=="function"&&(m.callback=function(){typeof C!="function"&&(En===null?En=new Set([this]):En.add(this),Zc(s,c));var P=c.stack;this.componentDidCatch(c.value,{componentStack:P!==null?P:""})}),m}var R2=typeof WeakSet=="function"?WeakSet:Set;function hg(s){var c=s.ref;if(c!==null)if(typeof c=="function")try{c(null)}catch(m){Cr(s,m)}else c.current=null}function E2(s,c){switch(c.tag){case 0:case 11:case 15:case 22:return;case 1:if(c.flags&256&&s!==null){var m=s.memoizedProps,C=s.memoizedState;s=c.stateNode,c=s.getSnapshotBeforeUpdate(c.elementType===c.type?m:on(c.type,m),C),s.__reactInternalSnapshotBeforeUpdate=c}return;case 3:c.flags&256&&Sc(c.stateNode.containerInfo);return;case 5:case 6:case 4:case 17:return}throw Error(r(163))}function _2(s,c,m){switch(m.tag){case 0:case 11:case 15:case 22:if(c=m.updateQueue,c=c!==null?c.lastEffect:null,c!==null){s=c=c.next;do{if((s.tag&3)===3){var C=s.create;s.destroy=C()}s=s.next}while(s!==c)}if(c=m.updateQueue,c=c!==null?c.lastEffect:null,c!==null){s=c=c.next;do{var b=s;C=b.next,b=b.tag,(b&4)!==0&&(b&1)!==0&&(Pg(m,s),F2(m,s)),s=C}while(s!==c)}return;case 1:s=m.stateNode,m.flags&4&&(c===null?s.componentDidMount():(C=m.elementType===m.type?c.memoizedProps:on(m.type,c.memoizedProps),s.componentDidUpdate(C,c.memoizedState,s.__reactInternalSnapshotBeforeUpdate))),c=m.updateQueue,c!==null&&km(m,c,s);return;case 3:if(c=m.updateQueue,c!==null){if(s=null,m.child!==null)switch(m.child.tag){case 5:s=m.child.stateNode;break;case 1:s=m.child.stateNode}km(m,c,s)}return;case 5:s=m.stateNode,c===null&&m.flags&4&&dm(m.type,m.memoizedProps)&&s.focus();return;case 6:return;case 4:return;case 12:return;case 13:m.memoizedState===null&&(m=m.alternate,m!==null&&(m=m.memoizedState,m!==null&&(m=m.dehydrated,m!==null&&Eh(m))));return;case 19:case 17:case 20:case 21:case 23:case 24:return}throw Error(r(163))}function mg(s,c){for(var m=s;;){if(m.tag===5){var C=m.stateNode;if(c)C=C.style,typeof C.setProperty=="function"?C.setProperty("display","none","important"):C.display="none";else{C=m.stateNode;var b=m.memoizedProps.style;b=b!=null&&b.hasOwnProperty("display")?b.display:null,C.style.display=ch("display",b)}}else if(m.tag===6)m.stateNode.nodeValue=c?"":m.memoizedProps;else if((m.tag!==23&&m.tag!==24||m.memoizedState===null||m===s)&&m.child!==null){m.child.return=m,m=m.child;continue}if(m===s)break;for(;m.sibling===null;){if(m.return===null||m.return===s)return;m=m.return}m.sibling.return=m.return,m=m.sibling}}function gg(s,c){if(zr&&typeof zr.onCommitFiberUnmount=="function")try{zr.onCommitFiberUnmount($c,c)}catch{}switch(c.tag){case 0:case 11:case 14:case 15:case 22:if(s=c.updateQueue,s!==null&&(s=s.lastEffect,s!==null)){var m=s=s.next;do{var C=m,b=C.destroy;if(C=C.tag,b!==void 0)if((C&4)!==0)Pg(c,m);else{C=c;try{b()}catch($){Cr(C,$)}}m=m.next}while(m!==s)}break;case 1:if(hg(c),s=c.stateNode,typeof s.componentWillUnmount=="function")try{s.props=c.memoizedProps,s.state=c.memoizedState,s.componentWillUnmount()}catch($){Cr(c,$)}break;case 5:hg(c);break;case 4:Cg(s,c)}}function yg(s){s.alternate=null,s.child=null,s.dependencies=null,s.firstEffect=null,s.lastEffect=null,s.memoizedProps=null,s.memoizedState=null,s.pendingProps=null,s.return=null,s.updateQueue=null}function xg(s){return s.tag===5||s.tag===3||s.tag===4}function vg(s){e:{for(var c=s.return;c!==null;){if(xg(c))break e;c=c.return}throw Error(r(160))}var m=c;switch(c=m.stateNode,m.tag){case 5:var C=!1;break;case 3:c=c.containerInfo,C=!0;break;case 4:c=c.containerInfo,C=!0;break;default:throw Error(r(161))}m.flags&16&&(ns(c,""),m.flags&=-17);e:t:for(m=s;;){for(;m.sibling===null;){if(m.return===null||xg(m.return)){m=null;break e}m=m.return}for(m.sibling.return=m.return,m=m.sibling;m.tag!==5&&m.tag!==6&&m.tag!==18;){if(m.flags&2||m.child===null||m.tag===4)continue t;m.child.return=m,m=m.child}if(!(m.flags&2)){m=m.stateNode;break e}}C?Jc(s,m,c):ed(s,m,c)}function Jc(s,c,m){var C=s.tag,b=C===5||C===6;if(b)s=b?s.stateNode:s.stateNode.instance,c?m.nodeType===8?m.parentNode.insertBefore(s,c):m.insertBefore(s,c):(m.nodeType===8?(c=m.parentNode,c.insertBefore(s,m)):(c=m,c.appendChild(s)),m=m._reactRootContainer,m!=null||c.onclick!==null||(c.onclick=tu));else if(C!==4&&(s=s.child,s!==null))for(Jc(s,c,m),s=s.sibling;s!==null;)Jc(s,c,m),s=s.sibling}function ed(s,c,m){var C=s.tag,b=C===5||C===6;if(b)s=b?s.stateNode:s.stateNode.instance,c?m.insertBefore(s,c):m.appendChild(s);else if(C!==4&&(s=s.child,s!==null))for(ed(s,c,m),s=s.sibling;s!==null;)ed(s,c,m),s=s.sibling}function Cg(s,c){for(var m=c,C=!1,b,$;;){if(!C){C=m.return;e:for(;;){if(C===null)throw Error(r(160));switch(b=C.stateNode,C.tag){case 5:$=!1;break e;case 3:b=b.containerInfo,$=!0;break e;case 4:b=b.containerInfo,$=!0;break e}C=C.return}C=!0}if(m.tag===5||m.tag===6){e:for(var P=s,A=m,M=A;;)if(gg(P,M),M.child!==null&&M.tag!==4)M.child.return=M,M=M.child;else{if(M===A)break e;for(;M.sibling===null;){if(M.return===null||M.return===A)break e;M=M.return}M.sibling.return=M.return,M=M.sibling}$?(P=b,A=m.stateNode,P.nodeType===8?P.parentNode.removeChild(A):P.removeChild(A)):b.removeChild(m.stateNode)}else if(m.tag===4){if(m.child!==null){b=m.stateNode.containerInfo,$=!0,m.child.return=m,m=m.child;continue}}else if(gg(s,m),m.child!==null){m.child.return=m,m=m.child;continue}if(m===c)break;for(;m.sibling===null;){if(m.return===null||m.return===c)return;m=m.return,m.tag===4&&(C=!1)}m.sibling.return=m.return,m=m.sibling}}function td(s,c){switch(c.tag){case 0:case 11:case 14:case 15:case 22:var m=c.updateQueue;if(m=m!==null?m.lastEffect:null,m!==null){var C=m=m.next;do(C.tag&3)===3&&(s=C.destroy,C.destroy=void 0,s!==void 0&&s()),C=C.next;while(C!==m)}return;case 1:return;case 5:if(m=c.stateNode,m!=null){C=c.memoizedProps;var b=s!==null?s.memoizedProps:C;s=c.type;var $=c.updateQueue;if(c.updateQueue=null,$!==null){for(m[ru]=C,s==="input"&&C.type==="radio"&&C.name!=null&&rh(m,C),Vl(s,b),c=Vl(s,C),b=0;b<$.length;b+=2){var P=$[b],A=$[b+1];P==="style"?dh(m,A):P==="dangerouslySetInnerHTML"?lh(m,A):P==="children"?ns(m,A):E(m,P,A,c)}switch(s){case"input":Dl(m,C);break;case"textarea":sh(m,C);break;case"select":s=m._wrapperState.wasMultiple,m._wrapperState.wasMultiple=!!C.multiple,$=C.value,$!=null?Yo(m,!!C.multiple,$,!1):s!==!!C.multiple&&(C.defaultValue!=null?Yo(m,!!C.multiple,C.defaultValue,!0):Yo(m,!!C.multiple,C.multiple?[]:"",!1))}}}return;case 6:if(c.stateNode===null)throw Error(r(162));c.stateNode.nodeValue=c.memoizedProps;return;case 3:m=c.stateNode,m.hydrate&&(m.hydrate=!1,Eh(m.containerInfo));return;case 12:return;case 13:c.memoizedState!==null&&(sd=mt(),mg(c.child,!0)),wg(c);return;case 19:wg(c);return;case 17:return;case 23:case 24:mg(c,c.memoizedState!==null);return}throw Error(r(163))}function wg(s){var c=s.updateQueue;if(c!==null){s.updateQueue=null;var m=s.stateNode;m===null&&(m=s.stateNode=new R2),c.forEach(function(C){var b=B2.bind(null,s,C);m.has(C)||(m.add(C),C.then(b,b))})}}function P2(s,c){return s!==null&&(s=s.memoizedState,s===null||s.dehydrated!==null)?(c=c.memoizedState,c!==null&&c.dehydrated===null):!1}var k2=Math.ceil,$u=R.ReactCurrentDispatcher,nd=R.ReactCurrentOwner,Se=0,bt=null,rt=null,yt=0,qr=0,rd=cr(0),ct=0,Ru=null,gi=0,Fs=0,yi=0,od=0,id=null,sd=0,ad=1/0;function xi(){ad=mt()+500}var fe=null,Eu=!1,ud=null,En=null,gr=!1,Ls=null,Ms=90,ld=[],cd=[],Wn=null,Bs=0,dd=null,_u=-1,Vn=0,Pu=0,Us=null,ku=!1;function Bt(){return(Se&48)!==0?mt():_u!==-1?_u:_u=mt()}function yr(s){if(s=s.mode,(s&2)===0)return 1;if((s&4)===0)return di()===99?1:2;if(Vn===0&&(Vn=gi),y2.transition!==0){Pu!==0&&(Pu=id!==null?id.pendingLanes:0),s=Vn;var c=4186112&~Pu;return c&=-c,c===0&&(s=4186112&~s,c=s&-s,c===0&&(c=8192)),c}return s=di(),(Se&4)!==0&&s===98?s=ja(12,Vn):(s=vb(s),s=ja(s,Vn)),s}function xr(s,c,m){if(50<Bs)throw Bs=0,dd=null,Error(r(185));if(s=Tu(s,c),s===null)return null;Xa(s,c,m),s===bt&&(yi|=c,ct===4&&vi(s,yt));var C=di();c===1?(Se&8)!==0&&(Se&48)===0?fd(s):(Yt(s,m),Se===0&&(xi(),bn())):((Se&4)===0||C!==98&&C!==99||(Wn===null?Wn=new Set([s]):Wn.add(s)),Yt(s,m)),id=s}function Tu(s,c){s.lanes|=c;var m=s.alternate;for(m!==null&&(m.lanes|=c),m=s,s=s.return;s!==null;)s.childLanes|=c,m=s.alternate,m!==null&&(m.childLanes|=c),m=s,s=s.return;return m.tag===3?m.stateNode:null}function Yt(s,c){for(var m=s.callbackNode,C=s.suspendedLanes,b=s.pingedLanes,$=s.expirationTimes,P=s.pendingLanes;0<P;){var A=31-ar(P),M=1<<A,q=$[A];if(q===-1){if((M&C)===0||(M&b)!==0){q=c,ei(M);var de=Ve;$[A]=10<=de?q+250:6<=de?q+5e3:-1}}else q<=c&&(s.expiredLanes|=M);P&=~M}if(C=fs(s,s===bt?yt:0),c=Ve,C===0)m!==null&&(m!==Pc&&Ec(m),s.callbackNode=null,s.callbackPriority=0);else{if(m!==null){if(s.callbackPriority===c)return;m!==Pc&&Ec(m)}c===15?(m=fd.bind(null,s),Mn===null?(Mn=[m],uu=Rc(au,Rm)):Mn.push(m),m=Pc):c===14?m=bs(99,fd.bind(null,s)):(m=Cb(c),m=bs(m,Sg.bind(null,s))),s.callbackPriority=c,s.callbackNode=m}}function Sg(s){if(_u=-1,Pu=Vn=0,(Se&48)!==0)throw Error(r(327));var c=s.callbackNode;if(vr()&&s.callbackNode!==c)return null;var m=fs(s,s===bt?yt:0);if(m===0)return null;var C=m,b=Se;Se|=16;var $=Rg();(bt!==s||yt!==C)&&(xi(),Ci(s,C));do try{N2();break}catch(A){$g(s,A)}while(!0);if(Tc(),$u.current=$,Se=b,rt!==null?C=0:(bt=null,yt=0,C=ct),(gi&yi)!==0)Ci(s,0);else if(C!==0){if(C===2&&(Se|=64,s.hydrate&&(s.hydrate=!1,Sc(s.containerInfo)),m=Oh(s),m!==0&&(C=Ws(s,m))),C===1)throw c=Ru,Ci(s,0),vi(s,m),Yt(s,mt()),c;switch(s.finishedWork=s.current.alternate,s.finishedLanes=m,C){case 0:case 1:throw Error(r(345));case 2:Kr(s);break;case 3:if(vi(s,m),(m&62914560)===m&&(C=sd+500-mt(),10<C)){if(fs(s,0)!==0)break;if(b=s.suspendedLanes,(b&m)!==m){Bt(),s.pingedLanes|=s.suspendedLanes&b;break}s.timeoutHandle=fm(Kr.bind(null,s),C);break}Kr(s);break;case 4:if(vi(s,m),(m&4186112)===m)break;for(C=s.eventTimes,b=-1;0<m;){var P=31-ar(m);$=1<<P,P=C[P],P>b&&(b=P),m&=~$}if(m=b,m=mt()-m,m=(120>m?120:480>m?480:1080>m?1080:1920>m?1920:3e3>m?3e3:4320>m?4320:1960*k2(m/1960))-m,10<m){s.timeoutHandle=fm(Kr.bind(null,s),m);break}Kr(s);break;case 5:Kr(s);break;default:throw Error(r(329))}}return Yt(s,mt()),s.callbackNode===c?Sg.bind(null,s):null}function vi(s,c){for(c&=~od,c&=~yi,s.suspendedLanes|=c,s.pingedLanes&=~c,s=s.expirationTimes;0<c;){var m=31-ar(c),C=1<<m;s[m]=-1,c&=~C}}function fd(s){if((Se&48)!==0)throw Error(r(327));if(vr(),s===bt&&(s.expiredLanes&yt)!==0){var c=yt,m=Ws(s,c);(gi&yi)!==0&&(c=fs(s,c),m=Ws(s,c))}else c=fs(s,0),m=Ws(s,c);if(s.tag!==0&&m===2&&(Se|=64,s.hydrate&&(s.hydrate=!1,Sc(s.containerInfo)),c=Oh(s),c!==0&&(m=Ws(s,c))),m===1)throw m=Ru,Ci(s,0),vi(s,c),Yt(s,mt()),m;return s.finishedWork=s.current.alternate,s.finishedLanes=c,Kr(s),Yt(s,mt()),null}function T2(){if(Wn!==null){var s=Wn;Wn=null,s.forEach(function(c){c.expiredLanes|=24&c.pendingLanes,Yt(c,mt())})}bn()}function bg(s,c){var m=Se;Se|=1;try{return s(c)}finally{Se=m,Se===0&&(xi(),bn())}}function Ig(s,c){var m=Se;Se&=-2,Se|=8;try{return s(c)}finally{Se=m,Se===0&&(xi(),bn())}}function Au(s,c){Ye(rd,qr),qr|=c,gi|=c}function pd(){qr=rd.current,Ge(rd)}function Ci(s,c){s.finishedWork=null,s.finishedLanes=0;var m=s.timeoutHandle;if(m!==-1&&(s.timeoutHandle=-1,d2(m)),rt!==null)for(m=rt.return;m!==null;){var C=m;switch(C.tag){case 1:C=C.type.childContextTypes,C!=null&&iu();break;case 3:hi(),Ge(Pt),Ge(ht),Bc();break;case 5:Fc(C);break;case 4:hi();break;case 13:Ge(Qe);break;case 19:Ge(Qe);break;case 10:Ac(C);break;case 23:case 24:pd()}m=m.return}bt=s,rt=wr(s.current,null),yt=qr=gi=c,ct=0,Ru=null,od=yi=Fs=0}function $g(s,c){do{var m=rt;try{if(Tc(),Ps.current=bu,vu){for(var C=et.memoizedState;C!==null;){var b=C.queue;b!==null&&(b.pending=null),C=C.next}vu=!1}if(ks=0,lt=gt=et=null,Ts=!1,nd.current=null,m===null||m.return===null){ct=1,Ru=c,rt=null;break}e:{var $=s,P=m.return,A=m,M=c;if(c=yt,A.flags|=2048,A.firstEffect=A.lastEffect=null,M!==null&&typeof M=="object"&&typeof M.then=="function"){var q=M;if((A.mode&2)===0){var de=A.alternate;de?(A.updateQueue=de.updateQueue,A.memoizedState=de.memoizedState,A.lanes=de.lanes):(A.updateQueue=null,A.memoizedState=null)}var Ie=(Qe.current&1)!==0,oe=P;do{var ye;if(ye=oe.tag===13){var be=oe.memoizedState;if(be!==null)ye=be.dehydrated!==null;else{var we=oe.memoizedProps;ye=we.fallback===void 0?!1:we.unstable_avoidThisFallback!==!0?!0:!Ie}}if(ye){var z=oe.updateQueue;if(z===null){var B=new Set;B.add(q),oe.updateQueue=B}else z.add(q);if((oe.mode&2)===0){if(oe.flags|=64,A.flags|=16384,A.flags&=-2981,A.tag===1)if(A.alternate===null)A.tag=17;else{var W=pr(-1,1);W.tag=2,hr(A,W)}A.lanes|=1;break e}M=void 0,A=c;var ee=$.pingCache;if(ee===null?(ee=$.pingCache=new $2,M=new Set,ee.set(q,M)):(M=ee.get(q),M===void 0&&(M=new Set,ee.set(q,M))),!M.has(A)){M.add(A);var te=M2.bind(null,$,q,A);q.then(te,te)}oe.flags|=4096,oe.lanes=c;break e}oe=oe.return}while(oe!==null);M=Error((Ko(A.type)||"A React component")+` suspended while rendering, but no fallback UI was specified.

Add a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display.`)}ct!==5&&(ct=2),M=Qc(M,A),oe=P;do{switch(oe.tag){case 3:$=M,oe.flags|=4096,c&=-c,oe.lanes|=c;var $e=fg(oe,$,c);Pm(oe,$e);break e;case 1:$=M;var me=oe.type,Re=oe.stateNode;if((oe.flags&64)===0&&(typeof me.getDerivedStateFromError=="function"||Re!==null&&typeof Re.componentDidCatch=="function"&&(En===null||!En.has(Re)))){oe.flags|=4096,c&=-c,oe.lanes|=c;var Pe=pg(oe,$,c);Pm(oe,Pe);break e}}oe=oe.return}while(oe!==null)}_g(m)}catch(Ee){c=Ee,rt===m&&m!==null&&(rt=m=m.return);continue}break}while(!0)}function Rg(){var s=$u.current;return $u.current=bu,s===null?bu:s}function Ws(s,c){var m=Se;Se|=16;var C=Rg();bt===s&&yt===c||Ci(s,c);do try{A2();break}catch(b){$g(s,b)}while(!0);if(Tc(),Se=m,$u.current=C,rt!==null)throw Error(r(261));return bt=null,yt=0,ct}function A2(){for(;rt!==null;)Eg(rt)}function N2(){for(;rt!==null&&!h2();)Eg(rt)}function Eg(s){var c=Tg(s.alternate,s,qr);s.memoizedProps=s.pendingProps,c===null?_g(s):rt=c,nd.current=null}function _g(s){var c=s;do{var m=c.alternate;if(s=c.return,(c.flags&2048)===0){if(m=b2(m,c,qr),m!==null){rt=m;return}if(m=c,m.tag!==24&&m.tag!==23||m.memoizedState===null||(qr&1073741824)!==0||(m.mode&4)===0){for(var C=0,b=m.child;b!==null;)C|=b.lanes|b.childLanes,b=b.sibling;m.childLanes=C}s!==null&&(s.flags&2048)===0&&(s.firstEffect===null&&(s.firstEffect=c.firstEffect),c.lastEffect!==null&&(s.lastEffect!==null&&(s.lastEffect.nextEffect=c.firstEffect),s.lastEffect=c.lastEffect),1<c.flags&&(s.lastEffect!==null?s.lastEffect.nextEffect=c:s.firstEffect=c,s.lastEffect=c))}else{if(m=I2(c),m!==null){m.flags&=2047,rt=m;return}s!==null&&(s.firstEffect=s.lastEffect=null,s.flags|=2048)}if(c=c.sibling,c!==null){rt=c;return}rt=c=s}while(c!==null);ct===0&&(ct=5)}function Kr(s){var c=di();return Gr(99,O2.bind(null,s,c)),null}function O2(s,c){do vr();while(Ls!==null);if((Se&48)!==0)throw Error(r(327));var m=s.finishedWork;if(m===null)return null;if(s.finishedWork=null,s.finishedLanes=0,m===s.current)throw Error(r(177));s.callbackNode=null;var C=m.lanes|m.childLanes,b=C,$=s.pendingLanes&~b;s.pendingLanes=b,s.suspendedLanes=0,s.pingedLanes=0,s.expiredLanes&=b,s.mutableReadLanes&=b,s.entangledLanes&=b,b=s.entanglements;for(var P=s.eventTimes,A=s.expirationTimes;0<$;){var M=31-ar($),q=1<<M;b[M]=0,P[M]=-1,A[M]=-1,$&=~q}if(Wn!==null&&(C&24)===0&&Wn.has(s)&&Wn.delete(s),s===bt&&(rt=bt=null,yt=0),1<m.flags?m.lastEffect!==null?(m.lastEffect.nextEffect=m,C=m.firstEffect):C=m:C=m.firstEffect,C!==null){if(b=Se,Se|=32,nd.current=null,vc=qa,P=em(),mc(P)){if("selectionStart"in P)A={start:P.selectionStart,end:P.selectionEnd};else e:if(A=(A=P.ownerDocument)&&A.defaultView||window,(q=A.getSelection&&A.getSelection())&&q.rangeCount!==0){A=q.anchorNode,$=q.anchorOffset,M=q.focusNode,q=q.focusOffset;try{A.nodeType,M.nodeType}catch{A=null;break e}var de=0,Ie=-1,oe=-1,ye=0,be=0,we=P,z=null;t:for(;;){for(var B;we!==A||$!==0&&we.nodeType!==3||(Ie=de+$),we!==M||q!==0&&we.nodeType!==3||(oe=de+q),we.nodeType===3&&(de+=we.nodeValue.length),(B=we.firstChild)!==null;)z=we,we=B;for(;;){if(we===P)break t;if(z===A&&++ye===$&&(Ie=de),z===M&&++be===q&&(oe=de),(B=we.nextSibling)!==null)break;we=z,z=we.parentNode}we=B}A=Ie===-1||oe===-1?null:{start:Ie,end:oe}}else A=null;A=A||{start:0,end:0}}else A=null;Cc={focusedElem:P,selectionRange:A},qa=!1,Us=null,ku=!1,fe=C;do try{D2()}catch(Ee){if(fe===null)throw Error(r(330));Cr(fe,Ee),fe=fe.nextEffect}while(fe!==null);Us=null,fe=C;do try{for(P=s;fe!==null;){var W=fe.flags;if(W&16&&ns(fe.stateNode,""),W&128){var ee=fe.alternate;if(ee!==null){var te=ee.ref;te!==null&&(typeof te=="function"?te(null):te.current=null)}}switch(W&1038){case 2:vg(fe),fe.flags&=-3;break;case 6:vg(fe),fe.flags&=-3,td(fe.alternate,fe);break;case 1024:fe.flags&=-1025;break;case 1028:fe.flags&=-1025,td(fe.alternate,fe);break;case 4:td(fe.alternate,fe);break;case 8:A=fe,Cg(P,A);var $e=A.alternate;yg(A),$e!==null&&yg($e)}fe=fe.nextEffect}}catch(Ee){if(fe===null)throw Error(r(330));Cr(fe,Ee),fe=fe.nextEffect}while(fe!==null);if(te=Cc,ee=em(),W=te.focusedElem,P=te.selectionRange,ee!==W&&W&&W.ownerDocument&&Jh(W.ownerDocument.documentElement,W)){for(P!==null&&mc(W)&&(ee=P.start,te=P.end,te===void 0&&(te=ee),"selectionStart"in W?(W.selectionStart=ee,W.selectionEnd=Math.min(te,W.value.length)):(te=(ee=W.ownerDocument||document)&&ee.defaultView||window,te.getSelection&&(te=te.getSelection(),A=W.textContent.length,$e=Math.min(P.start,A),P=P.end===void 0?$e:Math.min(P.end,A),!te.extend&&$e>P&&(A=P,P=$e,$e=A),A=Zh(W,$e),$=Zh(W,P),A&&$&&(te.rangeCount!==1||te.anchorNode!==A.node||te.anchorOffset!==A.offset||te.focusNode!==$.node||te.focusOffset!==$.offset)&&(ee=ee.createRange(),ee.setStart(A.node,A.offset),te.removeAllRanges(),$e>P?(te.addRange(ee),te.extend($.node,$.offset)):(ee.setEnd($.node,$.offset),te.addRange(ee)))))),ee=[],te=W;te=te.parentNode;)te.nodeType===1&&ee.push({element:te,left:te.scrollLeft,top:te.scrollTop});for(typeof W.focus=="function"&&W.focus(),W=0;W<ee.length;W++)te=ee[W],te.element.scrollLeft=te.left,te.element.scrollTop=te.top}qa=!!vc,Cc=vc=null,s.current=m,fe=C;do try{for(W=s;fe!==null;){var me=fe.flags;if(me&36&&_2(W,fe.alternate,fe),me&128){ee=void 0;var Re=fe.ref;if(Re!==null){var Pe=fe.stateNode;switch(fe.tag){case 5:ee=Pe;break;default:ee=Pe}typeof Re=="function"?Re(ee):Re.current=ee}}fe=fe.nextEffect}}catch(Ee){if(fe===null)throw Error(r(330));Cr(fe,Ee),fe=fe.nextEffect}while(fe!==null);fe=null,g2(),Se=b}else s.current=m;if(gr)gr=!1,Ls=s,Ms=c;else for(fe=C;fe!==null;)c=fe.nextEffect,fe.nextEffect=null,fe.flags&8&&(me=fe,me.sibling=null,me.stateNode=null),fe=c;if(C=s.pendingLanes,C===0&&(En=null),C===1?s===dd?Bs++:(Bs=0,dd=s):Bs=0,m=m.stateNode,zr&&typeof zr.onCommitFiberRoot=="function")try{zr.onCommitFiberRoot($c,m,void 0,(m.current.flags&64)===64)}catch{}if(Yt(s,mt()),Eu)throw Eu=!1,s=ud,ud=null,s;return(Se&8)!==0||bn(),null}function D2(){for(;fe!==null;){var s=fe.alternate;ku||Us===null||((fe.flags&8)!==0?Ch(fe,Us)&&(ku=!0):fe.tag===13&&P2(s,fe)&&Ch(fe,Us)&&(ku=!0));var c=fe.flags;(c&256)!==0&&E2(s,fe),(c&512)===0||gr||(gr=!0,bs(97,function(){return vr(),null})),fe=fe.nextEffect}}function vr(){if(Ms!==90){var s=97<Ms?97:Ms;return Ms=90,Gr(s,L2)}return!1}function F2(s,c){ld.push(c,s),gr||(gr=!0,bs(97,function(){return vr(),null}))}function Pg(s,c){cd.push(c,s),gr||(gr=!0,bs(97,function(){return vr(),null}))}function L2(){if(Ls===null)return!1;var s=Ls;if(Ls=null,(Se&48)!==0)throw Error(r(331));var c=Se;Se|=32;var m=cd;cd=[];for(var C=0;C<m.length;C+=2){var b=m[C],$=m[C+1],P=b.destroy;if(b.destroy=void 0,typeof P=="function")try{P()}catch(M){if($===null)throw Error(r(330));Cr($,M)}}for(m=ld,ld=[],C=0;C<m.length;C+=2){b=m[C],$=m[C+1];try{var A=b.create;b.destroy=A()}catch(M){if($===null)throw Error(r(330));Cr($,M)}}for(A=s.current.firstEffect;A!==null;)s=A.nextEffect,A.nextEffect=null,A.flags&8&&(A.sibling=null,A.stateNode=null),A=s;return Se=c,bn(),!0}function kg(s,c,m){c=Qc(m,c),c=fg(s,c,1),hr(s,c),c=Bt(),s=Tu(s,1),s!==null&&(Xa(s,1,c),Yt(s,c))}function Cr(s,c){if(s.tag===3)kg(s,s,c);else for(var m=s.return;m!==null;){if(m.tag===3){kg(m,s,c);break}else if(m.tag===1){var C=m.stateNode;if(typeof m.type.getDerivedStateFromError=="function"||typeof C.componentDidCatch=="function"&&(En===null||!En.has(C))){s=Qc(c,s);var b=pg(m,s,1);if(hr(m,b),b=Bt(),m=Tu(m,1),m!==null)Xa(m,1,b),Yt(m,b);else if(typeof C.componentDidCatch=="function"&&(En===null||!En.has(C)))try{C.componentDidCatch(c,s)}catch{}break}}m=m.return}}function M2(s,c,m){var C=s.pingCache;C!==null&&C.delete(c),c=Bt(),s.pingedLanes|=s.suspendedLanes&m,bt===s&&(yt&m)===m&&(ct===4||ct===3&&(yt&62914560)===yt&&500>mt()-sd?Ci(s,0):od|=m),Yt(s,c)}function B2(s,c){var m=s.stateNode;m!==null&&m.delete(c),c=0,c===0&&(c=s.mode,(c&2)===0?c=1:(c&4)===0?c=di()===99?1:2:(Vn===0&&(Vn=gi),c=ti(62914560&~Vn),c===0&&(c=4194304))),m=Bt(),s=Tu(s,c),s!==null&&(Xa(s,c,m),Yt(s,m))}var Tg;Tg=function(s,c,m){var C=c.lanes;if(s!==null)if(s.memoizedProps!==c.pendingProps||Pt.current)sn=!0;else if((m&C)!==0)sn=(s.flags&16384)!==0;else{switch(sn=!1,c.tag){case 3:ng(c),Mc();break;case 5:Lm(c);break;case 1:kt(c.type)&&su(c);break;case 4:Dc(c,c.stateNode.containerInfo);break;case 10:C=c.memoizedProps.value;var b=c.type._context;Ye(lu,b._currentValue),b._currentValue=C;break;case 13:if(c.memoizedState!==null)return(m&c.child.childLanes)!==0?rg(s,c,m):(Ye(Qe,Qe.current&1),c=Un(s,c,m),c!==null?c.sibling:null);Ye(Qe,Qe.current&1);break;case 19:if(C=(m&c.childLanes)!==0,(s.flags&64)!==0){if(C)return ug(s,c,m);c.flags|=64}if(b=c.memoizedState,b!==null&&(b.rendering=null,b.tail=null,b.lastEffect=null),Ye(Qe,Qe.current),C)break;return null;case 23:case 24:return c.lanes=0,jc(s,c,m)}return Un(s,c,m)}else sn=!1;switch(c.lanes=0,c.tag){case 2:if(C=c.type,s!==null&&(s.alternate=null,c.alternate=null,c.flags|=2),s=c.pendingProps,b=ci(c,ht.current),pi(c,m),b=Wc(null,c,C,s,b,m),c.flags|=1,typeof b=="object"&&b!==null&&typeof b.render=="function"&&b.$$typeof===void 0){if(c.tag=1,c.memoizedState=null,c.updateQueue=null,kt(C)){var $=!0;su(c)}else $=!1;c.memoizedState=b.state!==null&&b.state!==void 0?b.state:null,Nc(c);var P=C.getDerivedStateFromProps;typeof P=="function"&&fu(c,C,P,s),b.updater=pu,c.stateNode=b,b._reactInternals=c,Oc(c,C,s,m),c=qc(null,c,C,!0,$,m)}else c.tag=0,At(null,c,b,m),c=c.child;return c;case 16:b=c.elementType;e:{switch(s!==null&&(s.alternate=null,c.alternate=null,c.flags|=2),s=c.pendingProps,$=b._init,b=$(b._payload),c.type=b,$=c.tag=W2(b),s=on(b,s),$){case 0:c=Xc(null,c,b,s,m);break e;case 1:c=tg(null,c,b,s,m);break e;case 11:c=Qm(null,c,b,s,m);break e;case 14:c=Zm(null,c,b,on(b.type,s),C,m);break e}throw Error(r(306,b,""))}return c;case 0:return C=c.type,b=c.pendingProps,b=c.elementType===C?b:on(C,b),Xc(s,c,C,b,m);case 1:return C=c.type,b=c.pendingProps,b=c.elementType===C?b:on(C,b),tg(s,c,C,b,m);case 3:if(ng(c),C=c.updateQueue,s===null||C===null)throw Error(r(282));if(C=c.pendingProps,b=c.memoizedState,b=b!==null?b.element:null,_m(s,c),Is(c,C,null,m),C=c.memoizedState.element,C===b)Mc(),c=Un(s,c,m);else{if(b=c.stateNode,($=b.hydrate)&&(mr=si(c.stateNode.containerInfo.firstChild),Bn=c,$=$n=!0),$){if(s=b.mutableSourceEagerHydrationData,s!=null)for(b=0;b<s.length;b+=2)$=s[b],$._workInProgressVersionPrimary=s[b+1],mi.push($);for(m=Fm(c,null,C,m),c.child=m;m;)m.flags=m.flags&-3|1024,m=m.sibling}else At(s,c,C,m),Mc();c=c.child}return c;case 5:return Lm(c),s===null&&Lc(c),C=c.type,b=c.pendingProps,$=s!==null?s.memoizedProps:null,P=b.children,wc(C,b)?P=null:$!==null&&wc(C,$)&&(c.flags|=16),eg(s,c),At(s,c,P,m),c.child;case 6:return s===null&&Lc(c),null;case 13:return rg(s,c,m);case 4:return Dc(c,c.stateNode.containerInfo),C=c.pendingProps,s===null?c.child=gu(c,null,C,m):At(s,c,C,m),c.child;case 11:return C=c.type,b=c.pendingProps,b=c.elementType===C?b:on(C,b),Qm(s,c,C,b,m);case 7:return At(s,c,c.pendingProps,m),c.child;case 8:return At(s,c,c.pendingProps.children,m),c.child;case 12:return At(s,c,c.pendingProps.children,m),c.child;case 10:e:{C=c.type._context,b=c.pendingProps,P=c.memoizedProps,$=b.value;var A=c.type._context;if(Ye(lu,A._currentValue),A._currentValue=$,P!==null)if(A=P.value,$=Xt(A,$)?0:(typeof C._calculateChangedBits=="function"?C._calculateChangedBits(A,$):1073741823)|0,$===0){if(P.children===b.children&&!Pt.current){c=Un(s,c,m);break e}}else for(A=c.child,A!==null&&(A.return=c);A!==null;){var M=A.dependencies;if(M!==null){P=A.child;for(var q=M.firstContext;q!==null;){if(q.context===C&&(q.observedBits&$)!==0){A.tag===1&&(q=pr(-1,m&-m),q.tag=2,hr(A,q)),A.lanes|=m,q=A.alternate,q!==null&&(q.lanes|=m),Em(A.return,m),M.lanes|=m;break}q=q.next}}else P=A.tag===10&&A.type===c.type?null:A.child;if(P!==null)P.return=A;else for(P=A;P!==null;){if(P===c){P=null;break}if(A=P.sibling,A!==null){A.return=P.return,P=A;break}P=P.return}A=P}At(s,c,b.children,m),c=c.child}return c;case 9:return b=c.type,$=c.pendingProps,C=$.children,pi(c,m),b=qt(b,$.unstable_observedBits),C=C(b),c.flags|=1,At(s,c,C,m),c.child;case 14:return b=c.type,$=on(b,c.pendingProps),$=on(b.type,$),Zm(s,c,b,$,C,m);case 15:return Jm(s,c,c.type,c.pendingProps,C,m);case 17:return C=c.type,b=c.pendingProps,b=c.elementType===C?b:on(C,b),s!==null&&(s.alternate=null,c.alternate=null,c.flags|=2),c.tag=1,kt(C)?(s=!0,su(c)):s=!1,pi(c,m),Nm(c,C,b),Oc(c,C,b,m),qc(null,c,C,!0,s,m);case 19:return ug(s,c,m);case 23:return jc(s,c,m);case 24:return jc(s,c,m)}throw Error(r(156,c.tag))};function U2(s,c,m,C){this.tag=s,this.key=m,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=c,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=C,this.flags=0,this.lastEffect=this.firstEffect=this.nextEffect=null,this.childLanes=this.lanes=0,this.alternate=null}function Qt(s,c,m,C){return new U2(s,c,m,C)}function hd(s){return s=s.prototype,!(!s||!s.isReactComponent)}function W2(s){if(typeof s=="function")return hd(s)?1:0;if(s!=null){if(s=s.$$typeof,s===U)return 11;if(s===Z)return 14}return 2}function wr(s,c){var m=s.alternate;return m===null?(m=Qt(s.tag,c,s.key,s.mode),m.elementType=s.elementType,m.type=s.type,m.stateNode=s.stateNode,m.alternate=s,s.alternate=m):(m.pendingProps=c,m.type=s.type,m.flags=0,m.nextEffect=null,m.firstEffect=null,m.lastEffect=null),m.childLanes=s.childLanes,m.lanes=s.lanes,m.child=s.child,m.memoizedProps=s.memoizedProps,m.memoizedState=s.memoizedState,m.updateQueue=s.updateQueue,c=s.dependencies,m.dependencies=c===null?null:{lanes:c.lanes,firstContext:c.firstContext},m.sibling=s.sibling,m.index=s.index,m.ref=s.ref,m}function Nu(s,c,m,C,b,$){var P=2;if(C=s,typeof s=="function")hd(s)&&(P=1);else if(typeof s=="string")P=5;else e:switch(s){case D:return wi(m.children,b,$,c);case Q:P=8,b|=16;break;case N:P=8,b|=1;break;case O:return s=Qt(12,m,c,b|8),s.elementType=O,s.type=O,s.lanes=$,s;case G:return s=Qt(13,m,c,b),s.type=G,s.elementType=G,s.lanes=$,s;case j:return s=Qt(19,m,c,b),s.elementType=j,s.lanes=$,s;case H:return md(m,b,$,c);case K:return s=Qt(24,m,c,b),s.elementType=K,s.lanes=$,s;default:if(typeof s=="object"&&s!==null)switch(s.$$typeof){case _:P=10;break e;case F:P=9;break e;case U:P=11;break e;case Z:P=14;break e;case L:P=16,C=null;break e;case X:P=22;break e}throw Error(r(130,s==null?s:typeof s,""))}return c=Qt(P,m,c,b),c.elementType=s,c.type=C,c.lanes=$,c}function wi(s,c,m,C){return s=Qt(7,s,C,c),s.lanes=m,s}function md(s,c,m,C){return s=Qt(23,s,C,c),s.elementType=H,s.lanes=m,s}function gd(s,c,m){return s=Qt(6,s,null,c),s.lanes=m,s}function yd(s,c,m){return c=Qt(4,s.children!==null?s.children:[],s.key,c),c.lanes=m,c.stateNode={containerInfo:s.containerInfo,pendingChildren:null,implementation:s.implementation},c}function V2(s,c,m){this.tag=c,this.containerInfo=s,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.pendingContext=this.context=null,this.hydrate=m,this.callbackNode=null,this.callbackPriority=0,this.eventTimes=rc(0),this.expirationTimes=rc(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=rc(0),this.mutableSourceEagerHydrationData=null}function z2(s,c,m){var C=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:k,key:C==null?null:""+C,children:s,containerInfo:c,implementation:m}}function Ou(s,c,m,C){var b=c.current,$=Bt(),P=yr(b);e:if(m){m=m._reactInternals;t:{if(Ur(m)!==m||m.tag!==1)throw Error(r(170));var A=m;do{switch(A.tag){case 3:A=A.stateNode.context;break t;case 1:if(kt(A.type)){A=A.stateNode.__reactInternalMemoizedMergedChildContext;break t}}A=A.return}while(A!==null);throw Error(r(171))}if(m.tag===1){var M=m.type;if(kt(M)){m=ym(m,M,A);break e}}m=A}else m=dr;return c.context===null?c.context=m:c.pendingContext=m,c=pr($,P),c.payload={element:s},C=C===void 0?null:C,C!==null&&(c.callback=C),hr(b,c),xr(b,P,$),P}function xd(s){if(s=s.current,!s.child)return null;switch(s.child.tag){case 5:return s.child.stateNode;default:return s.child.stateNode}}function Ag(s,c){if(s=s.memoizedState,s!==null&&s.dehydrated!==null){var m=s.retryLane;s.retryLane=m!==0&&m<c?m:c}}function vd(s,c){Ag(s,c),(s=s.alternate)&&Ag(s,c)}function G2(){return null}function Cd(s,c,m){var C=m!=null&&m.hydrationOptions!=null&&m.hydrationOptions.mutableSources||null;if(m=new V2(s,c,m!=null&&m.hydrate===!0),c=Qt(3,null,null,c===2?7:c===1?3:0),m.current=c,c.stateNode=m,Nc(c),s[ai]=m.current,sm(s.nodeType===8?s.parentNode:s),C)for(s=0;s<C.length;s++){c=C[s];var b=c._getVersion;b=b(c._source),m.mutableSourceEagerHydrationData==null?m.mutableSourceEagerHydrationData=[c,b]:m.mutableSourceEagerHydrationData.push(c,b)}this._internalRoot=m}Cd.prototype.render=function(s){Ou(s,this._internalRoot,null,null)},Cd.prototype.unmount=function(){var s=this._internalRoot,c=s.containerInfo;Ou(null,s,null,function(){c[ai]=null})};function Vs(s){return!(!s||s.nodeType!==1&&s.nodeType!==9&&s.nodeType!==11&&(s.nodeType!==8||s.nodeValue!==" react-mount-point-unstable "))}function H2(s,c){if(c||(c=s?s.nodeType===9?s.documentElement:s.firstChild:null,c=!(!c||c.nodeType!==1||!c.hasAttribute("data-reactroot"))),!c)for(var m;m=s.lastChild;)s.removeChild(m);return new Cd(s,0,c?{hydrate:!0}:void 0)}function Du(s,c,m,C,b){var $=m._reactRootContainer;if($){var P=$._internalRoot;if(typeof b=="function"){var A=b;b=function(){var q=xd(P);A.call(q)}}Ou(c,P,s,b)}else{if($=m._reactRootContainer=H2(m,C),P=$._internalRoot,typeof b=="function"){var M=b;b=function(){var q=xd(P);M.call(q)}}Ig(function(){Ou(c,P,s,b)})}return xd(P)}wh=function(s){if(s.tag===13){var c=Bt();xr(s,4,c),vd(s,4)}},Ql=function(s){if(s.tag===13){var c=Bt();xr(s,67108864,c),vd(s,67108864)}},Sh=function(s){if(s.tag===13){var c=Bt(),m=yr(s);xr(s,m,c),vd(s,m)}},bh=function(s,c){return c()},Gl=function(s,c,m){switch(c){case"input":if(Dl(s,m),c=m.name,m.type==="radio"&&c!=null){for(m=s;m.parentNode;)m=m.parentNode;for(m=m.querySelectorAll("input[name="+JSON.stringify(""+c)+'][type="radio"]'),c=0;c<m.length;c++){var C=m[c];if(C!==s&&C.form===s.form){var b=ou(C);if(!b)throw Error(r(90));th(C),Dl(C,b)}}}break;case"textarea":sh(s,m);break;case"select":c=m.value,c!=null&&Yo(s,!!m.multiple,c,!1)}},Hl=bg,mh=function(s,c,m,C,b){var $=Se;Se|=4;try{return Gr(98,s.bind(null,c,m,C,b))}finally{Se=$,Se===0&&(xi(),bn())}},jl=function(){(Se&49)===0&&(T2(),vr())},gh=function(s,c){var m=Se;Se|=2;try{return s(c)}finally{Se=m,Se===0&&(xi(),bn())}};function Ng(s,c){var m=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!Vs(c))throw Error(r(200));return z2(s,c,null,m)}var j2={Events:[Ss,ui,ou,ph,hh,vr,{current:!1}]},zs={findFiberByHostInstance:Wr,bundleType:0,version:"17.0.2",rendererPackageName:"react-dom"},X2={bundleType:zs.bundleType,version:zs.version,rendererPackageName:zs.rendererPackageName,rendererConfig:zs.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:R.ReactCurrentDispatcher,findHostInstanceByFiber:function(s){return s=vh(s),s===null?null:s.stateNode},findFiberByHostInstance:zs.findFiberByHostInstance||G2,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var Fu=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!Fu.isDisabled&&Fu.supportsFiber)try{$c=Fu.inject(X2),zr=Fu}catch{}}return Ut.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=j2,Ut.createPortal=Ng,Ut.findDOMNode=function(s){if(s==null)return null;if(s.nodeType===1)return s;var c=s._reactInternals;if(c===void 0)throw typeof s.render=="function"?Error(r(188)):Error(r(268,Object.keys(s)));return s=vh(c),s=s===null?null:s.stateNode,s},Ut.flushSync=function(s,c){var m=Se;if((m&48)!==0)return s(c);Se|=1;try{if(s)return Gr(99,s.bind(null,c))}finally{Se=m,bn()}},Ut.hydrate=function(s,c,m){if(!Vs(c))throw Error(r(200));return Du(null,s,c,!0,m)},Ut.render=function(s,c,m){if(!Vs(c))throw Error(r(200));return Du(null,s,c,!1,m)},Ut.unmountComponentAtNode=function(s){if(!Vs(s))throw Error(r(40));return s._reactRootContainer?(Ig(function(){Du(null,null,s,!1,function(){s._reactRootContainer=null,s[ai]=null})}),!0):!1},Ut.unstable_batchedUpdates=bg,Ut.unstable_createPortal=function(s,c){return Ng(s,c,2<arguments.length&&arguments[2]!==void 0?arguments[2]:null)},Ut.unstable_renderSubtreeIntoContainer=function(s,c,m,C){if(!Vs(m))throw Error(r(200));if(s==null||s._reactInternals===void 0)throw Error(r(38));return Du(s,c,m,!1,C)},Ut.version="17.0.2",Ut}var Vg;function rI(){if(Vg)return Id.exports;Vg=1;function t(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(t)}catch(e){console.error(e)}}return t(),Id.exports=nI(),Id.exports}var oI=rI();const iI=Ef(oI);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sI=1e-7,aI=1e-4;class Lv{constructor(e,n){this.backend=e,this.dataMover=n,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,n){this.dataIdsCount++,this.data.set(e,n)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class Pf{refCount(e){return Nt("refCount")}incRef(e){return Nt("incRef")}timerAvailable(){return!0}time(e){return Nt("time")}read(e){return Nt("read")}readSync(e){return Nt("readSync")}readToGPU(e,n){return Nt("readToGPU")}numDataIds(){return Nt("numDataIds")}disposeData(e,n){return Nt("disposeData")}write(e,n,r){return Nt("write")}move(e,n,r,o,i){return Nt("move")}createTensorFromGPUData(e,n,r){return Nt("createTensorFromGPUData")}memory(){return Nt("memory")}floatPrecision(){return Nt("floatPrecision")}epsilon(){return this.floatPrecision()===32?sI:aI}dispose(){return Nt("dispose")}}function Nt(t){throw new Error(`'${t}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function el(t,e,n){return Math.max(t,Math.min(e,n))}function kf(t){return t%2===0?t:t+1}function Gs(t,e,n){const r=t[e];t[e]=t[n],t[n]=r}function Mv(t){let e=0;for(let n=0;n<t.length;n++)e+=t[n];return e}function re(t,e){if(!t)throw new Error(typeof e=="string"?e:e())}function Tf(t,e,n=""){re(je(t,e),()=>n+` Shapes ${t} and ${e} must match`)}function Y(t){if(t.length===0)return 1;let e=t[0];for(let n=1;n<t.length;n++)e*=t[n];return e}function zg(t){return t.length===0}function je(t,e){if(t===e)return!0;if(t==null||e==null||t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}function tl(t){return t%1===0}function tf(t){const e=Math.ceil(Math.sqrt(t));return[e,Math.ceil(t/e)]}function Di(t,e){return e<=t.length?t:t+" ".repeat(e-t.length)}function Gg(t,e=o=>0,n,r){return new Promise((o,i)=>{let a=0;const u=()=>{if(t()){o();return}a++;const l=e(a);if(n!=null&&a>=n){i();return}r!=null?r(u,l):setTimeout(u,l)};u()})}function Bv(t,e){let n=1,r=-1;for(let i=0;i<t.length;++i)if(t[i]>=0)n*=t[i];else if(t[i]===-1){if(r!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${i}`);r=i}else if(t[i]<0)throw Error(`Shapes can not be < 0. Found ${t[i]} at dim ${i}`);if(r===-1){if(e>0&&e!==n)throw Error(`Size(${e}) must match the product of shape ${t}`);return t}if(n===0)throw Error(`Cannot infer the missing size in [${t}] when there are 0 elements`);if(e%n!==0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${n}`);const o=t.slice();return o[r]=e/n,o}function Je(t,e){const n=e.length;return t=t==null?e.map((r,o)=>o):[].concat(t),re(t.every(r=>r>=-n&&r<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${t}`),re(t.every(r=>tl(r)),()=>`All values in axis param must be integers but got axis ${t}`),t.map(r=>r<0?n+r:r)}function Mo(t,e){const n=[],r=[];for(let o=0;o<t.length;++o)t[o]!==1&&(n.push(t[o]),r.push(o));return{newShape:n,keptDims:r}}function qn(t,e){return nt(t,e)}function nt(t,e){let n=null;if(t==null||t==="float32")n=new Float32Array(e);else if(t==="int32")n=new Int32Array(e);else if(t==="bool")n=new Uint8Array(e);else if(t==="string")n=new Array(e);else throw new Error(`Unknown data type ${t}`);return n}function uI(t,e){for(let n=0;n<t.length;n++){const r=t[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${e} being uploaded contains ${r}.`)}}function lI(t){return t==="bool"||t==="complex64"||t==="float32"||t==="int32"||t==="string"}function Uv(t,e){return!(e==="complex64"||e==="float32"&&t!=="complex64"||e==="int32"&&t!=="float32"&&t!=="complex64"||e==="bool"&&t==="bool")}function nl(t){if(t==="float32"||t==="int32")return 4;if(t==="complex64")return 8;if(t==="bool")return 1;throw new Error(`Unknown dtype ${t}`)}function cI(t){if(t==null)return 0;let e=0;return t.forEach(n=>e+=n.length),e}function wa(t){return typeof t=="string"||t instanceof String}function dI(t){return typeof t=="boolean"}function fI(t){return typeof t=="number"}function Gi(t){return Array.isArray(t)?Gi(t[0]):t instanceof Float32Array?"float32":t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray?"int32":fI(t)?"float32":wa(t)?"string":dI(t)?"bool":"float32"}function nf(t){return!!(t&&t.constructor&&t.call&&t.apply)}function rf(t,e){for(let n=e;n<t;++n)if(t%n===0)return n;return t}function Ke(t){const e=t.length;if(e<2)return[];const n=new Array(e-1);n[e-2]=t[e-1];for(let r=e-3;r>=0;--r)n[r]=n[r+1]*t[r+1];return n}function Wv(t,e,n,r=!1){const o=new Array;if(e.length===1){const i=e[0]*(r?2:1);for(let a=0;a<i;a++)o[a]=n[t+a]}else{const i=e[0],a=e.slice(1),u=a.reduce((l,d)=>l*d)*(r?2:1);for(let l=0;l<i;l++)o[l]=Wv(t+l*u,a,n,r)}return o}function Hg(t,e,n=!1){if(t.length===0)return e[0];const r=t.reduce((o,i)=>o*i)*(n?2:1);if(r===0)return[];if(r!==e.length)throw new Error(`[${t}] does not match the input size ${e.length}${n?" for a complex tensor":""}.`);return Wv(0,t,e,n)}function Ed(t,e){if(Array.isArray(t))return t;if(e==="float32")return t instanceof Float32Array?t:new Float32Array(t);if(e==="int32")return t instanceof Int32Array?t:new Int32Array(t);if(e==="bool"||e==="string")return Uint8Array.from(new Int32Array(t));throw new Error(`Unknown dtype ${e}`)}function pI(t,e){const n=Kn(t,e);for(let r=0;r<n.length;r++)n[r]=1;return n}function Kn(t,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(t);if(e==="int32")return new Int32Array(t);if(e==="bool")return new Uint8Array(t);throw new Error(`Unknown data type ${e}`)}function Sa(t){t.forEach(e=>{re(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${t}].`)})}function of(t,e,n){if(e===0)return 0;if(e===1)return t[0];let r=t[t.length-1];for(let o=0;o<t.length-1;++o)r+=n[o]*t[o];return r}function Af(t,e,n){if(e===0)return[];if(e===1)return[t];const r=new Array(e);for(let o=0;o<r.length-1;++o)r[o]=Math.floor(t/n[o]),t-=r[o]*n[o];return r[r.length-1]=t,r}function Nf(t){return t&&t.then&&typeof t.then=="function"}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jg="tfjsflags";class hI{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=mI,this.populateURLFlags()}setPlatform(e,n){this.platform!=null&&(V().getBool("IS_TEST")||V().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=n}registerFlag(e,n,r){if(this.flagRegistry[e]={evaluationFn:n,setHook:r},this.urlFlags[e]!=null){const o=this.urlFlags[e];V().getBool("IS_TEST")||V().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${o}.`),this.set(e,o)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];const n=this.evaluateFlag(e);if(Nf(n))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=n,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,n){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=n,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(n)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const e=this.getQueryParams(this.global.location.search);jg in e&&e[jg].split(",").forEach(r=>{const[o,i]=r.split(":");this.urlFlags[o]=yI(o,i)})}}function mI(t){const e={};return t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(n,...r)=>(gI(e,r[0],r[1]),r.join("="))),e}function gI(t,e,n){t[decodeURIComponent(e)]=decodeURIComponent(n||"")}function yI(t,e){const n=e.toLowerCase();return n==="true"||n==="false"?n==="true":`${+n}`===n?+n:e}function V(){return Vv}let Vv=null;function xI(t){Vv=t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let _d;function zv(){if(_d==null){let t;if(typeof window<"u")t=window;else if(typeof global<"u")t=global;else if(typeof process<"u")t=process;else if(typeof self<"u")t=self;else throw new Error("Could not find a global object");_d=t}return _d}function vI(){const t=zv();return t._tfGlobals==null&&(t._tfGlobals=new Map),t._tfGlobals}function Of(t,e){const n=vI();if(n.has(t))return n.get(t);{const r=e();return n.set(t,r),n.get(t)}}const Df="Abs",Gv="Acos",Hv="Acosh",gl="Add",jv="AddN",Xv="All",qv="Any",Kv="ArgMax",Yv="ArgMin",Qv="Asin",Zv="Asinh",Jv="Atan",eC="Atanh",tC="Atan2",nC="AvgPool",rC="AvgPoolGrad",oC="AvgPool3D",iC="AvgPool3DGrad",sC="BatchMatMul",aC="BatchToSpaceND",uC="Bincount",CI="BitwiseAnd",lC="BroadcastArgs",yl="Cast",cC="Ceil",dC="ClipByValue",Ff="Complex",Lf="ComplexAbs",fC="Concat",pC="Conv2D",hC="Conv2DBackpropFilter",mC="Conv2DBackpropInput",gC="Conv3D",yC="Conv3DBackpropFilterV2",xC="Conv3DBackpropInputV2",vC="Cos",CC="Cosh",wC="Cumprod",SC="Cumsum",bC="CropAndResize",IC="DenseBincount",$C="DepthToSpace",RC="DepthwiseConv2dNative",EC="DepthwiseConv2dNativeBackpropFilter",_C="DepthwiseConv2dNativeBackpropInput",PC="Diag",kC="Dilation2D",wI="Dilation2DBackpropInput",SI="Dilation2DBackpropFilter",bI="Draw",Mf="RealDiv",TC="Einsum",Bf="Elu",AC="EluGrad",NC="Erf",OC="Equal",DC="Exp",FC="ExpandDims",LC="Expm1",MC="FFT",Uf="Fill",BC="FlipLeftRight",UC="Floor",Wf="FloorDiv",WC="FusedBatchNorm",VC="GatherV2",zC="GatherNd",GC="Greater",HC="GreaterEqual",xl="Identity",jC="IFFT",XC="Imag",qC="IsFinite",KC="IsInf",YC="IsNan",Vf="LeakyRelu",QC="Less",ZC="LessEqual",JC="LinSpace",e1="Log",t1="Log1p",n1="LogicalAnd",r1="LogicalNot",o1="LogicalOr",i1="LRN",s1="LRNGrad",a1="Max",zf="Maximum",u1="MaxPool",l1="MaxPoolGrad",c1="MaxPool3D",d1="MaxPool3DGrad",f1="MaxPoolWithArgmax",p1="Mean",h1="Min",m1="Minimum",g1="MirrorPad",y1="Mod",x1="Multinomial",Gf="Multiply",v1="Neg",C1="NotEqual",w1="NonMaxSuppressionV3",II="NonMaxSuppressionV4",S1="NonMaxSuppressionV5",b1="OnesLike",I1="OneHot",$1="Pack",R1="PadV2",Hf="Pow",jf="Prelu",E1="Prod",$I="RaggedGather",RI="RaggedRange",EI="RaggedTensorToTensor",_1="Range",P1="Real",k1="Reciprocal",Xf="Relu",qf="Reshape",T1="ResizeNearestNeighbor",A1="ResizeNearestNeighborGrad",N1="ResizeBilinear",O1="ResizeBilinearGrad",Kf="Relu6",D1="Reverse",F1="Round",L1="Rsqrt",M1="ScatterNd",B1="TensorScatterUpdate",U1="SearchSorted",W1="Select",V1="Selu",z1="Slice",G1="Sin",H1="Sinh",j1="Sign",Yf="Sigmoid",X1="Softplus",Qf="Sqrt",Zf="Sum",q1="SpaceToBatchND",K1="SplitV",Y1="Softmax",_I="SparseFillEmptyRows",PI="SparseReshape",Q1="SparseSegmentMean",Z1="SparseSegmentSum",J1="SparseToDense",e0="SquaredDifference",t0="Square",kI="StaticRegexReplace",n0="StridedSlice",r0="StringNGrams",TI="StringSplit",AI="StringToHashBucketFast",Jf="Sub",o0="Tan",i0="Tanh",ep="Tile",s0="TopK",a0="Transform",u0="Transpose",NI="Unique",l0="Unpack",c0="UnsortedSegmentSum",tp="ZerosLike",np="Step",d0="FromPixels",f0="RotateWithOffset",p0="_FusedMatMul",h0="FusedConv2D",m0="FusedDepthwiseConv2D";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yn(...t){V().getBool("IS_TEST")||V().getBool("PROD")||console.warn(...t)}function OI(...t){V().getBool("IS_TEST")||V().getBool("PROD")||console.log(...t)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rl=Of("kernelRegistry",()=>new Map),DI=Of("gradRegistry",()=>new Map);function Xg(t,e){const n=y0(t,e);return rl.get(n)}function qg(t){return DI.get(t)}function Kg(t){const e=rl.entries(),n=[];for(;;){const{done:r,value:o}=e.next();if(r)break;const[i,a]=o,[u]=i.split("_");u===t&&n.push(a)}return n}function g0(t){const{kernelName:e,backendName:n}=t,r=y0(e,n);rl.has(r)&&yn(`The kernel '${e}' for backend '${n}' is already registered`),rl.set(r,t)}function y0(t,e){return`${e}_${t}`}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x0(t){return t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray}var Pd,Yg;function FI(){if(Yg)return Pd;Yg=1,Pd=e;var t=null;try{t=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function e(O,_,F){this.low=O|0,this.high=_|0,this.unsigned=!!F}e.prototype.__isLong__,Object.defineProperty(e.prototype,"__isLong__",{value:!0});function n(O){return(O&&O.__isLong__)===!0}e.isLong=n;var r={},o={};function i(O,_){var F,U,G;return _?(O>>>=0,(G=0<=O&&O<256)&&(U=o[O],U)?U:(F=u(O,(O|0)<0?-1:0,!0),G&&(o[O]=F),F)):(O|=0,(G=-128<=O&&O<128)&&(U=r[O],U)?U:(F=u(O,O<0?-1:0,!1),G&&(r[O]=F),F))}e.fromInt=i;function a(O,_){if(isNaN(O))return _?S:w;if(_){if(O<0)return S;if(O>=y)return k}else{if(O<=-x)return D;if(O+1>=x)return T}return O<0?a(-O,_).neg():u(O%g|0,O/g|0,_)}e.fromNumber=a;function u(O,_,F){return new e(O,_,F)}e.fromBits=u;var l=Math.pow;function d(O,_,F){if(O.length===0)throw Error("empty string");if(O==="NaN"||O==="Infinity"||O==="+Infinity"||O==="-Infinity")return w;if(typeof _=="number"?(F=_,_=!1):_=!!_,F=F||10,F<2||36<F)throw RangeError("radix");var U;if((U=O.indexOf("-"))>0)throw Error("interior hyphen");if(U===0)return d(O.substring(1),_,F).neg();for(var G=a(l(F,8)),j=w,Z=0;Z<O.length;Z+=8){var L=Math.min(8,O.length-Z),X=parseInt(O.substring(Z,Z+L),F);if(L<8){var ne=a(l(F,L));j=j.mul(ne).add(a(X))}else j=j.mul(G),j=j.add(a(X))}return j.unsigned=_,j}e.fromString=d;function f(O,_){return typeof O=="number"?a(O,_):typeof O=="string"?d(O,_):u(O.low,O.high,typeof _=="boolean"?_:O.unsigned)}e.fromValue=f;var p=65536,h=1<<24,g=p*p,y=g*g,x=y/2,v=i(h),w=i(0);e.ZERO=w;var S=i(0,!0);e.UZERO=S;var I=i(1);e.ONE=I;var E=i(1,!0);e.UONE=E;var R=i(-1);e.NEG_ONE=R;var T=u(-1,2147483647,!1);e.MAX_VALUE=T;var k=u(-1,-1,!0);e.MAX_UNSIGNED_VALUE=k;var D=u(0,-2147483648,!1);e.MIN_VALUE=D;var N=e.prototype;return N.toInt=function(){return this.unsigned?this.low>>>0:this.low},N.toNumber=function(){return this.unsigned?(this.high>>>0)*g+(this.low>>>0):this.high*g+(this.low>>>0)},N.toString=function(_){if(_=_||10,_<2||36<_)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(D)){var F=a(_),U=this.div(F),G=U.mul(F).sub(this);return U.toString(_)+G.toInt().toString(_)}else return"-"+this.neg().toString(_);for(var j=a(l(_,6),this.unsigned),Z=this,L="";;){var X=Z.div(j),ne=Z.sub(X.mul(j)).toInt()>>>0,Q=ne.toString(_);if(Z=X,Z.isZero())return Q+L;for(;Q.length<6;)Q="0"+Q;L=""+Q+L}},N.getHighBits=function(){return this.high},N.getHighBitsUnsigned=function(){return this.high>>>0},N.getLowBits=function(){return this.low},N.getLowBitsUnsigned=function(){return this.low>>>0},N.getNumBitsAbs=function(){if(this.isNegative())return this.eq(D)?64:this.neg().getNumBitsAbs();for(var _=this.high!=0?this.high:this.low,F=31;F>0&&(_&1<<F)==0;F--);return this.high!=0?F+33:F+1},N.isZero=function(){return this.high===0&&this.low===0},N.eqz=N.isZero,N.isNegative=function(){return!this.unsigned&&this.high<0},N.isPositive=function(){return this.unsigned||this.high>=0},N.isOdd=function(){return(this.low&1)===1},N.isEven=function(){return(this.low&1)===0},N.equals=function(_){return n(_)||(_=f(_)),this.unsigned!==_.unsigned&&this.high>>>31===1&&_.high>>>31===1?!1:this.high===_.high&&this.low===_.low},N.eq=N.equals,N.notEquals=function(_){return!this.eq(_)},N.neq=N.notEquals,N.ne=N.notEquals,N.lessThan=function(_){return this.comp(_)<0},N.lt=N.lessThan,N.lessThanOrEqual=function(_){return this.comp(_)<=0},N.lte=N.lessThanOrEqual,N.le=N.lessThanOrEqual,N.greaterThan=function(_){return this.comp(_)>0},N.gt=N.greaterThan,N.greaterThanOrEqual=function(_){return this.comp(_)>=0},N.gte=N.greaterThanOrEqual,N.ge=N.greaterThanOrEqual,N.compare=function(_){if(n(_)||(_=f(_)),this.eq(_))return 0;var F=this.isNegative(),U=_.isNegative();return F&&!U?-1:!F&&U?1:this.unsigned?_.high>>>0>this.high>>>0||_.high===this.high&&_.low>>>0>this.low>>>0?-1:1:this.sub(_).isNegative()?-1:1},N.comp=N.compare,N.negate=function(){return!this.unsigned&&this.eq(D)?D:this.not().add(I)},N.neg=N.negate,N.add=function(_){n(_)||(_=f(_));var F=this.high>>>16,U=this.high&65535,G=this.low>>>16,j=this.low&65535,Z=_.high>>>16,L=_.high&65535,X=_.low>>>16,ne=_.low&65535,Q=0,H=0,K=0,J=0;return J+=j+ne,K+=J>>>16,J&=65535,K+=G+X,H+=K>>>16,K&=65535,H+=U+L,Q+=H>>>16,H&=65535,Q+=F+Z,Q&=65535,u(K<<16|J,Q<<16|H,this.unsigned)},N.subtract=function(_){return n(_)||(_=f(_)),this.add(_.neg())},N.sub=N.subtract,N.multiply=function(_){if(this.isZero())return w;if(n(_)||(_=f(_)),t){var F=t.mul(this.low,this.high,_.low,_.high);return u(F,t.get_high(),this.unsigned)}if(_.isZero())return w;if(this.eq(D))return _.isOdd()?D:w;if(_.eq(D))return this.isOdd()?D:w;if(this.isNegative())return _.isNegative()?this.neg().mul(_.neg()):this.neg().mul(_).neg();if(_.isNegative())return this.mul(_.neg()).neg();if(this.lt(v)&&_.lt(v))return a(this.toNumber()*_.toNumber(),this.unsigned);var U=this.high>>>16,G=this.high&65535,j=this.low>>>16,Z=this.low&65535,L=_.high>>>16,X=_.high&65535,ne=_.low>>>16,Q=_.low&65535,H=0,K=0,J=0,ge=0;return ge+=Z*Q,J+=ge>>>16,ge&=65535,J+=j*Q,K+=J>>>16,J&=65535,J+=Z*ne,K+=J>>>16,J&=65535,K+=G*Q,H+=K>>>16,K&=65535,K+=j*ne,H+=K>>>16,K&=65535,K+=Z*X,H+=K>>>16,K&=65535,H+=U*Q+G*ne+j*X+Z*L,H&=65535,u(J<<16|ge,H<<16|K,this.unsigned)},N.mul=N.multiply,N.divide=function(_){if(n(_)||(_=f(_)),_.isZero())throw Error("division by zero");if(t){if(!this.unsigned&&this.high===-2147483648&&_.low===-1&&_.high===-1)return this;var F=(this.unsigned?t.div_u:t.div_s)(this.low,this.high,_.low,_.high);return u(F,t.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?S:w;var U,G,j;if(this.unsigned){if(_.unsigned||(_=_.toUnsigned()),_.gt(this))return S;if(_.gt(this.shru(1)))return E;j=S}else{if(this.eq(D)){if(_.eq(I)||_.eq(R))return D;if(_.eq(D))return I;var Z=this.shr(1);return U=Z.div(_).shl(1),U.eq(w)?_.isNegative()?I:R:(G=this.sub(_.mul(U)),j=U.add(G.div(_)),j)}else if(_.eq(D))return this.unsigned?S:w;if(this.isNegative())return _.isNegative()?this.neg().div(_.neg()):this.neg().div(_).neg();if(_.isNegative())return this.div(_.neg()).neg();j=w}for(G=this;G.gte(_);){U=Math.max(1,Math.floor(G.toNumber()/_.toNumber()));for(var L=Math.ceil(Math.log(U)/Math.LN2),X=L<=48?1:l(2,L-48),ne=a(U),Q=ne.mul(_);Q.isNegative()||Q.gt(G);)U-=X,ne=a(U,this.unsigned),Q=ne.mul(_);ne.isZero()&&(ne=I),j=j.add(ne),G=G.sub(Q)}return j},N.div=N.divide,N.modulo=function(_){if(n(_)||(_=f(_)),t){var F=(this.unsigned?t.rem_u:t.rem_s)(this.low,this.high,_.low,_.high);return u(F,t.get_high(),this.unsigned)}return this.sub(this.div(_).mul(_))},N.mod=N.modulo,N.rem=N.modulo,N.not=function(){return u(~this.low,~this.high,this.unsigned)},N.and=function(_){return n(_)||(_=f(_)),u(this.low&_.low,this.high&_.high,this.unsigned)},N.or=function(_){return n(_)||(_=f(_)),u(this.low|_.low,this.high|_.high,this.unsigned)},N.xor=function(_){return n(_)||(_=f(_)),u(this.low^_.low,this.high^_.high,this.unsigned)},N.shiftLeft=function(_){return n(_)&&(_=_.toInt()),(_&=63)===0?this:_<32?u(this.low<<_,this.high<<_|this.low>>>32-_,this.unsigned):u(0,this.low<<_-32,this.unsigned)},N.shl=N.shiftLeft,N.shiftRight=function(_){return n(_)&&(_=_.toInt()),(_&=63)===0?this:_<32?u(this.low>>>_|this.high<<32-_,this.high>>_,this.unsigned):u(this.high>>_-32,this.high>=0?0:-1,this.unsigned)},N.shr=N.shiftRight,N.shiftRightUnsigned=function(_){if(n(_)&&(_=_.toInt()),_&=63,_===0)return this;var F=this.high;if(_<32){var U=this.low;return u(U>>>_|F<<32-_,F>>>_,this.unsigned)}else return _===32?u(F,0,this.unsigned):u(F>>>_-32,0,this.unsigned)},N.shru=N.shiftRightUnsigned,N.shr_u=N.shiftRightUnsigned,N.toSigned=function(){return this.unsigned?u(this.low,this.high,!1):this},N.toUnsigned=function(){return this.unsigned?this:u(this.low,this.high,!0)},N.toBytes=function(_){return _?this.toBytesLE():this.toBytesBE()},N.toBytesLE=function(){var _=this.high,F=this.low;return[F&255,F>>>8&255,F>>>16&255,F>>>24,_&255,_>>>8&255,_>>>16&255,_>>>24]},N.toBytesBE=function(){var _=this.high,F=this.low;return[_>>>24,_>>>16&255,_>>>8&255,_&255,F>>>24,F>>>16&255,F>>>8&255,F&255]},e.fromBytes=function(_,F,U){return U?e.fromBytesLE(_,F):e.fromBytesBE(_,F)},e.fromBytesLE=function(_,F){return new e(_[0]|_[1]<<8|_[2]<<16|_[3]<<24,_[4]|_[5]<<8|_[6]<<16|_[7]<<24,F)},e.fromBytesBE=function(_,F){return new e(_[4]<<24|_[5]<<16|_[6]<<8|_[7],_[0]<<24|_[1]<<16|_[2]<<8|_[3],F)},Pd}var v0=FI();const C0=Ef(v0),LI=K2({__proto__:null,default:C0},[v0]);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _o=C0||LI;function vl(t){return _o.fromString(t,!0,16)}const w0=vl("c3a5c85c97cb3127"),Ro=vl("b492b66fbe98f273"),xt=vl("9ae16a3b2f90404f");function sf(t){return t.xor(t.shru(47))}function S0(t,e,n){const r=t.slice(e,e+n);return _o.fromBytes(Array.from(r),!0,!0)}function Ue(t,e){return S0(t,e,8)}function Qg(t,e){return S0(t,e,4)}function ot(t,e){return e===0?t:t.shru(e).or(t.shl(64-e))}function Tr(t,e,n=vl("9ddfea08eb382d69")){let r=t.xor(e).mul(n);r=r.xor(r.shru(47));let o=e.xor(r).mul(n);return o=o.xor(o.shru(47)),o=o.mul(n),o}function MI(t,e,n,r,o,i){o=o.add(t),i=ot(i.add(o).add(r),21);const a=o;return o=o.add(e),o=o.add(n),i=i.add(ot(o,44)),[o.add(r),i.add(a)]}function Lu(t,e,n,r){return MI(Ue(t,e),Ue(t,e+8),Ue(t,e+16),Ue(t,e+24),n,r)}function BI(t,e=t.length){if(e>=8){const n=xt.add(e*2),r=Ue(t,0).add(xt),o=Ue(t,e-8),i=ot(o,37).mul(n).add(r),a=ot(r,25).add(o).mul(n);return Tr(i,a,n)}if(e>=4){const n=xt.add(e*2),r=Qg(t,0);return Tr(r.shl(3).add(e),Qg(t,e-4),n)}if(e>0){const n=t[0],r=t[e>>1],o=t[e-1],i=n+(r<<8),a=e+(o<<2);return sf(xt.mul(i).xor(w0.mul(a))).mul(xt)}return xt}function UI(t,e=t.length){const n=xt.add(e*2),r=Ue(t,0).mul(Ro),o=Ue(t,8),i=Ue(t,e-8).mul(n),a=Ue(t,e-16).mul(xt);return Tr(ot(r.add(o),43).add(ot(i,30)).add(a),r.add(ot(o.add(xt),18)).add(i),n)}function WI(t,e=t.length){const n=xt.add(e*2),r=Ue(t,0).mul(xt),o=Ue(t,8),i=Ue(t,e-8).mul(n),a=Ue(t,e-16).mul(xt),u=ot(r.add(o),43).add(ot(i,30)).add(a),l=Tr(u,r.add(ot(o.add(xt),18)).add(i),n),d=Ue(t,16).mul(n),f=Ue(t,24),p=u.add(Ue(t,e-32)).mul(n),h=l.add(Ue(t,e-24)).mul(n);return Tr(ot(d.add(f),43).add(ot(p,30)).add(h),d.add(ot(f.add(r),18)).add(p),n)}function VI(t,e=t.length){const n=_o.fromNumber(81,!0);if(e<=32)return e<=16?BI(t,e):UI(t,e);if(e<=64)return WI(t,e);let r=n,o=n.mul(Ro).add(113),i=sf(o.mul(xt).add(113)).mul(xt),a=[_o.UZERO,_o.UZERO],u=[_o.UZERO,_o.UZERO];r=r.mul(xt).add(Ue(t,0));let l=0;const d=(e-1>>6)*64,f=d+(e-1&63)-63;do r=ot(r.add(o).add(a[0]).add(Ue(t,l+8)),37).mul(Ro),o=ot(o.add(a[1]).add(Ue(t,l+48)),42).mul(Ro),r=r.xor(u[1]),o=o.add(a[0]).add(Ue(t,l+40)),i=ot(i.add(u[0]),33).mul(Ro),a=Lu(t,l,a[1].mul(Ro),r.add(u[0])),u=Lu(t,l+32,i.add(u[1]),o.add(Ue(t,l+16))),[i,r]=[r,i],l+=64;while(l!==d);const p=Ro.add(i.and(255).shl(1));return l=f,u[0]=u[0].add(e-1&63),a[0]=a[0].add(u[0]),u[0]=u[0].add(a[0]),r=ot(r.add(o).add(a[0]).add(Ue(t,l+8)),37).mul(p),o=ot(o.add(a[1]).add(Ue(t,l+48)),42).mul(p),r=r.xor(u[1].mul(9)),o=o.add(a[0].mul(9).add(Ue(t,l+40))),i=ot(i.add(u[0]),33).mul(p),a=Lu(t,l,a[1].mul(p),r.add(u[0])),u=Lu(t,l+32,i.add(u[1]),o.add(Ue(t,l+16))),[i,r]=[r,i],Tr(Tr(a[0],u[0],p).add(sf(o).mul(w0)).add(i),Tr(a[1],u[1],p).add(r),p)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hi(t,e){return e==="string"?Ar(t):Cl([t],e)}function zI(t,e){return t instanceof Float32Array&&e==="float32"||t instanceof Int32Array&&e==="int32"||t instanceof Uint8Array&&e==="bool"}function Cl(t,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(t)&&(t=Qn(t)),V().getBool("DEBUG")&&uI(t,e),zI(t,e))return t;if(e==null||e==="float32"||e==="complex64")return new Float32Array(t);if(e==="int32")return new Int32Array(t);if(e==="bool"){const n=new Uint8Array(t.length);for(let r=0;r<n.length;++r)Math.round(t[r])!==0&&(n[r]=1);return n}else throw new Error(`Unknown data type ${e}`)}function pn(){return V().platform.now()}function Ar(t,e="utf-8"){return e=e||"utf-8",V().platform.encode(t,e)}function Yn(t,e="utf-8"){return e=e||"utf-8",V().platform.decode(t,e)}function en(t){return V().platform.isTypedArray!=null?V().platform.isTypedArray(t):x0(t)}function Qn(t,e=[],n=!1){if(e==null&&(e=[]),typeof t=="boolean"||typeof t=="number"||typeof t=="string"||Nf(t)||t==null||en(t)&&n)e.push(t);else if(Array.isArray(t)||en(t))for(let r=0;r<t.length;++r)Qn(t[r],e,n);else{let r=-1;for(const o of Object.keys(t))/^([1-9]+[0-9]*|0)$/.test(o)&&(r=Math.max(r,Number(o)));for(let o=0;o<=r;o++)Qn(t[o],e,n)}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class GI{constructor(e,n){this.backendTimer=e,this.logger=n,n==null&&(this.logger=new jI)}profileKernel(e,n,r){let o;const i=()=>{o=r()};let a;const u=pn();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(i);else{i();for(const d of o)d.dataSync();a=Promise.resolve({kernelMs:pn()-u})}if(V().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let d=0;d<o.length;d++){const f=o[d];f.data().then(p=>{HI(p,f.dtype,e)})}return{kernelName:e,outputs:o,inputs:n,timeMs:a.then(d=>d.kernelMs),extraInfo:a.then(d=>d.getExtraProfileInfo!=null?d.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:n,outputs:r,timeMs:o,inputs:i,extraInfo:a}=e;r.forEach(u=>{Promise.all([u.data(),o,a]).then(l=>{this.logger.logKernelProfile(n,u,l[0],l[1],i,l[2])})})}}function HI(t,e,n){if(e!=="float32")return!1;for(let r=0;r<t.length;r++){const o=t[r];if(isNaN(o)||!isFinite(o))return console.warn(`Found ${o} in the result of '${n}'`),!0}return!1}class jI{logKernelProfile(e,n,r,o,i,a){const u=typeof o=="number"?Di(`${o}ms`,9):o.error,l=Di(e,25),d=n.rank,f=n.size,p=Di(n.shape.toString(),14);let h="";for(const g in i){const y=i[g];if(y!=null){const x=y.shape||n.shape,v=x.length;h+=`${g}: ${v}D ${v>0?x:""} `}}console.log(`%c${l}	%c${u}	%c${d}D ${p}	%c${f}	%c${h}	%c${a}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XI(t,e,n){const r={},o={};for(let l=0;l<e.length;l++)r[e[l].id]=!0;for(let l=0;l<t.length;l++){const d=t[l],f=d.inputs;for(const p in f){const h=f[p];let g=!1;for(let y=0;y<e.length;y++)if(r[h.id]){d.outputs.forEach(x=>r[x.id]=!0),g=!0,o[d.id]=!0;break}if(g)break}}const i={};i[n.id]=!0;const a={};for(let l=t.length-1;l>=0;l--){const d=t[l],f=d.inputs;for(let p=0;p<d.outputs.length;p++)if(i[d.outputs[p].id]){for(const h in f)i[f[h].id]=!0,a[d.id]=!0;break}}const u=[];for(let l=0;l<t.length;l++){const d=t[l];if(o[d.id]&&a[d.id]){const f={};for(const h in d.inputs){const g=d.inputs[h];r[g.id]&&(f[h]=g)}const p=Object.assign({},d);p.inputs=f,p.outputs=d.outputs,u.push(p)}}return u}function qI(t,e,n,r){for(let o=e.length-1;o>=0;o--){const i=e[o],a=[];if(i.outputs.forEach(l=>{const d=t[l.id];d!=null?a.push(d):a.push(null)}),i.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${i.kernelName}.`);const u=i.gradient(a);for(const l in i.inputs){if(!(l in u))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(u)}.`);const d=n(()=>u[l]());if(d.dtype!=="float32")throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${d.dtype}'`);const f=i.inputs[l];if(!je(d.shape,f.shape))throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input '${l}' has shape '${d.shape}', which does not match the shape of the input '${f.shape}'`);if(t[f.id]==null)t[f.id]=d;else{const p=t[f.id];t[f.id]=r(p,d),p.dispose()}}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zg=20,Hs=3,kd=7;function KI(t,e,n,r){const o=Ke(e),i=YI(t,e,n,o),a=e.length,u=Qu(t,e,n,o,i),l=["Tensor"];return r&&(l.push(`  dtype: ${n}`),l.push(`  rank: ${a}`),l.push(`  shape: [${e}]`),l.push("  values:")),l.push(u.map(d=>"    "+d).join(`
`)),l.join(`
`)}function YI(t,e,n,r){const o=Y(e),i=r[r.length-1],a=new Array(i).fill(0),u=e.length,l=n==="complex64"?sa(t):t;if(u>1)for(let d=0;d<o/i;d++){const f=d*i;for(let p=0;p<i;p++)a[p]=Math.max(a[p],ia(l[f+p],0,n).length)}return a}function ia(t,e,n){let r;return Array.isArray(t)?r=`${parseFloat(t[0].toFixed(kd))} + ${parseFloat(t[1].toFixed(kd))}j`:wa(t)?r=`'${t}'`:n==="bool"?r=b0(t):r=parseFloat(t.toFixed(kd)).toString(),Di(r,e)}function b0(t){return t===0?"false":"true"}function Qu(t,e,n,r,o,i=!0){const a=n==="complex64"?2:1,u=e[0],l=e.length;if(l===0){if(n==="complex64"){const x=sa(t);return[ia(x[0],0,n)]}return n==="bool"?[b0(t[0])]:[t[0].toString()]}if(l===1){if(u>Zg){const v=Hs*a;let w=Array.from(t.slice(0,v)),S=Array.from(t.slice((u-Hs)*a,u*a));return n==="complex64"&&(w=sa(w),S=sa(S)),["["+w.map((I,E)=>ia(I,o[E],n)).join(", ")+", ..., "+S.map((I,E)=>ia(I,o[u-Hs+E],n)).join(", ")+"]"]}return["["+(n==="complex64"?sa(t):Array.from(t)).map((v,w)=>ia(v,o[w],n)).join(", ")+"]"]}const d=e.slice(1),f=r.slice(1),p=r[0]*a,h=[];if(u>Zg){for(let x=0;x<Hs;x++){const v=x*p,w=v+p;h.push(...Qu(t.slice(v,w),d,n,f,o,!1))}h.push("...");for(let x=u-Hs;x<u;x++){const v=x*p,w=v+p;h.push(...Qu(t.slice(v,w),d,n,f,o,x===u-1))}}else for(let x=0;x<u;x++){const v=x*p,w=v+p;h.push(...Qu(t.slice(v,w),d,n,f,o,x===u-1))}const g=l===2?",":"";h[0]="["+(u>0?h[0]+g:"");for(let x=1;x<h.length-1;x++)h[x]=" "+h[x]+g;let y=`,
`;for(let x=2;x<l;x++)y+=`
`;return h[h.length-1]=" "+h[h.length-1]+"]"+(i?"":y),h}function sa(t){const e=[];for(let n=0;n<t.length;n+=2)e.push([t[n],t[n+1]]);return e}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ol{constructor(e,n,r){if(this.dtype=n,this.shape=e.slice(),this.size=Y(e),r!=null){const o=r.length;re(o===this.size,()=>`Length of values '${o}' does not match the size inferred by the shape '${this.size}'.`)}if(n==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=r||nt(n,this.size),this.strides=Ke(e)}set(e,...n){n.length===0&&(n=[0]),re(n.length===this.rank,()=>`The number of provided coordinates (${n.length}) must match the rank (${this.rank})`);const r=this.locToIndex(n);this.values[r]=e}get(...e){e.length===0&&(e=[0]);let n=0;for(const o of e){if(o<0||o>=this.shape[n]){const i=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(i)}n++}let r=e[e.length-1];for(let o=0;o<e.length-1;++o)r+=this.strides[o]*e[o];return this.values[r]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let n=e[e.length-1];for(let r=0;r<e.length-1;++r)n+=this.strides[r]*e[r];return n}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];const n=new Array(this.shape.length);for(let r=0;r<n.length-1;++r)n[r]=Math.floor(e/this.strides[r]),e-=n[r]*this.strides[r];return n[n.length-1]=e,n}get rank(){return this.shape.length}toTensor(){return hn().makeTensor(this.values,this.shape,this.dtype)}}let hn=null,Ni=null;function QI(t){hn=t}function ZI(t){Ni=t}class mn{constructor(e,n,r,o){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=n||"float32",this.size=Y(e),this.strides=Ke(e),this.dataId=r,this.id=o,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return Ni.buffer(this.shape,this.dtype,e)}bufferSync(){return Ni.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return Hg(this.shape,e,this.dtype==="complex64")}arraySync(){return Hg(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const e=hn().read(this.dataId);if(this.dtype==="string"){const n=await e;try{return n.map(r=>Yn(r))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),hn().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=hn().readSync(this.dataId);if(this.dtype==="string")try{return e.map(n=>Yn(n))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await hn().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),hn().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return Ni.print(this,e)}clone(){return this.throwIfDisposed(),Ni.clone(this)}toString(e=!1){const n=this.dataSync();return KI(n,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),Ni.cast(this,e)}variable(e=!0,n,r){return this.throwIfDisposed(),hn().makeVariable(this,e,n,r)}}Object.defineProperty(mn,Symbol.hasInstance,{value:t=>!!t&&t.data!=null&&t.dataSync!=null&&t.throwIfDisposed!=null});function I0(){return Of("Tensor",()=>mn)}I0();class il extends mn{constructor(e,n,r,o){super(e.shape,e.dtype,e.dataId,o),this.trainable=n,this.name=r}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!je(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);hn().disposeTensor(this),this.dataId=e.dataId,hn().incRef(this,null)}dispose(){hn().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(il,Symbol.hasInstance,{value:t=>t instanceof mn&&t.assign!=null&&t.assign instanceof Function});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Jg;(function(t){t.R0="R0",t.R1="R1",t.R2="R2",t.R3="R3",t.R4="R4",t.R5="R5",t.R6="R6"})(Jg||(Jg={}));var af;(function(t){t.float32="float32",t.int32="int32",t.bool="int32",t.complex64="complex64"})(af||(af={}));var uf;(function(t){t.float32="float32",t.int32="int32",t.bool="bool",t.complex64="complex64"})(uf||(uf={}));var lf;(function(t){t.float32="float32",t.int32="float32",t.bool="float32",t.complex64="complex64"})(lf||(lf={}));var cf;(function(t){t.float32="complex64",t.int32="complex64",t.bool="complex64",t.complex64="complex64"})(cf||(cf={}));const JI={float32:lf,int32:af,bool:uf,complex64:cf};function Rt(t,e){if(t==="string"||e==="string"){if(t==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${t} with ${e}`)}return JI[t][e]}function wl(t){return Rt(t,"int32")}function $0(t){return t!=null&&typeof t=="object"&&"texture"in t&&t.texture instanceof WebGLTexture}function R0(t){return typeof GPUBuffer<"u"&&t!=null&&typeof t=="object"&&"buffer"in t&&t.buffer instanceof GPUBuffer}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bo(t,e){if(t.dtype===e.dtype)return[t,e];const n=Rt(t.dtype,e.dtype);return[t.cast(n),e.cast(n)]}function E0(t){const e=[];return _0(t,e,new Set),e}function _0(t,e,n){if(t==null)return;if(t instanceof mn){e.push(t);return}if(!e$(t))return;const r=t;for(const o in r){const i=r[o];n.has(i)||(n.add(i),_0(i,e,n))}}function e$(t){return Array.isArray(t)||typeof t=="object"}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Td(t){return t.kernelName!=null}class ey{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class Mi{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new ey}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const e=this.getSortedBackends();for(let n=0;n<e.length;n++){const r=e[n];if(await this.initializeBackend(r).success){await this.setBackend(r);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:e,asyncInit:n}=this.initializeBackendsAndReturnBest();if(n)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){const{asyncInit:n}=this.initializeBackend(e);if(n)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,n,r=1){return e in this.registryFactory?(yn(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:n,priority:r},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;const{success:n,asyncInit:r}=this.initializeBackend(e);if(!(r?await n:n))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new GI(this.backendInstance),!0}setupRegisteredKernels(){Kg(this.backendName).forEach(n=>{n.setupFunc!=null&&n.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){Kg(e).forEach(r=>{r.disposeFunc!=null&&r.disposeFunc(this.registry[e])})}initializeBackend(e){const n=this.registryFactory[e];if(n==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const r=n.factory();if(r&&!(r instanceof Pf)&&typeof r.then=="function"){const o=++this.pendingBackendInitId,i=r.then(a=>o<this.pendingBackendInitId?!1:(this.registry[e]=a,this.pendingBackendInit=null,!0)).catch(a=>(o<this.pendingBackendInitId||(this.pendingBackendInit=null,yn(`Initialization of backend ${e} failed`),yn(a.stack||a.message)),!1));return this.pendingBackendInit=i,{success:i,asyncInit:!0}}else return this.registry[e]=r,{success:!0,asyncInit:!1}}catch(r){return yn(`Initialization of backend ${e} failed`),yn(r.stack||r.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,n)=>this.registryFactory[n].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let n=0;n<e.length;n++){const r=e[n],{success:o,asyncInit:i}=this.initializeBackend(r);if(i||o)return{name:r,asyncInit:i}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,n){const r=this.state.tensorInfo.get(n),o=r.backend,i=this.readSync(n),a=o.refCount(n);o.disposeData(n,!0),r.backend=e,e.move(n,i,r.shape,r.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,n){let r=null;if(n==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");n=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof n!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}let o;return this.scopedRun(()=>this.startScope(r),()=>this.endScope(o),()=>(o=n(),o instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),o))}scopedRun(e,n,r){e();try{const o=r();return n(),o}catch(o){throw n(),o}}nextTensorId(){return Mi.nextTensorId++}nextVariableId(){return Mi.nextVariableId++}clone(e){const n=xe.runKernel(xl,{x:e}),r={x:e},o=a=>({x:()=>{const u="float32",l={x:a},d={dtype:u};return xe.runKernel(yl,l,d)}}),i=[];return this.addTapeNode(this.state.activeScope.name,r,[n],o,i,{}),n}runKernel(e,n,r){if(this.backendName==null&&this.backend,!(Xg(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:n,attrs:r})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,n,r){const o=this.backend.numDataIds();let i=0;r.forEach(l=>{i+=l.dtype==="complex64"?3:1});const a=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],u=o-n-i-a;if(u>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${u} data ids) after running '${e}'`)}runKernelFunc(e){let n,r=[];const o=this.isTapeOn(),i=this.state.numBytes,a=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let u;this.backendName==null&&this.backend;let l;const d=Td(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(Td(e)){const{kernelName:y,inputs:x,attrs:v}=e;this.backendName==null&&this.backend;const w=Xg(y,this.backendName);re(w!=null,()=>`Cannot find registered kernel '${y}' for backend '${this.backendName}'`),u=()=>{const S=this.backend.numDataIds();l=w.kernelFunc({inputs:x,attrs:v,backend:this.backend});const I=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(y,S,I);const E=I.map(R=>R.rank!=null?R:this.makeTensorFromTensorInfo(R));if(o){const R=this.getTensorsForGradient(y,x,E);r=this.saveTensorsForBackwardMode(R)}return E}}else{const{forwardFunc:y}=e,x=v=>{o&&(r=v.map(w=>this.keep(this.clone(w))))};u=()=>{const v=this.backend.numDataIds();l=this.tidy(()=>y(this.backend,x));const w=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(d,v,w),w}}const{inputs:f,attrs:p}=e,h=Td(e)?null:e.backwardsFunc;let g;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?n=u():(g=this.profiler.profileKernel(d,f,()=>u()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(g),n=g.outputs)}),o&&this.addTapeNode(d,f,n,h,r,p),this.state.profiling&&this.state.activeProfile.kernels.push({name:d,bytesAdded:this.state.numBytes-i,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(f).map(y=>f[y]!=null?f[y].shape:null),outputShapes:n.map(y=>y.shape),kernelTimeMs:g.timeMs,extraInfo:g.extraInfo}),Array.isArray(l)?n:n[0]}saveTensorsForBackwardMode(e){return e.map(r=>this.keep(this.clone(r)))}getTensorsForGradient(e,n,r){const o=qg(e);if(o!=null){const i=o.inputsToSave||[],a=o.outputsToSave||[];let u;o.saveAllInputs?(re(Array.isArray(n),()=>"saveAllInputs is true, expected inputs to be an array."),u=Object.keys(n).map(d=>n[d])):u=i.map(d=>n[d]);const l=r.filter((d,f)=>a[f]);return u.concat(l)}return[]}makeTensor(e,n,r,o){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");r=r||"float32",o=o||this.backend;let i=e;r==="string"&&wa(e[0])&&(i=e.map(l=>Ar(l)));const a=o.write(i,n,r),u=new mn(n,r,a,this.nextTensorId());if(this.trackTensor(u,o),r==="string"){const l=this.state.tensorInfo.get(a),d=cI(i);this.state.numBytes+=d-l.bytes,l.bytes=d}return u}makeTensorFromDataId(e,n,r,o){r=r||"float32";const i={dataId:e,shape:n,dtype:r};return this.makeTensorFromTensorInfo(i,o)}makeTensorFromTensorInfo(e,n){const{dataId:r,shape:o,dtype:i}=e,a=new mn(o,i,r,this.nextTensorId());return this.trackTensor(a,n),a}makeVariable(e,n=!0,r,o){r=r||this.nextVariableId().toString(),o!=null&&o!==e.dtype&&(e=e.cast(o));const i=new il(e,n,r,this.nextTensorId());if(this.state.registeredVariables[i.name]!=null)throw new Error(`Variable with name ${i.name} was already registered`);return this.state.registeredVariables[i.name]=i,this.incRef(i,this.backend),i}trackTensor(e,n){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let r=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(r=e.size*nl(e.dtype)),this.state.numBytes+=r,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:n||this.backend,dtype:e.dtype,shape:e.shape,bytes:r})),e instanceof il||this.track(e)}incRef(e,n){this.trackTensor(e,n),this.backend.incRef(e.dataId)}removeDataId(e,n){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===n&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const n=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=n.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){const r=e.size*nl(e.dtype);this.state.numBytes-=r}n.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,n.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const n=this.state.registeredVariables[e];this.disposeVariable(n)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const n=this.state.numBytes,r=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(o=>o.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-n,this.state.activeProfile.newTensors=this.state.numTensors-r;for(const o of this.state.activeProfile.kernels)o.kernelTimeMs=await o.kernelTimeMs,o.extraInfo=await o.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,n,r,o,i,a){const u={id:this.state.nextTapeNodeId++,kernelName:e,inputs:n,outputs:r,saved:i},l=qg(e);l!=null&&(o=l.gradFunc),o!=null&&(u.gradient=d=>(d=d.map((f,p)=>{if(f==null){const h=r[p],g=Kn(h.size,h.dtype);return this.makeTensor(g,h.shape,h.dtype)}return f}),o(d.length>1?d:d[0],i,a))),this.state.activeTape.push(u)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const n={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(n.name=e),this.state.scopeStack.push(n),this.state.activeScope=n}endScope(e){const n=E0(e),r=new Set(n.map(i=>i.id));for(let i=0;i<this.state.activeScope.track.length;i++){const a=this.state.activeScope.track[i];!a.kept&&!r.has(a.id)&&a.dispose()}const o=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],n.forEach(i=>{!i.kept&&i.scopeId===o.id&&this.track(i)})}gradients(e,n,r,o=!1){if(re(n.length>0,()=>"gradients() received an empty list of xs."),r!=null&&r.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${r.dtype}'`);const i=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));re(i instanceof mn,()=>"The result y returned by f() must be a tensor.");const a=XI(this.state.activeTape,n,i);if(!o&&a.length===0&&n.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const u={};u[i.id]=r??t$(i.shape),qI(u,a,d=>this.tidy(d),n$);const l=n.map(d=>u[d.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(d=>{for(const f of d.saved)f.dispose()}),this.state.activeTape=null),{value:i,grads:l}})}customGrad(e){return re(nf(e),()=>"The f passed in customGrad(f) must be a function."),(...n)=>{re(n.every(u=>u instanceof mn),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let r;const o={};n.forEach((u,l)=>{o[l]=u});const i=(u,l)=>(r=e(...n,l),re(r.value instanceof mn,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),re(nf(r.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),r.value),a=(u,l)=>{const d=r.gradFunc(u,l),f=Array.isArray(d)?d:[d];re(f.length===n.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),re(f.every(h=>h instanceof mn),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const p={};return f.forEach((h,g)=>{p[g]=()=>h}),p};return this.runKernelFunc({forwardFunc:i,backwardsFunc:a,inputs:o})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,n){return this.state.tensorInfo.get(e).backend.readToGPU(e,n)}async time(e){const n=pn(),r=await this.backend.time(e);return r.wallMs=pn()-n,r}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new ey;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}Mi.nextTensorId=0;Mi.nextVariableId=0;function t$(t){const e=pI(Y(t),"float32");return xe.makeTensor(e,t,"float32")}function P0(){const t=zv();if(t._tfengine==null){const e=new hI(t);t._tfengine=new Mi(e)}return xI(t._tfengine.ENV),QI(()=>t._tfengine),t._tfengine}const xe=P0();function n$(t,e){const n={a:t,b:e};return xe.runKernel(gl,n)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r$(){return typeof navigator<"u"&&navigator!=null}function k0(t){if(t||r$()){if(t||(t=navigator),t.product==="ReactNative")return!0;const e=t.userAgent||t.vendor||(typeof window<"u"?window.opera:"");if(!e){const n=t;return n.userAgentData&&n.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function T0(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Et=V();Et.registerFlag("DEBUG",()=>!1,t=>{t&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});Et.registerFlag("IS_BROWSER",()=>T0());Et.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");Et.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));Et.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));Et.registerFlag("PROD",()=>!1);Et.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Et.getBool("DEBUG"));Et.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);Et.registerFlag("IS_TEST",()=>!1);Et.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>Et.getBool("DEBUG"));Et.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);Et.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);Et.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o$(t,e){let n=t;if(en(t))return e==="string"?[]:[t.length];if($0(t)){const o=t.channels||"RGBA";return[t.height,t.width*o.length]}else if(R0(t))return[t.buffer.size/(e==null?4:nl(e))];if(!Array.isArray(t))return[];const r=[];for(;Array.isArray(n)||en(n)&&e!=="string";)r.push(n.length),n=n[0];return Array.isArray(t)&&V().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&A0(t,r,[]),r}function A0(t,e,n){if(n=n||[],!Array.isArray(t)&&!en(t)){re(e.length===0,()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}re(e.length>0,()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${t.length} elements`),re(t.length===e[0],()=>`Element arr[${n.join("][")}] should have ${e[0]} elements, but has ${t.length} elements`);const r=e.slice(1);for(let o=0;o<t.length;++o)A0(t[o],r,n.concat(o))}function ty(t,e,n,r){if(t!=="string_or_numeric"){if(t==null)throw new Error("Expected dtype cannot be null.");if(t!=="numeric"&&t!==e||t==="numeric"&&e==="string")throw new Error(`Argument '${n}' passed to '${r}' must be ${t} tensor, but got ${e} tensor`)}}function Oe(t,e,n,r="numeric"){if(t instanceof I0())return ty(r,t.dtype,e,n),t;let o=Gi(t);if(o!=="string"&&["bool","int32","float32"].indexOf(r)>=0&&(o=r),ty(r,o,e,n),t==null||!en(t)&&!Array.isArray(t)&&typeof t!="number"&&typeof t!="boolean"&&typeof t!="string"){const l=t==null?"null":t.constructor.name;throw new Error(`Argument '${e}' passed to '${n}' must be a Tensor or TensorLike, but got '${l}'`)}const i=o$(t,o);!en(t)&&!Array.isArray(t)&&(t=[t]);const u=o!=="string"?Cl(t,o):Qn(t,[],!0);return xe.makeTensor(u,i,o)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const i$="__op";function qe(t){const e=Object.keys(t);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let n=e[0];const r=t[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n=n+i$;const o=(...i)=>{xe.startScope(n);try{const a=r(...i);return Nf(a)&&console.error("Cannot return a Promise inside of tidy."),xe.endScope(a),a}catch(a){throw xe.endScope(null),a}};return Object.defineProperty(o,"name",{value:n,configurable:!0}),o}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s$(t,e){const n=Oe(t,"real","complex"),r=Oe(e,"imag","complex");Tf(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`);const o={real:n,imag:r};return xe.runKernel(Ff,o)}const a$=qe({complex_:s$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u$(t,e,n,r){if(r==null)r=Gi(t);else if(r==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(R0(t)||$0(t)){if(r!=="float32"&&r!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return xe.backend.createTensorFromGPUData(t,e||n,r)}if(!en(t)&&!Array.isArray(t)&&typeof t!="number"&&typeof t!="boolean"&&typeof t!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){Sa(e);const o=Y(e),i=Y(n);re(o===i,()=>`Based on the provided shape, [${e}], the tensor should have ${o} values but has ${i}`);for(let a=0;a<n.length;++a){const u=n[a],l=a===n.length-1?u!==Y(e.slice(a)):!0;re(n[a]===e[a]||!l,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${e}). `)}}return!en(t)&&!Array.isArray(t)&&(t=[t]),e=e||n,t=r!=="string"?Cl(t,r):Qn(t,[],!0),xe.makeTensor(t,e,r)}class ba{static join(e){return new ba(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,e==null||(e instanceof Array||(e=[e]),e=e.map(r=>en(r)?r.buffer:r),e.length===0))return;this.bufferUniformSize=e[0].byteLength;let n=0;for(let r=0;r<e.length;r++){const o=e[r];r!==e.length-1&&o.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const i=n+o.byteLength;this.shards.push({buffer:o,start:n,end:i}),n=i}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(e=0,n=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,n=isNaN(Number(n))?0:n,e=Math.max(0,e),n=Math.min(this.byteLength,n),n<=e)return new ArrayBuffer(0);const r=this.findShardForByte(e);if(r===-1)throw new Error(`Could not find start shard for byte ${e}`);const o=n-e,i=new ArrayBuffer(o),a=new Uint8Array(i);let u=0;for(let l=r;l<this.shards.length;l++){const d=this.shards[l],p=e+u-d.start,h=u,y=Math.min(n,d.end)-d.start,x=new Uint8Array(d.buffer,p,y-p);if(a.set(x,h),u+=x.length,n<d.end)break}return i}findShardForByte(e){if(this.shards.length===0||e<0||e>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function n(o){return e<o.start?-1:e>=o.end?1:0}if(n(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;const r=l$(this.shards,n);return r===-1?-1:(this.previousShardIndex=r,this.previousShardIndex)}}function l$(t,e){let n=0,r=t.length;for(;n<=r;){const o=Math.floor((r-n)/2)+n,i=e(t[o]);if(i===0)return o;i<0?r=o:n=o+1}return-1}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fn(){return xe}function tt(t,e){return xe.tidy(t,e)}function Gt(t){E0(t).forEach(n=>n.dispose())}function c$(t){return xe.keep(t)}function N0(t,e,n=1){return xe.registerBackend(t,e,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rp=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function ny(t){return rp?Buffer.byteLength(t,"utf8"):new Blob([t]).size}function d$(t){if(rp)return Buffer.from(t).toString("base64");const e=new Uint8Array(t);let n="";for(let r=0,o=e.length;r<o;r++)n+=String.fromCharCode(e[r]);return btoa(n)}function f$(t){if(rp){const r=Buffer.from(t,"base64");return r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}const e=atob(t),n=new Uint8Array(e.length);for(let r=0;r<e.length;++r)n.set([e.charCodeAt(r)],r);return n.buffer}function O0(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:t.modelTopology==null?0:ny(JSON.stringify(t.modelTopology)),weightSpecsBytes:t.weightSpecs==null?0:ny(JSON.stringify(t.weightSpecs)),weightDataBytes:t.weightData==null?0:new ba(t.weightData).byteLength}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class It{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return It.instance==null&&(It.instance=new It),It.instance}static registerSaveRouter(e){It.getInstance().saveRouters.push(e)}static registerLoadRouter(e){It.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return It.getHandlers(e,"save")}static getLoadHandlers(e,n){return It.getHandlers(e,"load",n)}static getHandlers(e,n,r){const o=[];return(n==="load"?It.getInstance().loadRouters:It.getInstance().saveRouters).forEach(a=>{const u=a(e,r);u!==null&&o.push(u)}),o}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const df="tensorflowjs",ff=1,Ao="models_store",Pr="model_info_store";function D0(){if(!V().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const t=typeof window>"u"?self:window,e=t.indexedDB||t.mozIndexedDB||t.webkitIndexedDB||t.msIndexedDB||t.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function pf(t){const e=t.result;e.createObjectStore(Ao,{keyPath:"modelPath"}),e.createObjectStore(Pr,{keyPath:"modelPath"})}class Do{constructor(e){if(this.indexedDB=D0(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,n){return new Promise((r,o)=>{const i=this.indexedDB.open(df,ff);i.onupgradeneeded=()=>pf(i),i.onsuccess=()=>{const a=i.result;if(n==null){const u=a.transaction(Ao,"readonly"),d=u.objectStore(Ao).get(this.modelPath);d.onsuccess=()=>{if(d.result==null)return a.close(),o(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));r(d.result.modelArtifacts)},d.onerror=f=>(a.close(),o(d.error)),u.oncomplete=()=>a.close()}else{n.weightData=ba.join(n.weightData);const u=O0(n),l=a.transaction(Pr,"readwrite");let d=l.objectStore(Pr),f;try{f=d.put({modelPath:this.modelPath,modelArtifactsInfo:u})}catch(h){return o(h)}let p;f.onsuccess=()=>{p=a.transaction(Ao,"readwrite");const h=p.objectStore(Ao);let g;try{g=h.put({modelPath:this.modelPath,modelArtifacts:n,modelArtifactsInfo:u})}catch(y){return o(y)}g.onsuccess=()=>r({modelArtifactsInfo:u}),g.onerror=y=>{d=l.objectStore(Pr);const x=d.delete(this.modelPath);x.onsuccess=()=>(a.close(),o(g.error)),x.onerror=v=>(a.close(),o(g.error))}},f.onerror=h=>(a.close(),o(f.error)),l.oncomplete=()=>{p==null?a.close():p.oncomplete=()=>a.close()}}},i.onerror=a=>o(i.error)})}}Do.URL_SCHEME="indexeddb://";const F0=t=>V().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(Do.URL_SCHEME)?p$(t.slice(Do.URL_SCHEME.length)):null;It.registerSaveRouter(F0);It.registerLoadRouter(F0);function p$(t){return new Do(t)}function h$(t){return t.startsWith(Do.URL_SCHEME)?t.slice(Do.URL_SCHEME.length):t}class m${constructor(){this.indexedDB=D0()}async listModels(){return new Promise((e,n)=>{const r=this.indexedDB.open(df,ff);r.onupgradeneeded=()=>pf(r),r.onsuccess=()=>{const o=r.result,i=o.transaction(Pr,"readonly"),u=i.objectStore(Pr).getAll();u.onsuccess=()=>{const l={};for(const d of u.result)l[d.modelPath]=d.modelArtifactsInfo;e(l)},u.onerror=l=>(o.close(),n(u.error)),i.oncomplete=()=>o.close()},r.onerror=o=>n(r.error)})}async removeModel(e){return e=h$(e),new Promise((n,r)=>{const o=this.indexedDB.open(df,ff);o.onupgradeneeded=()=>pf(o),o.onsuccess=()=>{const i=o.result,a=i.transaction(Pr,"readwrite"),u=a.objectStore(Pr),l=u.get(e);let d;l.onsuccess=()=>{if(l.result==null)return i.close(),r(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const f=u.delete(e),p=()=>{d=i.transaction(Ao,"readwrite");const g=d.objectStore(Ao).delete(e);g.onsuccess=()=>n(l.result.modelArtifactsInfo),g.onerror=y=>r(l.error)};f.onsuccess=p,f.onerror=h=>(p(),i.close(),r(l.error))}},l.onerror=f=>(i.close(),r(l.error)),a.oncomplete=()=>{d==null?i.close():d.oncomplete=()=>i.close()}},o.onerror=i=>r(o.error)})}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jn="/",Oi="tensorflowjs_models",L0="info",g$="model_topology",y$="weight_specs",x$="weight_data",v$="model_metadata";function M0(t){return{info:[Oi,t,L0].join(jn),topology:[Oi,t,g$].join(jn),weightSpecs:[Oi,t,y$].join(jn),weightData:[Oi,t,x$].join(jn),modelMetadata:[Oi,t,v$].join(jn)}}function B0(t){for(const e of Object.values(t))window.localStorage.removeItem(e)}function C$(t){const e=t.split(jn);if(e.length<3)throw new Error(`Invalid key format: ${t}`);return e.slice(1,e.length-1).join(jn)}function w$(t){return t.startsWith(Fo.URL_SCHEME)?t.slice(Fo.URL_SCHEME.length):t}class Fo{constructor(e){if(!V().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=M0(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const n=JSON.stringify(e.modelTopology),r=JSON.stringify(e.weightSpecs),o=O0(e),i=ba.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(o)),this.LS.setItem(this.keys.topology,n),this.LS.setItem(this.keys.weightSpecs,r),this.LS.setItem(this.keys.weightData,d$(i));const a={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(a)),{modelArtifactsInfo:o}}catch{throw B0(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${o.modelTopologyBytes}, weightSpecsBytes=${o.weightSpecsBytes}, weightDataBytes=${o.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const n={},r=JSON.parse(this.LS.getItem(this.keys.topology));if(r==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);n.modelTopology=r;const o=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(o==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);n.weightSpecs=o;const i=this.LS.getItem(this.keys.modelMetadata);if(i!=null){const u=JSON.parse(i);n.format=u.format,n.generatedBy=u.generatedBy,n.convertedBy=u.convertedBy,u.signature!=null&&(n.signature=u.signature),u.userDefinedMetadata!=null&&(n.userDefinedMetadata=u.userDefinedMetadata),u.modelInitializer!=null&&(n.modelInitializer=u.modelInitializer),u.initializerSignature!=null&&(n.initializerSignature=u.initializerSignature),u.trainingConfig!=null&&(n.trainingConfig=u.trainingConfig)}const a=this.LS.getItem(this.keys.weightData);if(a==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return n.weightData=f$(a),n}}Fo.URL_SCHEME="localstorage://";const U0=t=>V().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(Fo.URL_SCHEME)?S$(t.slice(Fo.URL_SCHEME.length)):null;It.registerSaveRouter(U0);It.registerLoadRouter(U0);function S$(t){return new Fo(t)}class b${constructor(){re(V().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),re(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},n=Oi+jn,r=jn+L0;for(let o=0;o<this.LS.length;++o){const i=this.LS.key(o);if(i.startsWith(n)&&i.endsWith(r)){const a=C$(i);e[a]=JSON.parse(this.LS.getItem(i))}}return e}async removeModel(e){e=w$(e);const n=M0(e);if(this.LS.getItem(n.info)==null)throw new Error(`Cannot find model at path '${e}'`);const r=JSON.parse(this.LS.getItem(n.info));return B0(n),r}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ry="://";class Tn{constructor(){this.managers={}}static getInstance(){return Tn.instance==null&&(Tn.instance=new Tn),Tn.instance}static registerManager(e,n){re(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(ry)&&(e=e.slice(0,e.indexOf(ry))),re(e.length>0,()=>"scheme must not be an empty string.");const r=Tn.getInstance();re(r.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),r.managers[e]=n}static getManager(e){const n=Tn.getInstance().managers[e];if(n==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return n}static getSchemes(){return Object.keys(Tn.getInstance().managers)}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class I${constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,n){return fetch(e,n)}now(){return performance.now()}encode(e,n){if(n!=="utf-8"&&n!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${n}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,n){return new TextDecoder(n).decode(e)}setTimeoutCustom(e,n){if(typeof window>"u"||!V().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,n);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},n),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",r=>{if(r.source===window&&r.data.name===this.messageName){r.stopPropagation();const o=this.functionRefs[r.data.index];o(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(e){return x0(e)}}if(V().get("IS_BROWSER")){V().setPlatform("browser",new I$);try{Tn.registerManager(Fo.URL_SCHEME,new b$)}catch{}try{Tn.registerManager(Do.URL_SCHEME,new m$)}catch{}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $$={importFetch:()=>require("node-fetch")};let Ad;class R${constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(e,n){return V().global.fetch!=null?V().global.fetch(e,n):(Ad==null&&(Ad=$$.importFetch()),Ad(e,n))}now(){const e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,n){if(n!=="utf-8"&&n!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${n}`);return this.textEncoder.encode(e)}decode(e,n){return e.length===0?"":new this.util.TextDecoder(n).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}V().get("IS_NODE")&&!V().get("IS_BROWSER")&&V().setPlatform("node",new R$);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xe(t,e="float32",n){return e=e||"float32",Sa(t),new ol(t,e,n)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E$(t,e){const n=Oe(t,"x","cast");if(!lI(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&n.dtype!=="string"||e!=="string"&&n.dtype==="string")throw new Error("Only strings can be casted to strings");const r={x:n},o={dtype:e};return xe.runKernel(yl,r,o)}const sl=qe({cast_:E$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _$(t){const n={x:Oe(t,"x","clone","string_or_numeric")};return xe.runKernel(xl,n)}const W0=qe({clone_:_$});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P$(t,e=!1){console.log(t.toString(e))}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */P0();const k$={buffer:Xe,cast:sl,clone:W0,print:P$};ZI(k$);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T$(t,e){let n=Oe(t,"a","add"),r=Oe(e,"b","add");[n,r]=Bo(n,r);const o={a:n,b:r};return xe.runKernel(gl,o)}const Le=qe({add_:T$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A$(t,e){let n=Oe(t,"a","floorDiv"),r=Oe(e,"b","floorDiv");[n,r]=Bo(n,r);const o={a:n,b:r};return xe.runKernel(Wf,o)}const N$=qe({floorDiv_:A$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O$(t,e){let n=Oe(t,"a","div"),r=Oe(e,"b","div");if([n,r]=Bo(n,r),n.dtype==="int32"&&r.dtype==="int32")return N$(n,r);const o={a:n,b:r},i={};return xe.runKernel(Mf,o,i)}const Nn=qe({div_:O$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D$(t,e){let n=Oe(t,"a","mul"),r=Oe(e,"b","mul");[n,r]=Bo(n,r);const o={a:n,b:r};return xe.runKernel(Gf,o)}const ke=qe({mul_:D$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F$(t){const e=Oe(t,"x","abs");if(e.dtype==="complex64"){const n={x:e};return xe.runKernel(Lf,n)}else{const n={x:e};return xe.runKernel(Df,n)}}const L$=qe({abs_:F$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ia(t,e,n,r,o="NHWC",i){const a=t[3],u=[...e,a],l=Cn(o);return it(t,u,n,i,r,null,null,l)}function vn(t,e,n,r,o,i,a="channelsLast"){const[u,l]=fa(e);let d;if(a==="channelsLast")d=[u,l,t[3],t[3]];else if(a==="channelsFirst")d=[u,l,t[1],t[1]];else throw new Error(`Unknown dataFormat ${a}`);return it(t,d,n,r,o,i,!1,a)}function Zn(t,e,n,r,o,i,a="NDHWC"){const[u,l,d]=hf(e);let f,p;if(a==="NDHWC")p="channelsLast",f=[u,l,d,t[4],t[4]];else if(a==="NCDHW")p="channelsFirst",f=[u,l,d,t[1],t[1]];else throw new Error(`Unknown dataFormat ${a}`);return Dr(t,f,n,r,o,!1,p,i)}function it(t,e,n,r,o,i,a=!1,u="channelsLast"){let[l,d,f,p]=[-1,-1,-1,-1];if(u==="channelsLast")[l,d,f,p]=t;else if(u==="channelsFirst")[l,p,d,f]=t;else throw new Error(`Unknown dataFormat ${u}`);const[h,g,,y]=e,[x,v]=fa(n),[w,S]=fa(r),I=Fi(h,w),E=Fi(g,S),{padInfo:R,outHeight:T,outWidth:k}=U$(o,d,f,x,v,I,E,i,u),D=a?y*p:y;let N;return u==="channelsFirst"?N=[l,D,T,k]:u==="channelsLast"&&(N=[l,T,k,D]),{batchSize:l,dataFormat:u,inHeight:d,inWidth:f,inChannels:p,outHeight:T,outWidth:k,outChannels:D,padInfo:R,strideHeight:x,strideWidth:v,filterHeight:h,filterWidth:g,effectiveFilterHeight:I,effectiveFilterWidth:E,dilationHeight:w,dilationWidth:S,inShape:t,outShape:N,filterShape:e}}function Dr(t,e,n,r,o,i=!1,a="channelsLast",u){let[l,d,f,p,h]=[-1,-1,-1,-1,-1];if(a==="channelsLast")[l,d,f,p,h]=t;else if(a==="channelsFirst")[l,h,d,f,p]=t;else throw new Error(`Unknown dataFormat ${a}`);const[g,y,x,,v]=e,[w,S,I]=hf(n),[E,R,T]=hf(r),k=Fi(g,E),D=Fi(y,R),N=Fi(x,T),{padInfo:O,outDepth:_,outHeight:F,outWidth:U}=W$(o,d,f,p,w,S,I,k,D,N,u),G=i?v*h:v;let j;return a==="channelsFirst"?j=[l,G,_,F,U]:a==="channelsLast"&&(j=[l,_,F,U,G]),{batchSize:l,dataFormat:a,inDepth:d,inHeight:f,inWidth:p,inChannels:h,outDepth:_,outHeight:F,outWidth:U,outChannels:G,padInfo:O,strideDepth:w,strideHeight:S,strideWidth:I,filterDepth:g,filterHeight:y,filterWidth:x,effectiveFilterDepth:k,effectiveFilterHeight:D,effectiveFilterWidth:N,dilationDepth:E,dilationHeight:R,dilationWidth:T,inShape:t,outShape:j,filterShape:e}}function M$(t,e,n,r,o){r==null&&(r=op(t,e,n));const i=t[0],a=t[1],u=pa((i-e+2*r)/n+1,o),l=pa((a-e+2*r)/n+1,o);return[u,l]}function B$(t,e,n,r,o,i){o==null&&(o=op(t,e[0],r[0]));const a=[0,0,0,n];for(let u=0;u<3;u++)t[u]+2*o>=e[u]&&(a[u]=pa((t[u]-e[u]+2*o)/r[u]+1,i));return a}function op(t,e,n,r=1){const o=Fi(e,r);return Math.floor((t[0]*(n-1)-n+o)/2)}function fa(t){return typeof t=="number"?[t,t,t]:t.length===2?[t[0],t[1],1]:t}function hf(t){return typeof t=="number"?[t,t,t]:t}function Fi(t,e){return e<=1?t:t+(t-1)*(e-1)}function U$(t,e,n,r,o,i,a,u,l){let d,f,p;if(typeof t=="number"){d={top:t,bottom:t,left:t,right:t,type:t===0?"VALID":"NUMBER"};const g=M$([e,n],i,r,t,u);f=g[0],p=g[1]}else if(t==="same"){f=Math.ceil(e/r),p=Math.ceil(n/o);const h=Math.max(0,(f-1)*r+i-e),g=Math.max(0,(p-1)*o+a-n),y=Math.floor(h/2),x=h-y,v=Math.floor(g/2),w=g-v;d={top:y,bottom:x,left:v,right:w,type:"SAME"}}else if(t==="valid")d={top:0,bottom:0,left:0,right:0,type:"VALID"},f=Math.ceil((e-i+1)/r),p=Math.ceil((n-a+1)/o);else if(typeof t=="object"){const h=l==="channelsLast"?t[1][0]:t[2][0],g=l==="channelsLast"?t[1][1]:t[2][1],y=l==="channelsLast"?t[2][0]:t[3][0],x=l==="channelsLast"?t[2][1]:t[3][1];d={top:h,bottom:g,left:y,right:x,type:h===0&&g===0&&y===0&&x===0?"VALID":"EXPLICIT"},f=pa((e-i+h+g)/r+1,u),p=pa((n-a+y+x)/o+1,u)}else throw Error(`Unknown padding parameter: ${t}`);return{padInfo:d,outHeight:f,outWidth:p}}function W$(t,e,n,r,o,i,a,u,l,d,f){let p,h,g,y;if(t==="valid"&&(t=0),typeof t=="number"){p={top:t,bottom:t,left:t,right:t,front:t,back:t,type:t===0?"VALID":"NUMBER"};const v=B$([e,n,r,1],[u,l,d],1,[o,i,a],t,f);h=v[0],g=v[1],y=v[2]}else if(t==="same"){h=Math.ceil(e/o),g=Math.ceil(n/i),y=Math.ceil(r/a);const x=(h-1)*o+u-e,v=(g-1)*i+l-n,w=(y-1)*a+d-r,S=Math.floor(x/2),I=x-S,E=Math.floor(v/2),R=v-E,T=Math.floor(w/2),k=w-T;p={top:E,bottom:R,left:T,right:k,front:S,back:I,type:"SAME"}}else throw Error(`Unknown padding parameter: ${t}`);return{padInfo:p,outDepth:h,outHeight:g,outWidth:y}}function pa(t,e){if(!e)return Math.trunc(t);switch(e){case"round":return Math.round(t);case"ceil":return Math.ceil(t);case"floor":return Math.floor(t);default:throw new Error(`Unknown roundingMode ${e}`)}}function mf(t){const[e,n,r]=fa(t);return e===1&&n===1&&r===1}function Fr(t,e){return mf(t)||mf(e)}function V$(t){return fa(t).every(e=>e>0)}function Cn(t){if(t==="NHWC")return"channelsLast";if(t==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${t}`)}function z$(t,e,n){if(n!=null){if(typeof e=="string")throw Error(`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${e}.`);if(typeof e=="number")re(tl(e),()=>`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${e}.`);else if(typeof e=="object")e.forEach(r=>{r.forEach(o=>{re(tl(o),()=>`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${o}.`)})});else throw Error(`Error in ${t}: Unknown padding parameter: ${e}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G$(t,e){const r={x:Oe(t,"x","reshape","string_or_numeric")},o={shape:e};return xe.runKernel(qf,r,o)}const ip=qe({reshape_:G$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H$(t){const n={x:Oe(t,"x","sigmoid","float32")};return xe.runKernel(Yf,n)}const j$=qe({sigmoid_:H$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X$(t,e){let n=Oe(t,"broadcastTo","x");const r=n.shape;if(Sa(e),e.length<n.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${n.rank}.`);if(e.length>n.rank){const d=n.shape.slice();for(;d.length<e.length;)d.unshift(1);n=ip(n,d)}const o=n.shape,i=Array.from(e);for(let d=e.length-1;d>=0;d--)if(o[d]===e[d])i[d]=1;else if(n.shape[d]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${e}].`);if(i.map((d,f)=>d>1?f:-1).filter(d=>d>=0).length===0)return W0(n);const u={x:n},l={reps:i};return xe.runKernel(ep,u,l)}const q$=qe({broadcastTo_:X$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K$(t,e,n){Sa(t),n=n||Gi(e);const r={shape:t,value:e,dtype:n};return xe.runKernel(Uf,{},r)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bi(t,e){const n=t.length,r=[];for(let o=0;o<n;o++){const i=n-1-o,a=t[i]||1;(e[e.length-1-o]||1)>1&&a===1&&r.unshift(i)}return r}function V0(t,e){const n=[];for(let r=0;r<e.length;r++){const o=t[t.length-r-1],i=e.length-r-1,a=e[i];(o==null||o===1&&a>1)&&n.unshift(i)}return n}function He(t,e){const n=Math.max(t.length,e.length),r=new Array(n);for(let o=0;o<n;o++){let i=t[t.length-o-1];i==null&&(i=1);let a=e[e.length-o-1];if(a==null&&(a=1),i===1)r[n-o-1]=a;else if(a===1)r[n-o-1]=i;else if(i!==a){const u=`Operands could not be broadcast together with shapes ${t} and ${e}.`;throw Error(u)}else r[n-o-1]=i}return r}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y$(t){const n={x:Oe(t,"x","zerosLike")};return xe.runKernel(tp,n)}const On=qe({zerosLike_:Y$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q$(t){const n={x:Oe(t,"x","elu","float32")};return xe.runKernel(Bf,n)}const Z$=qe({elu_:Q$});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sp(t,e){for(let n=0;n<t.length;++n)if(t[t.length-n-1]!==e-1-n)return!1;return!0}function z0(t,e,n){const r=t.length+e.length,o=[];let i=0,a=0;for(let u=0;u<r;u++)n.indexOf(u)===-1?o.push(t[i++]):o.push(e[a++]);return o}function Ht(t,e){const n=[],r=t.length;for(let i=0;i<r;i++)e.indexOf(i)===-1&&n.push(t[i]);const o=e.map(i=>t[i]);return[n,o]}function Fn(t,e){const n=e.map(r=>1);return z0(t,n,e)}function Ft(t,e,n){re(sp(e,n),()=>`${t} supports only inner-most axes for now. Got axes ${e} and rank-${n} input.`)}function dt(t,e){if(sp(t,e))return null;const n=[];for(let r=0;r<e;++r)t.indexOf(r)===-1&&n.push(r);return t.forEach(r=>n.push(r)),n}function $a(t){return t.map((e,n)=>[n,e]).sort((e,n)=>e[1]-n[1]).map(e=>e[0])}function ft(t,e){const n=[];for(let r=e-t;r<e;++r)n.push(r);return n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J$(t,e){let n=Oe(t,"base","pow"),r=Oe(e,"exp","pow");[n,r]=Bo(n,r);const o={a:n,b:r};return xe.runKernel(Hf,o)}const oy=qe({pow_:J$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nr(t,e){if((en(t)&&e!=="string"||Array.isArray(t))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&en(t)&&!(t instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return u$(t,[],[],e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eR(t){const n={x:Oe(t,"x","sqrt","float32")};return xe.runKernel(Qf,n)}const Ui=qe({sqrt_:eR});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tR(t){const e=Oe(t,"x","square"),n={};return xe.runKernel("Square",{x:e},n)}const No=qe({square_:tR});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nR(t,e=null,n=!1){let r=Oe(t,"x","sum");r.dtype==="bool"&&(r=sl(r,"int32"));const o={x:r},i={axis:e,keepDims:n};return xe.runKernel(Zf,o,i)}const rR=qe({sum_:nR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oR(t,e=.2){const r={x:Oe(t,"x","leakyRelu")},o={alpha:e};return xe.runKernel(Vf,r,o)}const iR=qe({leakyRelu_:oR});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sR(t,e){re(nf(t),()=>"The f passed in variableGrads(f) must be a function"),re(e==null||Array.isArray(e)&&e.every(d=>d instanceof il),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const n=e!=null;if(!n){e=[];for(const d in xe.registeredVariables)e.push(xe.registeredVariables[d])}const r=n?e.filter(d=>!d.trainable):null,o=e.length;e=e.filter(d=>d.trainable),re(e.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${o} variables is trainable.`);const i=!0,{value:a,grads:u}=xe.gradients(t,e,null,i);re(u.some(d=>d!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),re(a.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${a.rank} tensor`);const l={};return e.forEach((d,f)=>{u[f]!=null&&(l[d.name]=u[f])}),r?.forEach(d=>l[d.name]=null),{value:a,grads:l}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aR(t,e){let n=Oe(t,"a","sub"),r=Oe(e,"b","sub");[n,r]=Bo(n,r);const o={a:n,b:r};return xe.runKernel(Jf,o)}const Li=qe({sub_:aR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uR(t,e){let n=Oe(t,"a","maximum"),r=Oe(e,"b","maximum");[n,r]=Bo(n,r),n.dtype==="bool"&&(n=sl(n,"int32"),r=sl(r,"int32")),He(n.shape,r.shape);const o={a:n,b:r};return xe.runKernel(zf,o)}const lR=qe({maximum_:uR});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function al(t,e="float32"){if(Sa(t),e==="complex64"){const r=al(t,"float32"),o=al(t,"float32");return a$(r,o)}const n=Kn(Y(t),e);return xe.makeTensor(n,t,e)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cR(t,e){const n=Oe(t,"x","prelu"),r=Oe(e,"alpha","prelu"),o={x:n,alpha:r};return xe.runKernel(jf,o)}const dR=qe({prelu_:cR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fR(t){const n={x:Oe(t,"x","relu")};return xe.runKernel(Xf,n)}const pR=qe({relu_:fR});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hR(t){const n={x:Oe(t,"x","relu6")};return xe.runKernel(Kf,n)}const mR=qe({relu6_:hR});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gR(t,e=0){const r={x:Oe(t,"x","step")},o={alpha:e};return xe.runKernel(np,r,o)}const yR=qe({step_:gR});function G0(t,e,n){const r=e.rank>1?e.shape[e.rank-1]:1,o=e.rank>1?e.rank-1:1,i=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${e.shape}, shape: ${t}, sliceDim: ${r}, and batchDim: ${o}.`;if(n.rank<o)throw new Error(i+` update.rank < ${o}. `);if(t.length<r+(n.rank-o))throw new Error(i+` Output shape length < ${r+(n.rank-o)}`);if(n.rank!==o+t.length-r)throw new Error(i+` update.rank != ${o+t.length-r}`);for(let a=0;a<o;++a)if(n.shape[a]!==e.shape[a])throw new Error(i+` updates.shape[${a}] (${n.shape[a]}) != indices.shape[${a}] (${e.shape[a]}).`);for(let a=0;a<n.rank-o;++a)if(n.shape[a+o]!==t[a+r])throw new Error(i+` updates.shape[${a+o}] (${n.shape[a+o]}) != shape[${a+o}] (${t[a+o]})`)}function xR(t,e,n){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(n.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(t.size===0)throw new Error(`Updates specified for empty output. updates shape: ${t.shape}`)}G0(n,e,t)}function Uo(t,e,n){const r=e.shape.length,o=r>1?e.shape[r-1]:1,i=n.length;let a=1;for(let p=o;p<i;++p)a*=n[p];const u=o<1?1:o,l=Y(e.shape)/u,d=[...Ke(n.slice(0,o)),1],f=Y(n);return{sliceRank:o,numUpdates:l,sliceSize:a,strides:d,outputSize:f}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vR(t,e){const n=[];for(let i=0;i<e.length;i++)e[i]&&n.push(i);const r=Xe(t,"int32"),o=Xe([n.length,t.length],"int32");for(let i=0;i<n.length;i++){const a=r.indexToLoc(n[i]),u=i*t.length;o.values.set(a,u)}return o.toTensor()}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CR(t,e,n){if(n==null||n==="linear")return t;if(n==="relu")return ke(t,yR(e));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function wR(t,e){let n=e;const r=V0(t.shape,e.shape);return r.length>0&&(n=rR(n,r)),ip(n,t.shape)}function SR(t,e,n,r){if(e==="linear")return t;if(e==="relu")return pR(t);if(e==="elu")return Z$(t);if(e==="relu6")return mR(t);if(e==="prelu")return dR(t,n);if(e==="leakyrelu")return iR(t,r);if(e==="sigmoid")return j$(t);throw new Error(`Unknown fused activation ${e}.`)}const bR=(t,e)=>!(t>0)||e==="linear";/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IR(t,e,n){const r=$R(t,e,n),o=r<0?-(r+1):r;t.splice(o,0,e)}function $R(t,e,n){return ER(t,e,n||RR)}function RR(t,e){return t>e?1:t<e?-1:0}function ER(t,e,n){let r=0,o=t.length,i=0,a=!1;for(;r<o;){i=r+(o-r>>>1);const u=n(e,t[i]);u>0?r=i+1:(o=i,a=!u)}return a?r:-r-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H0(t,e,n,r,o){return ap(t,e,n,r,o,0)}function _R(t,e,n,r,o,i){return ap(t,e,n,r,o,0,!1,i,!0)}function j0(t,e,n,r,o,i){return ap(t,e,n,r,o,i,!0)}function ap(t,e,n,r,o,i,a=!1,u=!1,l=!1){const d=[];for(let v=0;v<e.length;v++)e[v]>o&&d.push({score:e[v],boxIndex:v,suppressBeginIndex:0});d.sort(iy);const f=i>0?-.5/i:0,p=[],h=[];for(;p.length<n&&d.length>0;){const v=d.pop(),{score:w,boxIndex:S,suppressBeginIndex:I}=v;if(w<o)break;let E=!1;for(let R=p.length-1;R>=I;--R){const T=PR(t,S,p[R]);if(T>=r){E=!0;break}if(v.score=v.score*kR(r,f,T),v.score<=o)break}v.suppressBeginIndex=p.length,E||(v.score===w?(p.push(S),h.push(v.score)):v.score>o&&IR(d,v,iy))}const g=p.length,y=n-g;u&&y>0&&(p.push(...new Array(y).fill(0)),h.push(...new Array(y).fill(0)));const x={selectedIndices:p};return a&&(x.selectedScores=h),l&&(x.validOutputs=g),x}function PR(t,e,n){const r=t.subarray(e*4,e*4+4),o=t.subarray(n*4,n*4+4),i=Math.min(r[0],r[2]),a=Math.min(r[1],r[3]),u=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),d=Math.min(o[0],o[2]),f=Math.min(o[1],o[3]),p=Math.max(o[0],o[2]),h=Math.max(o[1],o[3]),g=(u-i)*(l-a),y=(p-d)*(h-f);if(g<=0||y<=0)return 0;const x=Math.max(i,d),v=Math.max(a,f),w=Math.min(u,p),S=Math.min(l,h),I=Math.max(w-x,0)*Math.max(S-v,0);return I/(g+y-I)}function kR(t,e,n){const r=Math.exp(e*n*n);return n<=t?r:0}function iy(t,e){return t.score-e.score||t.score===e.score&&e.boxIndex-t.boxIndex}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TR=new Map,AR=new Map;class NR{getClassName(){return this.constructor.className}static fromConfig(e,n){return new e(n)}}class Po{constructor(){this.classNameMap={}}static getMap(){return Po.instance==null&&(Po.instance=new Po),Po.instance}static register(e){Po.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function OR(t,e,n){re(t.className!=null,()=>"Class being registered does not have the static className property defined."),re(typeof t.className=="string",()=>"className is required to be a string, but got type "+typeof t.className),re(t.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof e>"u"&&(e="Custom"),typeof n>"u"&&(n=t.className);const r=n,o=e+">"+r;return Po.register(t),TR.set(o,t),AR.set(t,o),t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Wo extends NR{minimize(e,n=!1,r){const{value:o,grads:i}=this.computeGradients(e,r);if(r!=null){const a=r.map(u=>({name:u.name,tensor:i[u.name]}));this.applyGradients(a)}else this.applyGradients(i);return Gt(i),n?o:(o.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,n){return sR(e,n)}dispose(){this.iterations_!=null&&Gt(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:Nr(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(Wo,Symbol.hasInstance,{value:t=>t.minimize!=null&&t.computeGradients!=null&&t.applyGradients!=null});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class DR extends Wo{static get className(){return"Adadelta"}constructor(e,n,r=null){super(),this.learningRate=e,this.rho=n,this.epsilon=r,this.accumulatedGrads=[],this.accumulatedUpdates=[],r==null&&(this.epsilon=xe.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,o)=>{const i=xe.registeredVariables[r],a=!1;this.accumulatedGrads[o]==null&&(this.accumulatedGrads[o]={originalName:`${r}/accum_grad`,variable:tt(()=>On(i).variable(a))}),this.accumulatedUpdates[o]==null&&(this.accumulatedUpdates[o]={originalName:`${r}/accum_var`,variable:tt(()=>On(i).variable(a))});const u=Array.isArray(e)?e[o].tensor:e[r];if(u==null)return;const l=this.accumulatedGrads[o].variable,d=this.accumulatedUpdates[o].variable;tt(()=>{const f=Le(ke(l,this.rho),ke(No(u),1-this.rho)),p=ke(Nn(Ui(Le(d,this.epsilon)),Ui(Le(l,this.epsilon))),u),h=Le(ke(d,this.rho),ke(No(p),1-this.rho));l.assign(f),d.assign(h);const g=Le(ke(p,-this.learningRate),i);i.assign(g)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(Gt(this.accumulatedGrads.map(e=>e.variable)),Gt(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(e){e=await this.extractIterations(e);const n=e.length/2,r=!1;this.accumulatedGrads=e.slice(0,n).map(o=>({originalName:o.name,variable:o.tensor.variable(r)})),this.accumulatedUpdates=e.slice(n,n*2).map(o=>({originalName:o.name,variable:o.tensor.variable(r)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,n){return new e(n.learningRate,n.rho,n.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class FR extends Wo{static get className(){return"Adagrad"}constructor(e,n=.1){super(),this.learningRate=e,this.initialAccumulatorValue=n,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,o)=>{const i=xe.registeredVariables[r];this.accumulatedGrads[o]==null&&(this.accumulatedGrads[o]={originalName:`${r}/accumulator`,variable:tt(()=>K$(i.shape,this.initialAccumulatorValue).variable(!1))});const a=Array.isArray(e)?e[o].tensor:e[r];if(a==null)return;const u=this.accumulatedGrads[o].variable;tt(()=>{const l=Le(u,No(a));u.assign(l);const d=Le(ke(Nn(a,Ui(Le(l,xe.backend.epsilon()))),-this.learningRate),i);i.assign(d)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&Gt(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const n=!1;this.accumulatedGrads=e.map(r=>({originalName:r.name,variable:r.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,n){return new e(n.learningRate,n.initialAccumulatorValue)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class LR extends Wo{static get className(){return"Adam"}constructor(e,n,r,o=null){super(),this.learningRate=e,this.beta1=n,this.beta2=r,this.epsilon=o,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],tt(()=>{this.accBeta1=Nr(n).variable(),this.accBeta2=Nr(r).variable()}),o==null&&(this.epsilon=xe.backend.epsilon())}applyGradients(e){const n=Array.isArray(e)?e.map(r=>r.name):Object.keys(e);tt(()=>{const r=Li(1,this.accBeta1),o=Li(1,this.accBeta2);n.forEach((i,a)=>{const u=xe.registeredVariables[i],l=!1;this.accumulatedFirstMoment[a]==null&&(this.accumulatedFirstMoment[a]={originalName:`${i}/m`,variable:tt(()=>On(u).variable(l))}),this.accumulatedSecondMoment[a]==null&&(this.accumulatedSecondMoment[a]={originalName:`${i}/v`,variable:tt(()=>On(u).variable(l))});const d=Array.isArray(e)?e[a].tensor:e[i];if(d==null)return;const f=this.accumulatedFirstMoment[a].variable,p=this.accumulatedSecondMoment[a].variable,h=Le(ke(f,this.beta1),ke(d,1-this.beta1)),g=Le(ke(p,this.beta2),ke(No(d),1-this.beta2)),y=Nn(h,r),x=Nn(g,o);f.assign(h),p.assign(g);const v=Le(ke(Nn(y,Le(Ui(x),this.epsilon)),-this.learningRate),u);u.assign(v)}),this.accBeta1.assign(ke(this.accBeta1,this.beta1)),this.accBeta2.assign(ke(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&Gt(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&Gt(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(e){e=await this.extractIterations(e),tt(()=>{this.accBeta1.assign(oy(this.beta1,this.iterations_+1)),this.accBeta2.assign(oy(this.beta2,this.iterations_+1))});const n=e.length/2,r=!1;this.accumulatedFirstMoment=e.slice(0,n).map(o=>({originalName:o.name,variable:o.tensor.variable(r)})),this.accumulatedSecondMoment=e.slice(n,n*2).map(o=>({originalName:o.name,variable:o.tensor.variable(r)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,n){return new e(n.learningRate,n.beta1,n.beta2,n.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class MR extends Wo{static get className(){return"Adamax"}constructor(e,n,r,o=null,i=0){super(),this.learningRate=e,this.beta1=n,this.beta2=r,this.epsilon=o,this.decay=i,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],tt(()=>{this.iteration=Nr(0).variable(),this.accBeta1=Nr(n).variable()}),o==null&&(this.epsilon=xe.backend.epsilon())}applyGradients(e){const n=Array.isArray(e)?e.map(r=>r.name):Object.keys(e);tt(()=>{const r=Li(1,this.accBeta1),o=Nn(-this.learningRate,Le(ke(this.iteration,this.decay),1));n.forEach((i,a)=>{const u=xe.registeredVariables[i],l=!1;this.accumulatedFirstMoment[a]==null&&(this.accumulatedFirstMoment[a]={originalName:`${i}/m`,variable:On(u).variable(l)}),this.accumulatedWeightedInfNorm[a]==null&&(this.accumulatedWeightedInfNorm[a]={originalName:`${i}/v`,variable:On(u).variable(l)});const d=Array.isArray(e)?e[a].tensor:e[i];if(d==null)return;const f=this.accumulatedFirstMoment[a].variable,p=this.accumulatedWeightedInfNorm[a].variable,h=Le(ke(f,this.beta1),ke(d,1-this.beta1)),g=ke(p,this.beta2),y=L$(d),x=lR(g,y);f.assign(h),p.assign(x);const v=Le(ke(Nn(o,r),Nn(h,Le(x,this.epsilon))),u);u.assign(v)}),this.iteration.assign(Le(this.iteration,1)),this.accBeta1.assign(ke(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&Gt(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&Gt(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,n){return new e(n.learningRate,n.beta1,n.beta2,n.epsilon,n.decay)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class X0 extends Wo{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,o)=>{const i=Array.isArray(e)?e[o].tensor:e[r];if(i==null)return;const a=xe.registeredVariables[r];tt(()=>{const u=Le(ke(this.c,i),a);a.assign(u)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=c$(Nr(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,n){return new e(n.learningRate)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class BR extends X0{static get className(){return"Momentum"}constructor(e,n,r=!1){super(e),this.learningRate=e,this.momentum=n,this.useNesterov=r,this.accumulations=[],this.m=Nr(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,o)=>{const i=xe.registeredVariables[r];this.accumulations[o]==null&&(this.accumulations[o]={originalName:`${r}/momentum`,variable:tt(()=>On(i).variable(!1))});const a=this.accumulations[o].variable,u=Array.isArray(e)?e[o].tensor:e[r];u!=null&&tt(()=>{let l;const d=Le(ke(this.m,a),u);this.useNesterov?l=Le(ke(this.c,Le(u,ke(d,this.m))),i):l=Le(ke(this.c,d),i),a.assign(d),i.assign(l)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&Gt(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const n=!1;this.accumulations=e.map(r=>({originalName:r.name,variable:r.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,n){return new e(n.learningRate,n.momentum,n.useNesterov)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class UR extends Wo{static get className(){return"RMSProp"}constructor(e,n=.9,r=0,o=null,i=!1){if(super(),this.learningRate=e,this.decay=n,this.momentum=r,this.epsilon=o,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=i,o==null&&(this.epsilon=xe.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,o)=>{const i=xe.registeredVariables[r],a=!1;this.accumulatedMeanSquares[o]==null&&(this.accumulatedMeanSquares[o]={originalName:`${r}/rms`,variable:tt(()=>On(i).variable(a))}),this.accumulatedMoments[o]==null&&(this.accumulatedMoments[o]={originalName:`${r}/momentum`,variable:tt(()=>On(i).variable(a))}),this.accumulatedMeanGrads[o]==null&&this.centered&&(this.accumulatedMeanGrads[o]={originalName:`${r}/mg`,variable:tt(()=>On(i).variable(a))});const u=Array.isArray(e)?e[o].tensor:e[r];if(u==null)return;const l=this.accumulatedMeanSquares[o].variable,d=this.accumulatedMoments[o].variable;tt(()=>{const f=Le(ke(l,this.decay),ke(No(u),1-this.decay));if(this.centered){const p=this.accumulatedMeanGrads[o].variable,h=Le(ke(p,this.decay),ke(u,1-this.decay)),g=Nn(ke(u,this.learningRate),Ui(Li(f,Le(No(h),this.epsilon)))),y=Le(ke(d,this.momentum),g);l.assign(f),p.assign(h),d.assign(y);const x=Li(i,y);i.assign(x)}else{const p=Le(ke(l,this.decay),ke(No(u),1-this.decay)),h=Le(ke(d,this.momentum),Nn(ke(u,this.learningRate),Ui(Le(p,this.epsilon))));l.assign(p),d.assign(h);const g=Li(i,h);i.assign(g)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&Gt(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&Gt(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&Gt(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(e){e=await this.extractIterations(e);const n=this.centered?e.length/3:e.length/2,r=!1;this.accumulatedMeanSquares=e.slice(0,n).map(o=>({originalName:o.name,variable:o.tensor.variable(r)})),this.accumulatedMoments=e.slice(n,n*2).map(o=>({originalName:o.name,variable:o.tensor.variable(r)})),this.centered&&(this.accumulatedMeanGrads=e.slice(n*2,n*3).map(o=>({originalName:o.name,variable:o.tensor.variable(r)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,n){return new e(n.learningRate,n.decay,n.momentum,n.epsilon,n.centered)}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WR=[DR,FR,LR,MR,BR,UR,X0];function VR(){for(const t of WR)OR(t)}function up(t,e){const n=t.shape.length,r=e.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[r-1]} vs. ${n}`);if(Y(t.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${t.shape}.`);const o=e.shape,i=o[o.length-1];let a=1;for(let p=0;p<o.length-1;++p)a*=o[p];const u=t.shape,l=o.slice();l.pop();let d=1;for(let p=i;p<n;++p)d*=u[p],l.push(u[p]);const f=[...Ke(t.shape).map(p=>p/d),1].slice(0,i);return[l,a,d,f]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gf=-2,zR=-1;function lp(t,e,n){const r=t.shape.length;re(r===e.length,()=>`Error in slice${r}D: Length of begin ${e} must match the rank of the array (${r}).`),re(r===n.length,()=>`Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`);for(let o=0;o<r;++o)re(e[o]+n[o]<=t.shape[o],()=>`Error in slice${r}D: begin[${o}] + size[${o}] (${e[o]+n[o]}) would overflow input.shape[${o}] (${t.shape[o]})`)}function GR(t){const e=[];let n=0;for(;t>0;)t&1&&e.push(n),t/=2,n++;return e}function cp(t,e,n){const r=[];for(let o=0;o<t.length;o++)r[o]=Math.ceil((e[o]-t[o])/n[o]);return r}function q0(t,e,n,r){const o=[...t];for(let i=o.length;i<r.length;i++)o.push(1);for(let i=0;i<n;i++)i===0?o[e]=1:(o.splice(e,0,1),o.pop());return o}function K0(t,e,n){return n<=t?n:n-(e-1)}function Y0(t,e){const n=[];for(let r=0;r<t;r++)n.push(e+r);return n}function HR(t,e,n,r,o,i,a,u,l){const d=t.length;let f=new Array(d),p=new Array(d),h=new Array(d);if(e.length&&n>0){const g=e[0],y=n+1;f=Q0(a,g,y,r,t),p=Z0(u,g,y,o,t),h=q0(i,g,y,t)}else for(let g=0;g<d;g++)f[g]=ew(a,r,i,t,g,l),p[g]=tw(u,o,i,t,g,l),h[g]=J0(i,g,l);return{begin:f,end:p,strides:h}}function Q0(t,e,n,r,o){const i=[...o],a=Y0(n,e);for(let u=0;u<i.length;u++)if(a.indexOf(u)>-1)i[u]=0;else{const l=K0(e,n,u);let d=r[l];t&1<<l&&(d=0),i[u]=d}return i}function Z0(t,e,n,r,o){const i=[...o],a=Y0(n,e);for(let u=0;u<i.length;u++)if(a.indexOf(u)>-1)i[u]=Number.MAX_SAFE_INTEGER;else{const l=K0(e,n,u);let d=r[l];t&1<<l&&(d=Number.MAX_SAFE_INTEGER),i[u]=d}for(let u=0;u<i.length;u++){const l=o[u];i[u]<0&&(i[u]+=l),i[u]=el(0,i[u],o[u])}return i}function J0(t,e,n){let r=t[e];return(n&1<<e||r==null)&&(r=1),r}function ew(t,e,n,r,o,i){let a=e[o];const u=n[o]||1;(t&1<<o||i&1<<o||a==null)&&(u>0?a=Number.MIN_SAFE_INTEGER:a=Number.MAX_SAFE_INTEGER);const l=r[o];return a<0&&(a+=l),a=el(0,a,l-1),a}function tw(t,e,n,r,o,i){let a=e[o];const u=n[o]||1;(t&1<<o||i&1<<o||a==null)&&(u>0?a=Number.MAX_SAFE_INTEGER:a=Number.MIN_SAFE_INTEGER);const l=r[o];return a<0&&(a+=l),u>0?a=el(0,a,l):a=el(-1,a,l-1),a}function dp(t,e,n){let r=n.length;for(let o=0;o<n.length;o++)if(n[o]>1){r=o;break}for(let o=r+1;o<n.length;o++)if(e[o]>0||n[o]!==t[o])return!1;return!0}function fp(t,e){let n=t.length>0?t[t.length-1]:1;for(let r=0;r<t.length-1;r++)n+=t[r]*e[r];return n}function pp(t,e,n){let r;const o=t.shape.length;typeof e=="number"?r=[e,...new Array(o-1).fill(0)]:e.length<o?r=e.concat(new Array(o-e.length).fill(0)):r=e.slice(),r.forEach(a=>{re(a!==-1,()=>"slice() does not support negative begin indexing.")});let i;return n==null?i=new Array(o).fill(-1):typeof n=="number"?i=[n,...new Array(o-1).fill(-1)]:n.length<o?i=n.concat(new Array(o-n.length).fill(-1)):i=n,i=i.map((a,u)=>a>=0?a:(re(a===-1,()=>`Negative size values should be exactly -1 but got ${a} for the slice() size at index ${u}.`),t.shape[u]-r[u])),[r,i]}function hp(t,e,n,r,o,i,a,u,l){let d;if(r==null?(d=new Array(e.length),d.fill(1)):d=r,a!=null&&(a&a-1)!==0)throw new Error("Multiple ellipses in slice is not allowed.");let f=!1;const p={dims:d.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:n.slice(),strides:d.slice(),beginMask:o,endMask:i,ellipsisMask:a,newAxisMask:u,shrinkAxisMask:l};for(let I=0;I<p.dims;I++)f&&(1<<I&u)!==0&&p.numAddAxisAfterEllipsis++,1<<I&a&&(f=!0);f||(p.ellipsisMask|=1<<p.dims,p.dims++);const h={dims:t.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};jR(p,h);let g=!0,y=!0,x=!0;const v=[],w=[];for(let I=0;I<t.length;++I){if(h.strides[I]===0)throw Error(`strides[${I}] must be non-zero`);const E=!!(h.shrinkAxisMask&1<<I),R=t[I];if(R===-1){v.push(E?1:-1);continue}const T=[h.beginMask&1<<I,h.endMask&1<<I],k=[h.strides[I]>0?0:-1,h.strides[I]>0?R:R-1];if(E&&h.strides[I]<=0)throw Error("only stride 1 allowed on non-range indexing.");x=x&&h.strides[I]===1;const D=!!(h.beginMask&1<<I&&h.endMask&1<<I);if(h.beginValid&&h.endValid){if(E){const F=h.begin[I]<0?R+h.begin[I]:h.begin[I];if(h.begin[I]=F,h.end[I]=h.begin[I]+1,F<0||F>=R)throw Error(`slice index ${h.begin[I]} of dimension ${I} out of bounds.`)}else h.begin[I]=sy(h.begin[I],0,h.strides[I],R,T,k),h.end[I]=sy(h.end[I],1,h.strides[I],R,T,k);const _=h.strides[I]===1&&h.begin[I]===0&&h.end[I]===R;g=g&&_,y=y&&(I===0&&h.strides[I]===1||_)}else g=g&&h.strides[I]===1&&D,y=y&&(I===0&&h.strides[I]===1||D);let N,O=!1;if(h.beginValid&&h.endValid?(N=h.end[I]-h.begin[I],O=!0):E?(N=1,O=!0):D&&R>=0&&(h.strides[I]<0?N=-R:N=R,O=!0),O){let _;N===0||N<0!=h.strides[I]<0?_=0:_=Math.trunc(N/h.strides[I])+(N%h.strides[I]!==0?1:0),v.push(_)}else v.push(-1)}for(let I=0;I<h.finalShapeGatherIndices.length;++I){const E=h.finalShapeGatherIndices[I];E>=0?w.push(v[E]):E===gf&&w.push(1)}return{finalShapeSparse:w.filter((I,E)=>h.finalShapeGatherIndices[E]!==gf),finalShape:w,isIdentity:g,sliceDim0:y,isSimpleSlice:x,begin:h.begin,end:h.end,strides:h.strides}}function jR(t,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let n=0;e.beginValid=t.begin!=null,e.endValid=t.end!=null,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let r=0;r<t.dims;r++)if(1<<r&t.ellipsisMask){const o=Math.min(e.dims-(t.dims-r)+1+t.numAddAxisAfterEllipsis,e.dims);for(;n<o;n++)e.begin[n]=0,e.end[n]=0,e.strides[n]=1,e.beginMask|=1<<n,e.endMask|=1<<n,e.finalShapeGatherIndices.push(n),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&t.newAxisMask)e.finalShapeGatherIndices.push(gf),e.finalShapeGatherIndicesSparse.push(-1);else{if(n===e.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${e.dims} dims, ${e.begin.length}.`);t.begin!=null&&(e.begin[n]=t.begin[r]),t.end!=null&&(e.end[n]=t.end[r]),e.strides[n]=t.strides[r],t.beginMask&1<<r&&(e.beginMask|=1<<n),t.endMask&1<<r&&(e.endMask|=1<<n),t.shrinkAxisMask&1<<r?(e.finalShapeGatherIndices.push(zR),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<n):(e.finalShapeGatherIndices.push(n),e.finalShapeGatherIndicesSparse.push(r)),e.inputShapeGatherIndicesSparse[n]=r,n++}}function sy(t,e,n,r,o,i){if(o[e])return n>0?i[e]:i[e+1&1];{const a=t<0?r+t:t;return a<i[0]?i[0]:a>i[1]?i[1]:a}}const XR=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:lp,computeFlatOffset:fp,computeOutShape:cp,getNormalizedAxes:HR,isSliceContinous:dp,maskToAxes:GR,parseSliceParams:pp,sliceInfo:hp,startForAxis:ew,startIndicesWithElidedDims:Q0,stopForAxis:tw,stopIndicesWithElidedDims:Z0,stridesForAxis:J0,stridesWithElidedDims:q0},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qR=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:t=>t();function KR(){return new Promise(t=>qR(()=>t()))}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mp(t,e){const n=t[0].length;t.forEach((o,i)=>{re(o.length===n,()=>`Error in concat${n}D: rank of tensors[${i}] must be the same as the rank of the rest (${n})`)}),re(e>=0&&e<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);const r=t[0];t.forEach((o,i)=>{for(let a=0;a<n;a++)re(a===e||o[a]===r[a],()=>`Error in concat${n}D: Shape of tensors[${i}] (${o}) does not match the shape of the rest (${r}) along the non-concatenated axis ${i}.`)})}function tn(t,e){const n=t[0].slice();for(let r=1;r<t.length;r++)n[e]+=t[r][e];return n}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var gn;(function(t){t[t.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",t[t.VALUE_ROWIDS=1]="VALUE_ROWIDS",t[t.ROW_LENGTHS=2]="ROW_LENGTHS",t[t.ROW_SPLITS=3]="ROW_SPLITS",t[t.ROW_LIMITS=4]="ROW_LIMITS",t[t.ROW_STARTS=5]="ROW_STARTS"})(gn||(gn={}));function nw(t,e,n){let r=new Array;if(n==null&&e==null)return r;if(e==null)for(;r.length<t+n.length;)r.push(-1);else r=e.slice();if(n==null)return r;if(t+n.length!==r.length)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.rank = ${t+n.length}, but shape.rank = ${r.length}`);for(let o=1;o<n.length;++o){const i=n[o],a=r[r.length-n.length+o],u=r[a];if(i>=0)if(u>=0){if(u!==i)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.shape[${o+t}] = ${i} but shape[${o+t}] = ${u}`)}else r[a]=i}return r}function rw(t){const e={FIRST_DIM_SIZE:gn.FIRST_DIM_SIZE,VALUE_ROWIDS:gn.VALUE_ROWIDS,ROW_LENGTHS:gn.ROW_LENGTHS,ROW_SPLITS:gn.ROW_SPLITS,ROW_LIMITS:gn.ROW_LIMITS,ROW_STARTS:gn.ROW_STARTS},n=[];for(const r of t)if(r in e)n.push(e[r]);else break;return n}function ow(t){return t.length===0?0:t[0]===gn.FIRST_DIM_SIZE?t.length-1:t.length}function iw(t,e){if(t==null||e==null)return;const n=t.length,r=e.length;if(n>=r)throw new Error(`defaultValue.shape=${t} and ragged tensor flatValues.shape=${e}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${r})`);for(let o=0;o<Math.min(n,r-1);++o){const i=t[o],a=e[o+1];if(i>=0&&a>=0&&i!==1&&i!==a)throw new Error(`defaultValue.shape=${t}, and ragged tensor input flatValues.shape=${e} are incompatible: defaultValue.shape[${o-t.length}] = ${i} but ragged tensor input.flatValues.shape[${o-t.length}] = ${a}`)}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gp=30;function Sl(t){return t<=gp?t:rf(t,Math.floor(Math.sqrt(t)))}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yp(t,e,n){const r=n*(typeof t=="number"?t:t[0]),o=e*(typeof t=="number"?t:t[1]);return[r,o]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ra(t,e,n,r=!0){let o=[];if(r)o=o.concat(e.slice(0)),o.push(t[0]/n),o=o.concat(t.slice(1));else{o=o.concat(t[0]);const i=e.length;for(let a=0;a<i;++a)o=o.concat([t[a+1]/e[a],e[a]]);o=o.concat(t.slice(i+1))}return o}function Ea(t,e,n=!0){const r=[];if(n){r.push(e);for(let o=e+1;o<t;++o)o<=2*e?(r.push(o),r.push(o-(e+1))):r.push(o)}else{const o=[],i=[];for(let a=1;a<t;++a)a>=e*2+1||a%2===1?i.push(a):o.push(a);r.push(...o),r.push(0),r.push(...i)}return r}function _a(t,e,n,r=!0){const o=[];r?o.push(t[0]/n):o.push(t[0]*n);for(let i=1;i<t.length;++i)i<=e.length?r?o.push(e[i-1]*t[i]):o.push(t[i]/e[i-1]):o.push(t[i]);return o}function xp(t,e){const n=[0];for(let r=0;r<e;++r)n.push(t[r][0]);return n}function vp(t,e,n){const r=t.slice(0,1);for(let o=0;o<n;++o)r.push(t[o+1]-e[o][0]-e[o][1]);return r}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cp=1.7580993408473768,wp=1.0507009873554805;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sp=.3275911,bp=.254829592,Ip=-.284496736,$p=1.421413741,Rp=-1.453152027,Ep=1.061405429;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ha(t,e){if(t.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${t.length}, imag: ${e.length}.`);const n=new Float32Array(t.length*2);for(let r=0;r<n.length;r+=2)n[r]=t[r/2],n[r+1]=e[r/2];return n}function YR(t){const e=new Float32Array(t.length/2),n=new Float32Array(t.length/2);for(let r=0;r<t.length;r+=2)e[r/2]=t[r],n[r/2]=t[r+1];return{real:e,imag:n}}function QR(t){const e=Math.ceil(t.length/4),n=new Float32Array(e),r=new Float32Array(e);for(let o=0;o<t.length;o+=4)n[Math.floor(o/4)]=t[o],r[Math.floor(o/4)]=t[o+1];return{real:n,imag:r}}function ZR(t){const e=Math.floor(t.length/4),n=new Float32Array(e),r=new Float32Array(e);for(let o=2;o<t.length;o+=4)n[Math.floor(o/4)]=t[o],r[Math.floor(o/4)]=t[o+1];return{real:n,imag:r}}function JR(t,e){const n=t[e*2],r=t[e*2+1];return{real:n,imag:r}}function eE(t,e,n,r){t[r*2]=e,t[r*2+1]=n}function tE(t,e){const n=new Float32Array(t/2),r=new Float32Array(t/2);for(let o=0;o<Math.ceil(t/2);o++){const i=(e?2:-2)*Math.PI*(o/t);n[o]=Math.cos(i),r[o]=Math.sin(i)}return{real:n,imag:r}}function nE(t,e,n){const r=(n?2:-2)*Math.PI*(t/e),o=Math.cos(r),i=Math.sin(r);return{real:o,imag:i}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nd="->",rE=/->/g,ay=",",uy="...";function _p(t,e){t=t.replace(/\s/g,"");const n=(t.length-t.replace(rE,"").length)/Nd.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${Nd}").`);const[r,o]=t.split(Nd);re(r.indexOf(uy)===-1,()=>`The ellipsis notation ("${uy}") is not supported yet.`);const i=r.split(ay),a=i.length;if(e!==a)throw new Error(`Expected ${a} input tensors, received ${e}`);if(a>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const u=[];for(let h=0;h<o.length;++h){const g=o[h];if(!i.some(y=>y.indexOf(g)!==-1))throw new Error(`Output subscripts contain the label ${g} not present in the input subscripts.`);u.indexOf(g)===-1&&u.push(g)}for(let h=0;h<r.length;++h){const g=r[h];u.indexOf(g)===-1&&g!==ay&&u.push(g)}const l=new Array(i.length);for(let h=0;h<a;++h){if(new Set(i[h].split("")).size!==i[h].length)throw new Error(`Found duplicate axes in input component ${i[h]}. Support for duplicate axes in input is not implemented yet.`);l[h]=[];for(let g=0;g<i[h].length;++g)l[h].push(u.indexOf(i[h][g]))}const d=u.length,f=o.length,p=[];for(let h=f;h<d;++h)p.push(h);return{allDims:u,summedDims:p,idDims:l}}function Pp(t,e){let n=new Array(t);n.fill(-1);for(let o=0;o<e.length;++o)n[e[o]]=o;const r=[];for(let o=0;o<t;++o)n[o]===-1&&r.push(o);return n=n.filter(o=>o!==-1),{permutationIndices:n,expandDims:r}}function kp(t,e,n){const r=new Array(t);for(let o=0;o<n.length;++o){const i=n[o].shape;for(let a=0;a<e[o].length;++a)r[e[o][a]]===void 0?r[e[o][a]]=i[a]:re(r[e[o][a]]===i[a],()=>`Expected dimension ${r[e[o][a]]} at axis ${a} of input shaped ${JSON.stringify(i)}, but got dimension ${i[a]}`)}}function Tp(t,e){const n=t,r=[];let o=0;t.length===0&&n.push(-1),o=t.length+1;for(let a=0;a<o;++a)r.push([]);const i=[];for(let a=0;a<n.length;++a){const u=n[a],l=oE(e,u);for(const d of l)i.indexOf(d)===-1&&(r[a].push(d),i.push(d))}return{path:n,steps:r}}function Ap(t){return t.every((e,n)=>e===n)}function oE(t,e){const n=[];for(let r=0;r<t.length;++r)(t[r].length===0||t[r].indexOf(e)!==-1||e===-1)&&n.push(r);return n}function Np(t,e,n=0){let r=[];if(typeof e=="number")re(t.shape[n]%e===0,()=>"Number of splits must evenly divide the axis."),r=new Array(e).fill(t.shape[n]/e);else{const o=e.reduce((a,u)=>(u===-1&&(a+=1),a),0);re(o<=1,()=>"There should be only one negative value in split array.");const i=e.indexOf(-1);if(i!==-1){const a=e.reduce((u,l)=>l>0?u+l:u);e[i]=t.shape[n]-a}re(t.shape[n]===e.reduce((a,u)=>a+u),()=>"The sum of sizes must match the size of the axis dimension."),r=e}return r}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sw(t){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${t}`}function aw(t,e){return`indices(${t}, 0) is invalid: ${e} < 0`}function uw(t,e,n){return`indices(${t}, 0) is invalid: ${e} >= ${n}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lw(t,e){return`only one output dimension may be -1, not both ${t} and ${e}`}function cw(t,e){return`size ${t} must be non-negative, not ${e}`}function dw(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function fw(t,e){const n=Y(t),r=Y(e);return`Input to reshape is a SparseTensor with ${n}
  dense values, but the requested shape requires a multiple of ${r}. inputShape=${t} outputShape= ${e}`}function pw(t,e){const n=Y(t),r=Y(e);return`Input to reshape is a tensor with ${n} dense values, but the requested shape has ${r}. inputShape=${t} outputShape=${e}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yf(){return"segment ids must be >= 0"}function hw(){return"segment ids are not increasing"}function mw(t,e){return`Segment id ${t} out of range [0, ${e}), possibly because segmentIds input is not sorted.`}function gw(t,e,n){return`Bad: indices[${t}] == ${e} out of range [0, ${n})`}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yw(t,e){let n=!1,r;for(t<=gp?(r=t,n=!0):r=rf(t,Math.floor(Math.sqrt(t)));!n;)r>e||r===t?n=!0:r=rf(t,r+1);return r}function Op(t,e,n){const r=[],o=t.length;for(let i=0;i<o;i++)i!==e?r.push(t[i]):r.push(n);return r}function Dp(t,e,n,r){const o=e.shape.length,i=t.shape.length;if(r!==0&&(r<-o||r>o))throw new Error(`Expect batchDims in the range of [-${o}, ${o}], but got ${r}`);if(r<0&&(r+=o),r>i)throw new Error(`batchDims (${r}) must be less than rank(x) (
    ${i}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let p=0;p<r;++p)if(t.shape[p]!==e.shape[p])throw new Error(`x.shape[${p}]: ${t.shape[p]} should be equal to indices.shape[${p}]: ${e.shape[p]}.`);const a=t.shape[n],u=[];let l=1,d=1,f=1;for(let p=0;p<r;++p)u.push(t.shape[p]),l*=t.shape[p];for(let p=r;p<n;p++)u.push(t.shape[p]),d*=t.shape[p];for(let p=r;p<o;p++)u.push(e.shape[p]);for(let p=n+1;p<i;p++)u.push(t.shape[p]),f*=t.shape[p];return{batchSize:l,sliceSize:f,outerSize:d,dimSize:a,outputShape:u}}const iE=Object.freeze(Object.defineProperty({__proto__:null,collectGatherOpShapeInfo:Dp,computeOutShape:Op,segOpComputeOptimalWindowSize:yw},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Or(t){try{return t.map(e=>Yn(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function xw(t){return t.map(e=>Ar(e))}const sE=Object.freeze(Object.defineProperty({__proto__:null,ERF_A1:bp,ERF_A2:Ip,ERF_A3:$p,ERF_A4:Rp,ERF_A5:Ep,ERF_P:Sp,PARALLELIZE_THRESHOLD:gp,get RowPartitionType(){return gn},SELU_SCALE:wp,SELU_SCALEALPHA:Cp,applyActivation:SR,assertAndGetBroadcastShape:He,assertAxesAreInnerMostDims:Ft,assertParamsConsistent:mp,assignToTypedArray:eE,axesAreInnerMostDims:sp,calculateShapes:Uo,checkEinsumDimSizes:kp,checkPadOnDimRoundingMode:z$,combineLocations:z0,combineRaggedTensorToTensorShapes:nw,complexWithEvenIndex:QR,complexWithOddIndex:ZR,computeConv2DInfo:it,computeConv3DInfo:Dr,computeDefaultPad:op,computeDilation2DInfo:Ia,computeOptimalWindowSize:Sl,computeOutAndReduceShapes:Ht,computeOutShape:tn,computePool2DInfo:vn,computePool3DInfo:Zn,convertConv2DDataFormat:Cn,decodeEinsumEquation:_p,eitherStridesOrDilationsAreOne:Fr,expandShapeToKeepDim:Fn,exponent:nE,exponents:tE,fromStringArrayToUint8:xw,fromUint8ToStringArray:Or,getAxesPermutation:dt,getBroadcastDims:Bi,getComplexWithIndex:JR,getEinsumComputePath:Tp,getEinsumPermutation:Pp,getFusedBiasGradient:wR,getFusedDyActivation:CR,getImageCenter:yp,getInnerMostAxes:ft,getPermuted:Ea,getRaggedRank:ow,getReductionAxes:V0,getReshaped:Ra,getReshapedPermuted:_a,getRowPartitionTypesHelper:rw,getSliceBeginCoords:xp,getSliceSize:vp,getSparseFillEmptyRowsIndicesDenseShapeMismatch:sw,getSparseFillEmptyRowsNegativeIndexErrorMessage:aw,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:uw,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:dw,getSparseReshapeInputOutputMismatchErrorMessage:pw,getSparseReshapeInputOutputMultipleErrorMessage:fw,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:lw,getSparseReshapeNegativeOutputDimErrorMessage:cw,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:gw,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:yf,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:hw,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:mw,getUndoAxesPermutation:$a,isIdentityPermutation:Ap,log:OI,mergeRealAndImagArrays:ha,prepareAndValidate:up,prepareSplitSize:Np,segment_util:iE,shouldFuse:bR,slice_util:XR,splitRealAndImagArrays:YR,stridesOrDilationsArePositive:V$,tupleValuesAreOne:mf,upcastType:Rt,validateDefaultValueShape:iw,validateInput:xR,validateUpdateShape:G0,warn:yn},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */VR();/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aE=V();aE.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,t=>{t&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var ly;(function(t){t[t.DT_INVALID=0]="DT_INVALID",t[t.DT_FLOAT=1]="DT_FLOAT",t[t.DT_DOUBLE=2]="DT_DOUBLE",t[t.DT_INT32=3]="DT_INT32",t[t.DT_UINT8=4]="DT_UINT8",t[t.DT_INT16=5]="DT_INT16",t[t.DT_INT8=6]="DT_INT8",t[t.DT_STRING=7]="DT_STRING",t[t.DT_COMPLEX64=8]="DT_COMPLEX64",t[t.DT_INT64=9]="DT_INT64",t[t.DT_BOOL=10]="DT_BOOL",t[t.DT_QINT8=11]="DT_QINT8",t[t.DT_QUINT8=12]="DT_QUINT8",t[t.DT_QINT32=13]="DT_QINT32",t[t.DT_BFLOAT16=14]="DT_BFLOAT16",t[t.DT_QINT16=15]="DT_QINT16",t[t.DT_QUINT16=16]="DT_QUINT16",t[t.DT_UINT16=17]="DT_UINT16",t[t.DT_COMPLEX128=18]="DT_COMPLEX128",t[t.DT_HALF=19]="DT_HALF",t[t.DT_RESOURCE=20]="DT_RESOURCE",t[t.DT_VARIANT=21]="DT_VARIANT",t[t.DT_UINT32=22]="DT_UINT32",t[t.DT_UINT64=23]="DT_UINT64",t[t.DT_FLOAT_REF=101]="DT_FLOAT_REF",t[t.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",t[t.DT_INT32_REF=103]="DT_INT32_REF",t[t.DT_UINT8_REF=104]="DT_UINT8_REF",t[t.DT_INT16_REF=105]="DT_INT16_REF",t[t.DT_INT8_REF=106]="DT_INT8_REF",t[t.DT_STRING_REF=107]="DT_STRING_REF",t[t.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",t[t.DT_INT64_REF=109]="DT_INT64_REF",t[t.DT_BOOL_REF=110]="DT_BOOL_REF",t[t.DT_QINT8_REF=111]="DT_QINT8_REF",t[t.DT_QUINT8_REF=112]="DT_QUINT8_REF",t[t.DT_QINT32_REF=113]="DT_QINT32_REF",t[t.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",t[t.DT_QINT16_REF=115]="DT_QINT16_REF",t[t.DT_QUINT16_REF=116]="DT_QUINT16_REF",t[t.DT_UINT16_REF=117]="DT_UINT16_REF",t[t.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",t[t.DT_HALF_REF=119]="DT_HALF_REF",t[t.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",t[t.DT_VARIANT_REF=121]="DT_VARIANT_REF",t[t.DT_UINT32_REF=122]="DT_UINT32_REF",t[t.DT_UINT64_REF=123]="DT_UINT64_REF"})(ly||(ly={}));var cy;(function(t){(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(t.CheckpointFormatVersion||(t.CheckpointFormatVersion={}))})(cy||(cy={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jt=V();jt.registerFlag("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE",()=>15);jt.registerFlag("WEBGPU_CPU_FORWARD",()=>!0);jt.registerFlag("WEBGPU_MATMUL_PROGRAM_TYPE",()=>-1);jt.registerFlag("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE",()=>!0);jt.registerFlag("WEBGPU_USE_LOW_POWER_GPU",()=>!1);jt.registerFlag("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e3);jt.registerFlag("WEBGPU_USE_PROFILE_TOOL",()=>!1);jt.registerFlag("WEBGPU_IMPORT_EXTERNAL_TEXTURE",()=>!0);jt.registerFlag("WEBGPU_USE_NAIVE_CONV2D_DEBUG",()=>!1);jt.registerFlag("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL",()=>-1);jt.registerFlag("WEBGPU_CONV_SEPARATE_IM2COL_SHADER",()=>!1);jt.registerFlag("WEBGPU_PRINT_SHADER",()=>"");jt.registerFlag("WEBGPU_ENGINE_COMPILE_ONLY",()=>!1);/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class uE{constructor(e){e&&(this.vendor=e.vendor,this.architecture=e.architecture,this.intelGPUGeneration=this.getIntelGPUGeneration())}getIntelGPUGeneration(){if(this.isIntel()){if(this.architecture.startsWith("gen"))return Number(this.architecture.match(/\d+/));if(this.architecture.startsWith("xe"))return 12}return 0}isIntel(){return this.vendor==="intel"}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lE{constructor(e){this.device=e,this.numUsedBuffers=0,this.numFreeBuffers=0,this.freeBuffers=new Map,this.usedBuffers=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireBuffer(e,n,r=!1,o=!0){let i;const a=dy(e,n);return o?(this.freeBuffers.has(a)||this.freeBuffers.set(a,[]),this.freeBuffers.get(a).length>0?(i=this.freeBuffers.get(a).pop(),this.numFreeBuffers--):(i=this.device.createBuffer({size:e,usage:n,mappedAtCreation:r}),this.numBytesAllocated+=e)):(i=this.device.createBuffer({size:e,usage:n,mappedAtCreation:r}),this.numBytesAllocated+=e),this.usedBuffers.has(a)||this.usedBuffers.set(a,[]),this.usedBuffers.get(a).push(i),this.numUsedBuffers++,this.numBytesUsed+=e,i}releaseBuffer(e,n=!0){if(this.freeBuffers.size===0)return;const r=e.size,o=e.usage,i=dy(r,o),a=this.usedBuffers.get(i),u=a.indexOf(e);if(u<0)throw new Error("Cannot find the buffer in buffer manager");a[u]=a[a.length-1],a.pop(),this.numUsedBuffers--,this.numBytesUsed-=r,n?(this.freeBuffers.get(i).push(e),this.numFreeBuffers++):(e.destroy(),this.numBytesAllocated-=r)}getNumUsedBuffers(){return this.numUsedBuffers}getNumFreeBuffers(){return this.numFreeBuffers}dispose(){this.freeBuffers.forEach((e,n)=>{e.forEach(r=>{r.destroy()})}),this.usedBuffers.forEach((e,n)=>{e.forEach(r=>{r.destroy()})}),this.freeBuffers=new Map,this.usedBuffers=new Map,this.numUsedBuffers=0,this.numFreeBuffers=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function dy(t,e){return`${t}_${e}`}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let cE=class{constructor(e){this.device=e,this.numUsedTextures=0,this.numFreeTextures=0,this.freeTextures=new Map,this.usedTextures=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireTexture(e,n,r,o){const i=py(r),a=e*n*i,u=fy(e,n,r,o);if(this.freeTextures.has(u)||this.freeTextures.set(u,[]),this.usedTextures.has(u)||this.usedTextures.set(u,[]),this.numBytesUsed+=a,this.numUsedTextures++,this.freeTextures.get(u).length>0){this.numFreeTextures--;const d=this.freeTextures.get(u).shift();return this.usedTextures.get(u).push(d),d}this.numBytesAllocated+=a;const l=this.device.createTexture({size:[e,n],format:r,usage:o});return this.usedTextures.get(u).push(l),l}releaseTexture(e){if(this.freeTextures.size===0)return;const n=e.width,r=e.height,o=e.format,i=e.usage,a=fy(n,r,o,i);this.freeTextures.has(a)||this.freeTextures.set(a,[]),this.freeTextures.get(a).push(e),this.numFreeTextures++,this.numUsedTextures--;const u=this.usedTextures.get(a),l=u.indexOf(e);if(l<0)throw new Error("Cannot release a texture that was never provided by this texture manager");u.splice(l,1);const d=py(o),f=n*r*d;this.numBytesUsed-=f}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){this.freeTextures.forEach((e,n)=>{e.forEach(r=>{r.destroy()})}),this.usedTextures.forEach((e,n)=>{e.forEach(r=>{r.destroy()})}),this.freeTextures=new Map,this.usedTextures=new Map,this.numUsedTextures=0,this.numFreeTextures=0,this.numBytesUsed=0,this.numBytesAllocated=0}};function fy(t,e,n,r){return`${t}_${e}_${n}_${r}`}function py(t){if(t==="rgba8unorm")return 16;throw new Error(`${t} is not supported!`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dE(t,e){if(Math.max(...t)>5)throw new Error("Cannot symbolically compute strides for rank > 6 tensor.");const n=t.length,r="xyzwuv",o=t.map(a=>`${e}.${r[a]}`),i=new Array(n-1);i[n-2]=o[n-1];for(let a=n-3;a>=0;--a)i[a]=`(${i[a+1]} * ${o[a+1]})`;return i}const Lr=(t,e,n)=>n==="int32"?`atomicAdd(${t}, bitcast<i32>(${e}));`:`
          {
            var oldValue = 0;
            loop {
              let newValueF32 = bitcast<f32>(oldValue) + (${e});
              let newValue = bitcast<i32>(newValueF32);
              let res = atomicCompareExchangeWeak(${t}, oldValue, newValue);
              if res.exchanged {
                break;
              }
              oldValue = res.old_value;
            }
          }`;/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Wi;(function(t){t[t.FROM_PIXELS=0]="FROM_PIXELS",t[t.DRAW=1]="DRAW"})(Wi||(Wi={}));const fE=(t,e,n,r,o)=>{const i={dtype:r.dtype,shape:r.shape},a=hE(n,i,e),u=t.createShaderModule({code:a,label:e.constructor.name});let l=V().get("WEBGPU_PRINT_SHADER");if(l!==""){l=l.toLowerCase();const d=l.split(",");(l==="all"||d.some(f=>e.shaderKey.toLowerCase().includes(f)))&&(console.group(e.shaderKey),console.debug(a),console.groupEnd())}return o?t.createComputePipelineAsync({compute:{module:u,entryPoint:"_start"},label:e.constructor.name,layout:"auto"}):t.createComputePipeline({compute:{module:u,entryPoint:"_start"},label:e.constructor.name,layout:"auto"})},_e=(t,e="f32")=>{switch(t){case 1:return`${e}`;case 2:return`vec2<${e}>`;case 3:return`vec3<${e}>`;case 4:return`vec4<${e}>`;default:throw new Error(`${t}-component ${e} is not supported.`)}};function Ze(t){if(t<=1)return"i32";if(t===2)return"vec2<i32>";if(t===3)return"vec3<i32>";if(t===4)return"vec4<i32>";if(t===5)return"vec5";if(t===6)return"vec6";throw Error(`GPU for rank ${t} is not yet supported`)}function Xn(t){if(t===0)return"x";if(t===1)return"y";if(t===2)return"z";if(t===3)return"w";if(t===4)return"u";if(t===5)return"v";throw Error(`Index ${t} is not yet supported`)}function se(...t){let e;switch(t.length){case 0:e=`
        fn main()
      `;break;case 1:e=`
        fn main(${t[0]} : i32)
      `;break;default:throw Error("Unreachable")}return e}function hy(t,e){let n;return n=`
     ${pE(e)}
      fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,
                @builtin(global_invocation_id) GlobalId : vec3<u32>,
                @builtin(local_invocation_index) LocalIndex: u32,
                @builtin(workgroup_id) WorkgroupId : vec3<u32>,
                @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {
        localId = LocalId;
        localIndex = LocalIndex;
        globalId = GlobalId;
        numWorkgroups = NumWorkgroups;
        workgroupId = WorkgroupId;
        ${t?"main(getGlobalIndex());":"main();"};
      }
    `,n}function pE(t){return`
  @compute @workgroup_size(${t.workgroupSize[0]}, ${t.workgroupSize[1]}, ${t.workgroupSize[2]})
`}function hE(t,e,n){const r=[],o=n.workgroupSize[0]*n.workgroupSize[1]*n.workgroupSize[2];if(n.outputComponent=n.outputComponent?n.outputComponent:1,r.push(`

      var<private> localId: vec3<u32>;
      var<private> localIndex: u32;
      var<private> globalId: vec3<u32>;
      var<private> numWorkgroups: vec3<u32>;
      var<private> workgroupId: vec3<u32>;

      // Only used when the y/z dimension of workgroup size is 1.
      fn getGlobalIndex() -> i32 {
        ${vw(n)?"  return i32(globalId.x);":`  return i32((workgroupId.z * numWorkgroups.x * numWorkgroups.y +
                workgroupId.y * numWorkgroups.x + workgroupId.x) * ${o}u +
                localIndex);
        `}
      }
    `),n.pixelsOpType!=null){const y=n.pixelsOpType===Wi.FROM_PIXELS?`@group(0) @binding(0) var<storage, read_write> result: array<${ko(e.dtype,n.outputComponent)}>;`:`@group(0) @binding(1) var<storage, read> inBuf : array<${ko(t[0].dtype,n.outputComponent)}>;`,x=e.shape.length===3?"vec2<i32>":"i32";r.push(`
        struct Uniform {
          outShapeStrides : ${x},
          size            : i32,
          numChannels     : i32,
          alpha           : f32,
        };

        ${y}
        @group(0) @binding(2) var<uniform> uniforms: Uniform;
      `);const v=gy(n);return[my,r.join(`
`),Zu(e.shape),n.getUserCode(),hy(v,n)].join(`
`)}let i,a,u="struct Uniforms { NAN : f32, INFINITY : f32, ";n.variableNames.forEach((y,x)=>{const v=Ze(t[x].shape.length);u+=`${y.charAt(0).toLowerCase()+y.slice(1)}Shape : ${v}, `,i=t[x].shape.length-1,a=Ze(i),u+=`${y.charAt(0).toLowerCase()+y.slice(1)}ShapeStrides: ${a}, `});const l=Ze(e.shape.length);u+=`outShape : ${l}, `,i=e.shape.length-1,a=Ze(i),u+=`
         outShapeStrides: ${a}, `,n.size&&(u+="size : i32, "),n.uniforms&&(u+=n.uniforms),u+="};",u=bE(u),r.push(u),n.atomic?r.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<atomic<i32>>;
    `):r.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<${ko(e.dtype,n.outputComponent)}>;
    `),n.variableNames.forEach((y,x)=>{r.push(`
      @group(0) @binding(${1+x}) var<storage, read> ${y}: array<${n.variableComponents?ko(t[x].dtype,n.variableComponents[x]):ko(t[x].dtype,n.outputComponent)}>;
        `)}),u!==""&&r.push(`
      @group(0) @binding(${1+n.variableNames.length}) var<uniform> uniforms: Uniforms;
      `);const d=CE(e.shape,n.dispatchLayout),f=[my,r.join(`
`)+gE,Zu(e.shape),d,wE(e.shape.length)];n.atomic||f.push(SE(e.shape,e.dtype,n.outputComponent)),n.variableNames.forEach((y,x)=>{f.push(`${Zu(t[x].shape,y)}`)});const p=t.map((y,x)=>vE(y,e.shape,n.variableComponents?n.variableComponents[x]:n.outputComponent,n.dispatchLayout.x.length===e.shape.length)).join(`
`);f.push(p),f.push(n.getUserCode());const h=gy(n);return f.push(hy(h,n)),f.join(`
`)}function mE(t,e,n){let r=t.shaderKey;if(t.pixelsOpType!=null)return r;const o=[],i=[];e.forEach(f=>{o.push(f.shape),i.push(f.dtype)}),o.push(n.shape),i.push(n.dtype);const a=e.map(f=>Bi(f.shape,n.shape)),u=e.map(f=>je(f.shape,n.shape)).join("_"),l=a.map(f=>f.join("_")).join(";"),d=vw(t)?"flatDispatch":"";return r+="_"+(t.workgroupSize?t.workgroupSize.join(","):"")+o.map(f=>f.length).join(",")+i.join(",")+t.variableNames.join(",")+l+u+d,r}const my=`
  struct vec5 {x: i32, y: i32, z: i32, w: i32, u: i32};
  struct vec6 {x: i32, y: i32, z: i32, w: i32, u: i32, v: i32};

  // Checks whether coordinates lie within the bounds of the shape.
  fn coordsInBounds2D(coord : vec2<i32>, shape : vec2<i32>) -> bool {
    return all(coord >= vec2<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds3D(coord : vec3<i32>, shape : vec3<i32>) -> bool {
    return all(coord >= vec3<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds4D(coord : vec4<i32>, shape : vec4<i32>) -> bool {
    return all(coord >= vec4<i32>(0)) && all(coord < shape);
  }

  fn getIndexFromCoords1D(coord : i32, shape : i32) -> i32 {
    return coord;
  }
  fn getIndexFromCoords2D(coords : vec2<i32>, shape : vec2<i32>) -> i32 {
    return dot(coords, vec2<i32>(shape.y, 1));
  }
  fn getIndexFromCoords3D(coords : vec3<i32>, shape : vec3<i32>) -> i32 {
    return dot(coords, vec3<i32>(shape.y * shape.z, shape.z, 1));
  }
  fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
    return dot(coords, vec4<i32>(
        shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
  }
  fn getIndexFromCoords5D(coords : vec5, shape : vec5) -> i32 {
    let shapeStrides: vec5 = vec5(shape.y * shape.z * shape.w * shape.u, shape.z * shape.w * shape.u, shape.w * shape.u, shape.u, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u;
  }
  fn getIndexFromCoords6D(coords : vec6, shape : vec6) -> i32 {
    let shapeStrides: vec6 = vec6(shape.y * shape.z * shape.w * shape.u * shape.v, shape.z * shape.w * shape.u * shape.v, shape.w * shape.u * shape.v, shape.u * shape.v, shape.v, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u + coords.v*shapeStrides.v;
  }

  // NaN defination in IEEE 754-1985 is :
  //   - sign = either 0 or 1.
  //   - biased exponent = all 1 bits.
  //   - fraction = anything except all 0 bits (since all 0 bits represents infinity).
  // https://en.wikipedia.org/wiki/IEEE_754-1985#Representation_of_non-numbers
  fn isnan(val: f32) -> bool {
    let floatToUint: u32 = bitcast<u32>(val);
    return (floatToUint & 0x7fffffffu) > 0x7f800000u;
  }
  fn isnanVec4(val : vec4<f32>) -> vec4<bool> {
    let floatToUint: vec4<u32> = bitcast<vec4<u32>>(val);
    return (floatToUint & vec4<u32>(0x7fffffffu)) > vec4<u32>(0x7f800000u);
  }
`,gE=`
  fn isinf(val: f32) -> bool {
    return abs(val) == uniforms.INFINITY;
  }
`;function Zu(t,e=""){const n=t.length,r=e!==""?`get${e.charAt(0).toUpperCase()+e.slice(1)}CoordsFromIndex`:"getCoordsFromIndex",o=e!==""?`${e.charAt(0).toLowerCase()+e.slice(1)}ShapeStrides`:"outShapeStrides";if(n<=1)return`fn ${r}(index : i32) -> i32 { return index; }`;const i=Ke(t),a=Ze(n),u=[];for(let d=0;d<n;d++)u.push(`d${d}`);if(i.length===1)return`    fn ${r}(index : i32) -> vec2<i32> {
      let d0 = index / uniforms.${o}; let d1 = index - d0 * uniforms.${o};
      return vec2<i32>(d0, d1);
    }`;let l;return l="var index2 = index;"+i.map((d,f)=>{const p=`let ${u[f]} = index2 / uniforms.${o}.${Xn(f)}`,h=f===i.length-1?`let ${u[f+1]} = index2 - ${u[f]} * uniforms.${o}.${Xn(f)}`:`index2 = index2 - ${u[f]} * uniforms.${o}.${Xn(f)}`;return`${p}; ${h};`}).join(""),`
    fn ${r}(index : i32) -> ${a} {
      ${l}
      return ${a}(${u.join(",")});
    }
  `}function yE(t,e){const n=t.name,r=t.shape.length,o=Ze(r),i="get"+n.charAt(0).toUpperCase()+n.slice(1),a=["d0","d1","d2","d3","d4","d5"].slice(0,r),u=a.map(f=>`${f} : i32`).join(", ");if(r<1)return`
      fn ${i}() -> ${_e(e)} {
        return ${_e(e)}(${n}[0]);
      }
    `;const l=`uniforms.${n.charAt(0).toLowerCase()+n.slice(1)}Shape`;let d=`${r}D`;return r===0&&(d="1D"),`
    fn ${i}(${u}) -> ${_e(e)} {
      return ${_e(e)}(${n}[getIndexFromCoords${d}(${o}(${a.join(",")}),
        ${l})${e===1?"":` / ${e}`}]);
    }
   `}function xE(t,e,n,r){const o=t.name,i=o.charAt(0).toUpperCase()+o.slice(1),a="get"+i+"ByOutput",u=t.shape.length,l=e.length,d=Ze(l);if(je(t.shape,e)&&r)return`
    fn ${a}Index(globalIndex : i32) -> ${_e(n)} {
      return ${_e(n)}(${o}[globalIndex]);
    }

    fn ${a}Coords(coords : ${d}) -> ${_e(n)} {
      return ${_e(n)}(${o}[${l>1?"getOutputIndexFromCoords(coords)":"coords"}${n===1?"":` / ${n}`}]);
    }
    `;const f=Bi(t.shape,e),p=l-u;let h="";if(u===0)return`
    fn ${a}Index(globalIndex : i32) -> ${_e(n)}{
      return get${i}();
    }

    fn ${a}Coords(coords : ${d}) -> ${_e(n)}{
      return get${i}();
    }
  `;l<2&&f.length>=1?h="coords = 0;":h=f.map(v=>`coords.${Xn(v+p)} = 0;`).join(`
`);let g="";if(l<2&&u>0)g="coords";else if(l>1){const v=Ze(u),w=t.shape.map((S,I)=>`coords.${Xn(I+p)}`).join(", ");g=`${v}(${w})`}else g="coords";const y=`uniforms.${o.charAt(0).toLowerCase()+o.slice(1)}Shape`,x=`${u}D`;return`
  fn ${a}Index(globalIndex : i32) -> ${_e(n)} {
    var coords = getCoordsFromIndex(globalIndex);
    ${h}
    return ${_e(n)}(${o}[getIndexFromCoords${x}(${g}, ${y})${n===1?"":` / ${n}`}]);
  }

  fn ${a}Coords(coordsIn : ${d}) -> ${_e(n)} {
    var coords = coordsIn;
    ${h}
    return ${_e(n)}(${o}[getIndexFromCoords${x}(${g}, ${y})${n===1?"":` / ${n}`}]);
  }
`}function vE(t,e,n,r){let o=yE(t,n);return t.shape.length<=e.length&&(o+=xE(t,e,n,r)),o}function CE(t,e){const{x:n,y:r=[],z:o=[]}=e,i=t.length,a=n.length+r.length+o.length;if(a!==i)return"";if(n.length===i)return`fn getOutputCoords() -> ${Ze(i)}{
    let globalIndex = getGlobalIndex();
    return getCoordsFromIndex(globalIndex);
  }
  `;let u="";const l=[n,r,o];for(let h=0;h<l.length;h++){const g=l[h];if(g.length!==0)if(g.length===1)u+=`let d${g[0]} = i32(globalId[${h}]);`;else{const y=dE(g,"uniforms.outShape");u+=`var index${h} = i32(globalId[${h}]);`;for(let x=0;x<y.length;x++)u+=`let d${g[x]} = index${h} / ${y[x]};`,x===y.length-1?u+=`let d${g[x+1]} = index${h} - d${g[x]} * ${y[x]};`:u+=`index${h} = index${h} - d${g[x]} * ${y[x]};`}}const d=[];for(let h=0;h<a;h++)d.push(`d${h}`);const f=Ze(a);let p=`fn getOutputCoords() -> ${f} {
  ${u}
`;return d.length===0?p+=`return ${f}(0); }`:p+=`return ${f}(${d.join(",")}); }`,p}function wE(t){let e="";switch(t){case 0:case 1:e+=`
        fn getOutputIndexFromCoords(coords : i32) -> i32 {
          return coords;
        }
        `;break;case 2:e+=`
        fn getOutputIndexFromCoords(coords : vec2<i32>) -> i32 {
          return dot(coords, vec2<i32>(uniforms.outShapeStrides, 1));
        }
        `;break;case 3:e+=`
        fn getOutputIndexFromCoords(coords : vec3<i32>) -> i32 {
          return dot(coords, vec3<i32>(uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, 1));
        }
        `;break;case 4:e+=`
        fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
          return dot(coords, vec4<i32>(
            uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, uniforms.outShapeStrides.z, 1));
        }
        `;break;case 5:e+=`
        fn getOutputIndexFromCoords(coords : vec5) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u;
        }
        `;break;case 6:e+=`
        fn getOutputIndexFromCoords(coords : vec6) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u * uniforms.outShapeStrides.u +
              coords.v;
        }
        `;break;default:re(!1,()=>`Unsupported ${t}D shape`);break}return e}function vw(t){return t.dispatch[1]===1&&t.dispatch[2]===1}function ko(t,e=1){if(t==="float32")return _e(e,"f32");if(t==="int32"||t==="bool")return _e(e,"i32");throw new Error(`type ${t} is not supported.`)}function SE(t,e,n){const r=t.length,o=ko(e,n);let i=`fn setOutputAtIndex(flatIndex : i32, value : ${_e(n)}) {
      result[flatIndex] = ${o}(value);
    }

    fn setOutputAtIndexI32(flatIndex : i32, value : ${_e(n,"i32")}) {
      result[flatIndex] = ${o}(value);
    }
    `;if(r>=2){const a=["d0","d1","d2","d3","d4","d5"].slice(0,r),u=Ze(r);i+=`
      fn setOutputAtCoords(${a.map(l=>`${l} : i32`).join(", ")}, value : ${_e(n)}) {
        let flatIndex = getOutputIndexFromCoords(${u}(${a.join(", ")}));
        setOutputAtIndex(flatIndex${n===1?"":` / ${n}`}, value);
      }
      fn setOutputAtCoordsI32(${a.map(l=>`${l} : i32`).join(", ")}, value : ${_e(n,"i32")}) {
        let flatIndex = getOutputIndexFromCoords(${u}(${a.join(", ")}));
        setOutputAtIndexI32(flatIndex${n===1?"":` / ${n}`}, value);
      }
    `}return i}function bE(t){const e=/(\w+)\s*:\s*vec(5|6)/g;t=t.replace(e,r=>"@align(16) "+r);const n=/vec(5|6)\s*,\s*(\w+)/g;return t=t.replace(n,(r,o,i)=>`vec${o}, @align(16) ${i}`),t}function gy(t){return!(t.dispatchLayout.hasOwnProperty("y")&&t.dispatchLayout.y.length!==0||t.dispatchLayout.hasOwnProperty("z")&&t.dispatchLayout.z.length!==0)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Oo=t=>{let e=1;for(let n=0;n<t.length;n++)e*=t[n];return e};function ae(t,e,n=[1,1,1],r=[1,1,1]){const[o,i,a]=[Math.ceil(Oo(t.x.map(u=>e[u]))/(n[0]*r[0])),t.y?Math.ceil(Oo(t.y.map(u=>e[u]))/(n[1]*r[1])):1,t.z?Math.ceil(Oo(t.z.map(u=>e[u]))/(n[2]*r[2])):1];return[o,i,a]}function IE(t,e,n,r=!1){const o=[8,8,1],i=[4,4,1];return r||(t<=8&&(i[1]=1),e<=16&&n<=16&&(o[0]=4)),{workgroupSize:o,elementsPerThread:i}}function Cw(t,e,n=!1){if(n)return[8,8,1];const r=Oo(t.x.map(i=>e[i])),o=Oo(t.y.map(i=>e[i]));return r<=4?[4,16,1]:o<=4?[16,4,1]:[16,16,1]}function ww(t,e,n=!1){if(n)return[4,4,1];const r=Oo(t.x.map(i=>e[i])),o=Oo(t.y.map(i=>e[i]));return r<=4?[1,2,1]:o<=4?[2,1,1]:[2,2,1]}function ce(t){return{x:t.map((e,n)=>n)}}function yy(t){if(t==="float32"||t==="int32"||t==="bool"||t==="string")return 4;if(t==="complex64")return 8;throw new Error(`Unknown dtype ${t}`)}function Sw(){return!!(typeof globalThis<"u"&&globalThis.navigator&&globalThis.navigator.gpu)}function bw(t,e){Array.isArray(t)||(t=[t]),t.forEach(n=>{n!=null&&re(n.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGPU backend.`)})}var kn;(function(t){t[t.MatMulReduceProgram=0]="MatMulReduceProgram",t[t.MatMulSplitKProgram=1]="MatMulSplitKProgram",t[t.MatMulSmallOutputSizeProgram=2]="MatMulSmallOutputSizeProgram",t[t.MatMulPackedProgram=3]="MatMulPackedProgram",t[t.MatMulMax=4]="MatMulMax"})(kn||(kn={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $E=V().getNumber("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD"),RE=(t,e)=>{const n=t.limits.maxComputeWorkgroupsPerDimension,r=e.dispatchLayout,o=e.dispatch;if(o.every(a=>a<=n))return o;re(o[0]>n&&r.y===void 0&&r.z===void 0,()=>"Dispatch size exceeds WebGPU limits in Y or Z dimension.");let i=Math.ceil(Math.sqrt(o[0]));return i>n?(i=Math.ceil(Math.cbrt(o[0])),re(i<=n,()=>"Total dispatch size exceeds WebGPU maximum."),[i,i,i]):[i,i,1]};class bl extends Pf{nextDataId(){return bl.nextDataId++}constructor(e,n){if(super(),this.commandQueueOwnedIds=new WeakSet,this.dispatchCountInPass=0,this.disposed=!1,this.downloadWaitMs=0,this.tensorDataPendingDisposal=[],this.queryResolveBuffer=null,this.querySet=null,this.querySetCount=2,this.stagingPendingDisposal=[],this.uniformPendingDisposal=[],this.uploadWaitMs=0,this.hasReadSyncWarned=!1,this.hasTimestampQueryWarned=!1,!Sw())throw new Error("WebGPU is not supported on this device");this.pipelineCache={},this.device=e,this.queue=e.queue,this.commandEncoder=null,this.computePassEncoder=null,this.adapterInfo=new uE(n),this.supportTimestampQuery=this.device.features.has("timestamp-query"),this.thresholdToIncreaseWorkgroups=this.adapterInfo.intelGPUGeneration>=12?16:8,this.bufferManager=new lE(this.device),this.textureManager=new cE(this.device),this.tensorMap=new Lv(this,fn()),V().getBool("WEBGPU_USE_PROFILE_TOOL")&&(this.dummyCanvas=document.createElement("canvas"),this.dummyCanvas.width=1,this.dummyCanvas.height=1,this.dummyContext=this.dummyCanvas.getContext("webgpu"),this.dummyContext.configure({device:e,format:"bgra8unorm"}),document.body.appendChild(this.dummyCanvas))}floatPrecision(){return 32}disposeData(e,n=!1){if(!this.tensorMap.has(e))return!0;const r=this.tensorMap.get(e);return n?r.refCount=0:r.refCount--,r.refCount>0?!1:(r.complexTensorInfos!=null&&(this.disposeData(r.complexTensorInfos.real.dataId),this.disposeData(r.complexTensorInfos.imag.dataId)),this.commandQueueOwnedIds.has(e)?(this.tensorDataPendingDisposal.push(e),!0):(this.releaseResource(e),this.tensorMap.delete(e),!0))}memory(){return{numBytesInGPU:this.bufferManager.numBytesUsed,numBytesAllocatedInGPU:this.bufferManager.numBytesAllocated,unreliable:!1}}releaseResource(e){const n=this.tensorMap.get(e);if(!(!n||!n.resource)){if(n.external){n.resource=null;return}n.resource instanceof GPUBuffer?this.bufferManager.releaseBuffer(n.resource):n.resource instanceof GPUTexture&&this.textureManager.releaseTexture(n.resource),n.resource=null}}refCount(e){return this.tensorMap.has(e)?this.tensorMap.get(e).refCount:0}incRef(e){const n=this.tensorMap.get(e);n.refCount++}decRef(e){if(this.tensorMap.has(e)){const n=this.tensorMap.get(e);n.refCount--}}write(e,n,r){if(r==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const o={id:this.nextDataId()};return this.tensorMap.set(o,{dtype:r,shape:n,values:e,refCount:1}),o}move(e,n,r,o,i){if(o==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.tensorMap.set(e,{dtype:o,shape:r,values:n,refCount:i})}submitQueue(){this.queue.submit([this.commandEncoder.finish()]),this.commandEncoder=null,this.dispatchCountInPass=0,this.commandQueueOwnedIds=new WeakSet,this.tensorDataPendingDisposal.forEach(e=>{this.releaseResource(e),this.tensorMap.delete(e)}),this.uniformPendingDisposal.forEach(e=>this.bufferManager.releaseBuffer(e)),this.stagingPendingDisposal.forEach(e=>this.bufferManager.releaseBuffer(e,!1)),this.tensorDataPendingDisposal=[],this.uniformPendingDisposal=[],this.stagingPendingDisposal=[]}ensureCommandEncoderReady(){this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder())}endComputePassEncoder(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}async checkCompileCompletionAsync(){let e;try{e=await Promise.all(Object.values(this.pipelineCache))}catch(n){throw new Error(n.message)}Object.keys(this.pipelineCache).map((n,r)=>{this.pipelineCache[n]=e[r]})}async getBufferData(e){if(V().getBool("WEBGPU_ENGINE_COMPILE_ONLY"))return console.warn("The data may be invalid since WEBGPU_ENGINE_COMPILE_ONLY is true, this can only be called when WEBGPU_ENGINE_COMPILE_ONLY is false"),null;const n=e.size,r=this.bufferManager.acquireBuffer(n,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ);this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(e,0,r,0,n),this.submitQueue(),await r.mapAsync(GPUMapMode.READ);const o=r.getMappedRange().slice(0);return r.unmap(),r!=null&&this.bufferManager.releaseBuffer(r),V().getBool("WEBGPU_USE_PROFILE_TOOL")&&(re(this.dummyContext!==void 0,()=>"Fail to get context for profiling tool"),this.dummyContext.getCurrentTexture()),o}convertAndCacheOnCPU(e,n){const r=this.tensorMap.get(e);return r.values=n,r.values}readSync(e){const n=this.tensorMap.get(e),{values:r,complexTensorInfos:o}=n;if(r!=null||n.dtype==="string")return r;if(n.dtype==="complex64"){const x=this.readSync(o.real.dataId),v=this.readSync(o.imag.dataId),w=Ed(ha(x,v).buffer,"float32");return this.convertAndCacheOnCPU(e,w),w}this.hasReadSyncWarned||(this.hasReadSyncWarned=!0,console.warn("The performance of synchronously reading data from GPU to CPU is poor on the webgpu backend, please use asynchronous APIs instead."));const i=["opaque","premultiplied"],a=n.resource,u=a.size;re(u%4===0,()=>"Because there is 4 bytes for one pixel, buffer size must be multiple of 4.");const l=u/4,d=new ArrayBuffer(u),f=256,p=256,h=i.map(x=>new OffscreenCanvas(f,p)),g=new OffscreenCanvas(f,p);this.endComputePassEncoder(),h.map((x,v)=>{const w=x.getContext("webgpu");return w.configure({device:this.device,format:"bgra8unorm",usage:GPUTextureUsage.COPY_DST,alphaMode:i[v]}),w.getCurrentTexture()}).map((x,v)=>{const w=f*4,S=(D,N,O)=>{this.ensureCommandEncoderReady(),this.commandEncoder.copyBufferToTexture({buffer:a,bytesPerRow:w,offset:O},{texture:x},{width:D,height:N}),this.submitQueue();const _=g.getContext("2d",{willReadFrequently:!0});_.clearRect(0,0,D,N),_.drawImage(h[v],0,0);const F=_.getImageData(0,0,D,N).data,U=i[v],G=new Uint8ClampedArray(d,O,D*N*4);for(let j=0;j<G.length;j+=4)if(U==="premultiplied")G[j+3]=F[j+3];else{const Z=F[j];G[j]=F[j+2],G[j+1]=F[j+1],G[j+2]=Z}},I=Math.floor(l/(f*p));let E=f,R=p,T=0;for(let D=0;D<I;D++)S(E,R,T),T+=f*p*4;const k=l%(f*p);R=Math.floor(k/f),R>0&&(S(E,R,T),T+=R*(f*4)),E=k%f,E>0&&S(E,1,T)});const y=Ed(d,n.dtype);return this.convertAndCacheOnCPU(e,y),y}async read(e){if(!this.tensorMap.has(e))throw new Error(`Tensor ${e} was not registered!`);const n=this.tensorMap.get(e),{values:r}=n;if(r!=null)return r;let o;if(n.dtype==="complex64"){const i=await Promise.all([this.read(n.complexTensorInfos.real.dataId),this.read(n.complexTensorInfos.imag.dataId)]),a=i[0],u=i[1];o=ha(a,u)}else{const i=await this.getBufferData(n.resource);o=Ed(i,n.dtype)}return this.convertAndCacheOnCPU(e,o),o}copyBuffer(e){const n=e.size,r=e.usage,o=this.bufferManager.acquireBuffer(n,r);return this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(e,0,o,0,n),this.submitQueue(),o}createTensorFromGPUData(e,n,r){let o=e.buffer;if(r==="complex64")throw new Error("Cannot write to a complex64 dtype. ");const i={id:this.nextDataId()};this.tensorMap.set(i,{dtype:r,shape:n,values:null,refCount:1,external:e.zeroCopy});const a=this.tensorMap.get(i),u=yy(a.dtype)*Y(a.shape);if(e.buffer.size<u)throw new Error(`GPUBuffer size(${e.buffer.size}) is smaller than tensor size(${u})!`);if((e.buffer.usage&(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))!==(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))throw new Error("GPUBuffer.usage should include GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC!");return e.zeroCopy!==!0&&(o=this.copyBuffer(o)),a.resource=o,fn().makeTensorFromDataId(i,n,r,this)}readToGPU(e){const n=this.tensorMap.get(e),{values:r,dtype:o,shape:i,resource:a}=n;if(o==="complex64")throw new Error("Does not support reading buffer for complex64 dtype.");if(a==null)throw r!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const u=a,l=u.size,d=u.usage,f=this.bufferManager.acquireBuffer(l,d);this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(a,0,f,0,l),this.submitQueue();const p=this.makeTensorInfo(i,o),h=fn().makeTensorFromTensorInfo(p),g=this.tensorMap.get(p.dataId);return g.resource=f,{tensorRef:h,buffer:f}}bufferSync(e){const n=this.readSync(e.dataId);if(e.dtype==="string")try{const r=n.map(o=>Yn(o));return Xe(e.shape,e.dtype,r)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Xe(e.shape,e.dtype,n)}async time(e){!this.supportTimestampQuery&&!this.hasTimestampQueryWarned&&(console.warn("This device doesn't support timestamp-query extension. Start Chrome browser with flag --enable-dawn-features=allow_unsafe_apis to try it again. Otherwise, zero will be shown for the kernel time when profiling mode is enabled."),this.hasTimestampQueryWarned=!0);const n=this.activeTimers,r=[];let o=!1;this.programTimersStack==null?(this.programTimersStack=r,o=!0):this.activeTimers.push(r),this.activeTimers=r,e();const i=Qn(this.activeTimers.map(d=>d.query)).filter(d=>d!=null),a=Qn(this.activeTimers.map(d=>d.name)).filter(d=>d!=null);this.activeTimers=n,o&&(this.programTimersStack=null);const u={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null},l=await Promise.all(i);return u.kernelMs=Mv(l),u.getExtraProfileInfo=()=>l.map((d,f)=>({name:a[f],ms:d})).map(d=>`${d.name}: ${d.ms}`).join(", "),this.uploadWaitMs=0,this.downloadWaitMs=0,u}makeTensorInfo(e,n,r){return n==="string"&&r!=null&&r.length>0&&wa(r[0])&&(r=r.map(i=>Ar(i))),{dataId:this.write(r,e,n),shape:e,dtype:n}}tensorToBinding(e){if(!e)return null;const r=this.tensorMap.get(e.dataId).resource;return r instanceof GPUBuffer?{buffer:r}:r instanceof GPUTexture?r.createView():r}uploadToGPU(e){const n=this.tensorMap.get(e);if(n.resource!=null)return;const r=yy(n.dtype)*Y(n.shape);let o;const i=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST;if(n.values){if(o=this.bufferManager.acquireBuffer(r,i,!0),o.mapState==="unmapped"){const a=this.bufferManager.acquireBuffer(r,GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC,!0,!1),u=a.getMappedRange();n.dtype==="int32"||n.dtype==="bool"?new Int32Array(u).set(n.values):new Float32Array(u).set(n.values),a.unmap(),this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(a,0,o,0,r),this.stagingPendingDisposal.push(a)}else{const a=o.getMappedRange();n.dtype==="int32"||n.dtype==="bool"?new Int32Array(a).set(n.values):new Float32Array(a).set(n.values),o.unmap()}n.values=null}else o=this.bufferManager.acquireBuffer(r,i);n.resource=o}makeUniforms(e){let n=0,r=0;const o=[];let i=1;e.forEach(l=>{l.data.length===0&&(l.data=[1]);let d;switch(l.data.length){case 1:d=4;break;case 2:d=8;break;case 3:d=16;break;case 4:d=16;break;case 5:d=16;break;case 6:d=16;break;default:re(!1,()=>`Unsupported ${l.data.length}D shape`)}(r===5||r===6)&&(d=16),d>i&&(i=d),n=Math.ceil(n/d)*d,r=l.data.length,o.push(n),n+=l.data.length*4}),n=Math.ceil(n/i)*i;const a=new ArrayBuffer(n);e.forEach((l,d)=>{const f=o[d];l.type==="int32"?new Int32Array(a,f,l.data.length).set(l.data):l.type==="uint32"?new Uint32Array(a,f,l.data.length).set(l.data):new Float32Array(a,f,l.data.length).set(l.data)});const u=this.bufferManager.acquireBuffer(n,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);return this.queue.writeBuffer(u,0,a,0,n),this.uniformPendingDisposal.push(u),{offset:0,size:n,buffer:u}}runWebGPUProgram(e,n,r,o,i){if(i||(i=this.makeTensorInfo(e.outputShape,r)),Y(i.shape)===0)return this.tensorMap.get(i.dataId).values=qn(i.dtype,0),i;this.uploadToGPU(i.dataId),e.dispatch=RE(this.device,e);const a=n.map((l,d)=>{if(l.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");return this.uploadToGPU(l.dataId),{dtype:this.tensorMap.get(l.dataId).dtype,shape:l.shape,name:e.variableNames[d]}});e.shaderKey=mE(e,a,i);const u=V().getBool("WEBGPU_ENGINE_COMPILE_ONLY");return e.shaderKey in this.pipelineCache||(this.pipelineCache[e.shaderKey]=fE(this.device,e,a,i,u)),e.pipeline=this.pipelineCache[e.shaderKey],u||this.recordAndSubmit(e,i,n,o),i}recordAndSubmit(e,n,r,o){if(e.pipeline instanceof Promise)throw new Error("Please call checkCompileCompletionAsync to ensure parallel compilation is done!");let i=[],a=[];const u="int32";if(e.pixelsOpType==null){i.push({type:"float32",data:[NaN]},{type:"float32",data:[1/0]}),a=r.concat(n).map(g=>g.shape);const h="int32";a.map(g=>{i.push({type:h,data:g});const y=Ke(g);i.push({type:h,data:y})})}else{const h=Ke(n.shape);i.push({type:u,data:h})}if(e.size){const h=Y(e.outputShape);i.push({type:u,data:[e.outputComponent?h/e.outputComponent:h]})}o&&(i=[...i,...o]);const l=[this.tensorToBinding(n),...r.map(h=>this.tensorToBinding(h)),this.makeUniforms(i)];r.forEach(h=>{this.commandQueueOwnedIds.add(h.dataId)}),this.commandQueueOwnedIds.add(n.dataId);const d=this.device.createBindGroup({layout:e.pipeline.getBindGroupLayout(0),entries:l.map((h,g)=>({binding:g,resource:h}))}),f=this.activeTimers!=null;this.ensureCommandEncoderReady();const p={};f&&this.supportTimestampQuery?(this.endComputePassEncoder(),this.querySet==null&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.querySetCount})),p.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:0,endOfPassWriteIndex:1},this.computePassEncoder=this.commandEncoder.beginComputePass(p)):this.computePassEncoder||(this.computePassEncoder=this.commandEncoder.beginComputePass(p)),this.computePassEncoder.setPipeline(e.pipeline),this.computePassEncoder.setBindGroup(0,d),this.computePassEncoder.dispatchWorkgroups(e.dispatch[0],e.dispatch[1],e.dispatch[2]),this.dispatchCountInPass++,(f||V().get("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE")<=this.dispatchCountInPass||e.pixelsOpType===Wi.DRAW)&&(this.endComputePassEncoder(),f?this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime()}):this.submitQueue())}async getQueryTime(){if(!this.supportTimestampQuery)return 0;this.queryResolveBuffer==null&&(this.queryResolveBuffer=this.bufferManager.acquireBuffer(this.querySetCount*8,GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST|GPUBufferUsage.QUERY_RESOLVE)),this.commandEncoder.resolveQuerySet(this.querySet,0,this.querySetCount,this.queryResolveBuffer,0);const e=this.bufferManager.acquireBuffer(this.querySetCount*8,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,e,0,this.querySetCount*8),this.submitQueue(),await e.mapAsync(GPUMapMode.READ);const n=new BigUint64Array(e.getMappedRange()),r=Number(n[1]-n[0])/1e6;return e.unmap(),this.bufferManager.releaseBuffer(e),r}shouldExecuteOnCPU(e,n=$E){return V().getBool("WEBGPU_CPU_FORWARD")&&e.every(r=>this.tensorMap.get(r.dataId).resource==null&&Y(r.shape)<n)}numDataIds(){return this.tensorMap.numDataIds()-this.tensorDataPendingDisposal.length}dispose(){this.disposed||(this.querySet!=null&&this.querySet.destroy(),this.bufferManager.dispose(),this.textureManager.dispose(),this.disposed=!0)}}bl.nextDataId=0;/**
 * @license
 * Copyright 2022 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Sw()&&N0("webgpu",async()=>{const t={powerPreference:V().get("WEBGPU_USE_LOW_POWER_GPU")?"low-power":"high-performance"},e=await navigator.gpu.requestAdapter(t),n={},r=[];e.features.has("timestamp-query")&&r.push("timestamp-query"),e.features.has("bgra8unorm-storage")&&r.push(["bgra8unorm-storage"]),n.requiredFeatures=r;const o=e.limits;n.requiredLimits={maxComputeWorkgroupStorageSize:o.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:o.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:o.maxStorageBufferBindingSize,maxBufferSize:o.maxBufferSize,maxComputeWorkgroupSizeX:o.maxComputeWorkgroupSizeX,maxComputeInvocationsPerWorkgroup:o.maxComputeInvocationsPerWorkgroup};const i=await e.requestDevice(n),a="info"in e?e.info:"requestAdapterInfo"in e?await e.requestAdapterInfo():void 0;return new bl(i,a)},3);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Ce;(function(t){t[t.ADD=0]="ADD",t[t.ATAN2=1]="ATAN2",t[t.COMPLEX_MULTIPLY_IMAG=2]="COMPLEX_MULTIPLY_IMAG",t[t.COMPLEX_MULTIPLY_REAL=3]="COMPLEX_MULTIPLY_REAL",t[t.DIV=4]="DIV",t[t.ELU_DER=5]="ELU_DER",t[t.EQUAL=6]="EQUAL",t[t.FLOOR_DIV=7]="FLOOR_DIV",t[t.GREATER=8]="GREATER",t[t.GREATER_EQUAL=9]="GREATER_EQUAL",t[t.LESS=10]="LESS",t[t.LESS_EQUAL=11]="LESS_EQUAL",t[t.LOGICAL_AND=12]="LOGICAL_AND",t[t.LOGICAL_OR=13]="LOGICAL_OR",t[t.MAX=14]="MAX",t[t.MIN=15]="MIN",t[t.MOD=16]="MOD",t[t.MUL=17]="MUL",t[t.NOT_EQUAL=18]="NOT_EQUAL",t[t.POW=19]="POW",t[t.PRELU=20]="PRELU",t[t.SQUARED_DIFFERENCE=21]="SQUARED_DIFFERENCE",t[t.SUB=22]="SUB"})(Ce||(Ce={}));const EE="let resultTemp = a + b;",_E="let resultTemp = atan2(a, b);",PE="let resultTemp = areal * breal - aimag * bimag;",kE="let resultTemp = areal * bimag + aimag * breal;",TE="let resultTemp = a / b;",AE="let resultTemp = select(a * (b + 1.0), a, b >= b - b);",NE=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a == b);
`,OE=`
  let remainder =
      select(a % b, round(a % b), (round(a) == a) & (round(b) == b));
  let quotient = (a - remainder) / b;
  let resultTemp =
      round(select(quotient, quotient - 1, sign(remainder) == -sign(b)));
`,DE=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a > b);
`,FE=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a >= b);
`,LE=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a < b);
`,ME=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a <= b);
`,BE="return f32(a >= 1.0 && b >= 1.0);",UE=`return (vec4<f32>(a >= vec4<f32>(1.0)) *
  vec4<f32>(b >= vec4<f32>(1.0)));`,WE="return f32(a >= 1.0 || b >= 1.0);",VE=`return min(vec4<f32>(a >= vec4<f32>(1.0)) +
  vec4<f32>(b >= vec4<f32>(1.0)), vec4<f32>(1.0));`,zE="let resultTemp = max(a, b);",GE="let resultTemp = min(a, b);",HE=`
  let isNaN = b == 0.;
  var resultTemp = a % b;
  resultTemp = select((resultTemp + b) % b, resultTemp,
      (a < 0. && b < 0.) || (a >= 0. && b > 0.));
`,jE=`
  let isNaN = !vec4<bool>(b);
  var resultTemp = vec4<f32>(a % b);
  if (!((a[0] < 0. && b[0] < 0.) || (a[0] >= 0. && b[0] > 0.))) {
    resultTemp[0] = (resultTemp[0] + b[0]) % b[0];
  }
  if (!((a[1] < 0. && b[1] < 0.) || (a[1] >= 0. && b[1] > 0.))) {
    resultTemp[1] = (resultTemp[1] + b[1]) % b[1];
  }
  if (!((a[2] < 0. && b[2] < 0.) || (a[2] >= 0. && b[2] > 0.))) {
    resultTemp[2] = (resultTemp[2] + b[2]) % b[2];
  }
  if (!((a[3] < 0. && b[3] < 0.) || (a[3] >= 0. && b[3] > 0.))) {
    resultTemp[3] = (resultTemp[3] + b[3]) % b[3];
  }
`,XE="let resultTemp = a * b;",qE=`
  var resultTemp = f32(a != b);
  let valueForNaN = 1.0;
`,KE=`
  var resultTemp = vec4<f32>(a != b);
  let valueForNaN = 1.0;
`,YE=`
  let isNaN = a < 0.0 && floor(b) < b;
  if (b == 0.0) {
    return 1.0;
  }
  var resultTemp = select(sign(a) * pow(abs(a), b), pow(abs(a), b),
      round(abs(b) % 2.0) != 1.0);
`,QE=`
  let isModRound1Bool = vec4<i32>(round(abs(b) % vec4<f32>(2.0))) == vec4<i32>(1);
  let isModRound1 = vec4<f32>(isModRound1Bool);
  let multiplier = sign(a) * isModRound1 + (vec4<f32>(1.0) - isModRound1);
  var resultTemp = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  let isExpZero = b == vec4<f32>(0.0);
  if (isExpZero.r) {
    resultTemp.r = 1.0;
  }
  if (isExpZero.g) {
    resultTemp.g = 1.0;
  }
  if (isExpZero.b) {
    resultTemp.b = 1.0;
  }
  if (isExpZero.a) {
    resultTemp.a = 1.0;
  }
  let isNaN = (a < vec4<f32>(0.0)) & (floor(b) < b);
`,ZE="if (a < 0.0) { return b * a; }  return a;",JE=`
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (b * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
`,e_="let resultTemp = (a - b) * (a - b);",t_="let resultTemp = a - b;";function Fp(t,e){let n;do{switch(t){case Ce.ATAN2:n=_E;break;case Ce.MAX:n=zE;break;case Ce.MIN:n=GE;break;case Ce.MOD:n=e?jE:HE;break;case Ce.NOT_EQUAL:n=e?KE:qE;break;case Ce.POW:n=e?QE:YE;break;default:continue}let r,o,i;return e?(r="isnanVec4",o="vec4<f32>",i="vec4<bool>"):(r="isnan",o="f32",i="bool"),`
      let aIsNaN = ${r}(a);
      let aPostLegalization = select(a, ${o}(42), aIsNaN);
      let bIsNaN = ${r}(b);
      let bPostLegalization = select(b, ${o}(42), bIsNaN);
      let isNaN = false;
      let valueForNaN = uniforms.NAN;
      {
        let a = aPostLegalization;
        let b = bPostLegalization;
        ${n}
        return select(
            resultTemp, ${o}(valueForNaN),
            ${i}(isNaN) | aIsNaN | bIsNaN);
      }
    `}while(!1);switch(t){case Ce.ADD:n=EE;break;case Ce.COMPLEX_MULTIPLY_IMAG:n=kE;break;case Ce.COMPLEX_MULTIPLY_REAL:n=PE;break;case Ce.DIV:n=TE;break;case Ce.ELU_DER:n=AE;break;case Ce.EQUAL:n=NE;break;case Ce.FLOOR_DIV:n=OE;break;case Ce.GREATER:n=DE;break;case Ce.GREATER_EQUAL:n=FE;break;case Ce.LESS:n=LE;break;case Ce.LESS_EQUAL:n=ME;break;case Ce.LOGICAL_AND:return e?UE:BE;case Ce.LOGICAL_OR:return e?VE:WE;case Ce.MUL:n=XE;break;case Ce.PRELU:return e?JE:ZE;case Ce.SQUARED_DIFFERENCE:n=e_;break;case Ce.SUB:n=t_;break}return`
    ${n}
    return resultTemp;
  `}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var ie;(function(t){t[t.ABS=0]="ABS",t[t.ACOS=1]="ACOS",t[t.ACOSH=2]="ACOSH",t[t.ASIN=3]="ASIN",t[t.ASINH=4]="ASINH",t[t.ATAN=5]="ATAN",t[t.ATANH=6]="ATANH",t[t.CEIL=7]="CEIL",t[t.COS=8]="COS",t[t.COSH=9]="COSH",t[t.ELU=10]="ELU",t[t.ERF=11]="ERF",t[t.EXP=12]="EXP",t[t.EXPM1=13]="EXPM1",t[t.FLOOR=14]="FLOOR",t[t.IS_FINITE=15]="IS_FINITE",t[t.IS_INF=16]="IS_INF",t[t.IS_NAN=17]="IS_NAN",t[t.LINEAR=18]="LINEAR",t[t.LOG=19]="LOG",t[t.LOG1P=20]="LOG1P",t[t.LOGICAL_NOT=21]="LOGICAL_NOT",t[t.NEG=22]="NEG",t[t.RELU=23]="RELU",t[t.RELU6=24]="RELU6",t[t.LEAKYRELU=25]="LEAKYRELU",t[t.RECIPROCAL=26]="RECIPROCAL",t[t.ROUND=27]="ROUND",t[t.RSQRT=28]="RSQRT",t[t.SELU=29]="SELU",t[t.SIGMOID=30]="SIGMOID",t[t.SIGN=31]="SIGN",t[t.SIN=32]="SIN",t[t.SINH=33]="SINH",t[t.SOFTPLUS=34]="SOFTPLUS",t[t.SQRT=35]="SQRT",t[t.SQUARE=36]="SQUARE",t[t.STEP=37]="STEP",t[t.TAN=38]="TAN",t[t.TANH=39]="TANH",t[t.TO_INT=40]="TO_INT"})(ie||(ie={}));const n_="return abs(a);",r_=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  return acos(a);
`,o_=`
  if (a < 1.) {
    return uniforms.NAN;
  }
  return acosh(a);
`,i_=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  return asin(a);
`,s_="return asinh(a);",a_=`
  if (isnan(a)) {
    return uniforms.NAN;
  }
  return atan(a);
`,u_=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  if (a == 1.) {
    return uniforms.INFINITY;
  }
  if (a == -1.) {
    return -uniforms.INFINITY;
  }
  return atanh(a);
`,l_="return ceil(a);",c_="return cos(a);",d_=`
  let e2x = exp(-a);
  return (e2x + 1.0 / e2x) / 2.0;
`,f_="return exp(a) - 1.0;",p_="if (a >= 0.0) { return a; }  return (exp(a) - 1.0);",h_=`
  var resFloat = exp(a) - vec4<f32>(1.0);
  if (a.r >= 0.0) {
    resFloat.r = a.r;
  }
  if (a.g >= 0.0) {
    resFloat.g = a.g;
  }
  if (a.b >= 0.0) {
    resFloat.b = a.b;
  }
  if (a.a >= 0.0) {
    resFloat.a = a.a;
  }
  return resFloat;
`,m_=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  let p = ${Sp};
  let a1 = ${bp};
  let a2 = ${Ip};
  let a3 = ${$p};
  let a4 = ${Rp};
  let a5 = ${Ep};

  let sign = sign(a);
  let absA = abs(a);
  let t = 1.0 / (1.0 + p * absA);
  return sign * (1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * exp(-absA * absA));
`,g_="return exp(a);",y_="return floor(a);",x_="return f32(!isnan(a) && !isinf(a));",v_="return f32(isinf(a));",C_="return f32(isnan(a));",w_="return a;",S_=`if (a < 0.0) { return uniforms.NAN; }
  return log(a);`,b_=`
  if (isnan(a)) { return a; }
  return log(1.0 + a);
`,I_="return f32(!(a >= 1.0));",$_="return -a;",R_="if (a < 0.0) { return uniforms.alpha * a; } return a;",E_=`
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (uniforms.alpha * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
`,__="return 1.0 / a;",P_="return select(a, 0.0, a < 0.0);",k_="return clamp(a, 0.0, 6.0);",T_="return clamp(a, vec4<f32>(0.0, 0.0, 0.0, 0.0), vec4<f32>(6.0, 6.0, 6.0, 6.0));",A_=`
  return select(a, vec4<f32>(0.0), a < vec4<f32>(0.0));
`,N_="return round(a);",O_="return inverseSqrt(a);",D_=`
  if (a >= 0.0) {
    return ${wp} * a;
  } else {
    return ${Cp} * (exp(a) - 1.0);
  }
`,F_="return 1.0 / (1.0 + exp(-1.0 * a));",L_="return sign(a);",M_="return sin(a);",B_=`
  let e2x = exp(a);
  return (e2x - 1.0 / e2x) / 2.0;
`,U_=`
  let epsilon = 1.1920928955078125e-7;
  let threshold = log(epsilon) + 2.0;

  let too_large = a > -threshold;
  let too_small = a < threshold;
  let exp_a = exp(a);

  if (too_large) {
    return a;
  } else if (too_small) {
    return exp_a;
  } else {
    return log(exp_a + 1.0);
  }
`,W_="return sqrt(a);",V_="return a * a;",z_=`
  if (isnan(a)) {
    return a;
  }

  return select(uniforms.stepAlpha, 1.0, a > 0.0);
`,G_="return tan(a);",H_=`
  let e2x = exp(-2.0 * abs(a));
  return sign(a) * (1.0 - e2x) / (1.0 + e2x);
`,j_="return f32(i32((a)));";function Eo(t,e){switch(t){case ie.ABS:return n_;case ie.ACOS:return r_;case ie.ACOSH:return o_;case ie.ASIN:return i_;case ie.ASINH:return s_;case ie.ATAN:return a_;case ie.ATANH:return u_;case ie.COS:return c_;case ie.COSH:return d_;case ie.CEIL:return l_;case ie.ELU:return e?h_:p_;case ie.ERF:return m_;case ie.EXP:return g_;case ie.EXPM1:return f_;case ie.FLOOR:return y_;case ie.IS_FINITE:return x_;case ie.IS_INF:return v_;case ie.IS_NAN:return C_;case ie.LINEAR:return w_;case ie.LOG:return S_;case ie.LOG1P:return b_;case ie.LOGICAL_NOT:return I_;case ie.NEG:return $_;case ie.LEAKYRELU:return e?E_:R_;case ie.RECIPROCAL:return __;case ie.RELU:return e?A_:P_;case ie.RELU6:return e?T_:k_;case ie.ROUND:return N_;case ie.RSQRT:return O_;case ie.SELU:return D_;case ie.SIGMOID:return F_;case ie.SIGN:return L_;case ie.SIN:return M_;case ie.SINH:return B_;case ie.SOFTPLUS:return U_;case ie.SQRT:return W_;case ie.SQUARE:return V_;case ie.STEP:return z_;case ie.TAN:return G_;case ie.TANH:return H_;case ie.TO_INT:return j_;default:throw new Error(`BinaryType ${t} is not implemented!`)}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jn(t,e=!1,n=!1,r=3){if(t===null)return"";let o="";if(t==="linear")o=Eo(ie.LINEAR);else if(t==="relu")o=Eo(ie.RELU,n);else if(t==="elu")o=Eo(ie.ELU,n);else if(t==="relu6")o=Eo(ie.RELU6,n);else if(t==="prelu")o=Fp(Ce.PRELU,n);else if(t==="sigmoid")o=Eo(ie.SIGMOID,n);else if(t==="leakyrelu")o=Eo(ie.LEAKYRELU,n);else throw new Error(`Activation ${t} has not been implemented for the WebGPU backend.`);const a=_e(n?4:1);let u="";return e?u=`
      fn activation(a : ${a}, coords : vec${r}<i32>) -> ${a} {
        let b = getPreluActivationWeightsByOutputCoords(coords);
        ${o}
      }`:u=`
      fn activation(a : ${a}, coords : vec${r}<i32>) -> ${a} {
        ${o}
      }`,u}function Vo(t,e){return`
      ${t?"value = value + getBiasByOutputCoords(coords);":""}
      ${e?"value = activation(value, coords);":""}
      `}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Iw(t,e,n=!1,r=!1,o=!1,i=1){re(t&&i===1||!t,()=>`transposeA ${t} is not compatible with component size ${i}`);const a=`
      ${t?"value = getA(batch, col, row);":"value = getA(batch, row, col);"}

    `,u=e?"value = getB(batch, col, row);":"value = getB(batch, row, col);";return`
  fn mm_readA(batch: i32, row: i32, col: i32) -> ${_e(i)} {
    var value = ${_e(i)}(0.0);
    ${n&&o?a:`
    ${t?"if(row < uniforms.dimAOuter && col < uniforms.dimInner)":"if(row < uniforms.aShape[1] && col < uniforms.aShape[2])"}
    {
      ${a}
    }
    `}
    return value;
  }

  fn mm_readB(batch: i32, row: i32, col: i32) -> ${_e(i)} {
    var value = ${_e(i)}(0.0);
    ${u}
    return value;
  }
  `}function Lp(t,e,n,r,o=!1,i=!1,a=!1,u=1){return`
  ${Iw(n,r,o,i,a,u)}
  fn mm_write(batch: i32, row: i32, col: i32, valueIn: ${_e(u)}) {
    ${o&&i?"":"if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)"}
    {
      var value = valueIn;
      let coords = vec3<i32>(batch, row, col);
      ${Vo(t,e)}
      setOutputAtCoords(coords[0], coords[1], coords[2], value);
    }
  }
  `}const X_=(t,e)=>t?`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          kStart + inputRow,
          globalRowStart + inputCol * ${e});
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          globalRow + innerRow,
          kStart + inputCol * ${e});
        `,q_=(t,e,n,r)=>{if(t)return`
      for (var k = 0; k < ${r}; k++) {
        let BCached0 = mm_Bsub[k][tileCol];
        let ACached0 = mm_Asub[k][localRow];
        for (var i = 0; i < ${n}; i++) {
          acc[i] = fma(BCached0, vec4<f32>(ACached0[i]), acc[i]);
        }
      }`;{let o="",i="";for(let a=0;a<e;a++)o+=`let BCached${a} = mm_Bsub[k * ${e} + ${a}][tileCol];`,i+=`acc[i] = fma(BCached${a}, vec4<f32>(ACached[${a}]), acc[i]);`;return`
      for (var k = 0; k < ${r/e}; k++) {
        ${o}
        for (var i = 0; i < ${n}; i++) {
          let ACached = mm_Asub[tileRow + i][k];
          ${i}
        }
      }`}};function Il(t,e,n=!1,r=32,o=!1,i=32,a=!1){const u=e[1]*t[1],l=e[0]*t[0],d=n?u:r,f=n?r:u,p=d/e[0],h=r/e[1],g=t[1],y=t[0];return re((n&&p===4&&t[1]===4||!n&&(p===3||p===4))&&d%e[0]===0&&r%e[1]===0&&t[0]===4,()=>`If transposeA ${n} is true, innerElementSize ${p} and workPerThread[1] ${t[1]} must be 4.
          Otherwise, innerElementSize ${p} must be 3 or 4.
      tileAWidth ${d} must be divisible by workgroupSize[0]${e[0]}. tileInner ${r} must be divisible by workgroupSize[1] ${e[1]}. colPerThread ${t[0]} must be 4.`),`
  var<workgroup> mm_Asub : array<array<vec${p}<f32>, ${d/p}>, ${f}>;
  var<workgroup> mm_Bsub : array<array<vec4<f32>, ${l/t[0]}>, ${r}>;

  ${se()} {
    let localRow = i32(localId.y);
    let tileRow = localRow * ${g};
    let tileCol = i32(localId.x);

    let globalRow = i32(globalId.y) * ${g};
    let globalCol = i32(globalId.x) * ${y};
    let batch = ${o?"0":"i32(globalId.z)"};
    let batchA = ${o||!a?"batch":"batch % uniforms.aShape[0]"};
    let batchB = ${o||!a?"batch":"batch % uniforms.bShape[0]"};
    let globalRowStart = i32(workgroupId.y) * ${u};

    let numTiles = ${o?`${Math.ceil(i/r)}`:`(uniforms.dimInner - 1) / ${r} + 1`};
    var kStart = ${o?`i32(globalId.z) * ${i}`:"0"};

    var acc: array<vec4<f32>, ${g}>;

    // Loop over shared dimension.
    let tileRowB = localRow * ${h};
    for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        for (var innerRow = 0; innerRow < ${g}; innerRow++) {
            let inputRow = tileRow + innerRow;
            let inputCol = tileCol;
            ${X_(n,p)}
        }

        // Load one tile of B into local memory.
        for (var innerRow = 0; innerRow < ${h}; innerRow++) {
            let inputRow = tileRowB + innerRow;
            let inputCol = tileCol;
            mm_Bsub[inputRow][inputCol] = mm_readB(batchB, kStart + inputRow, globalCol);
        }
        kStart = kStart + ${r};
        workgroupBarrier();

        // Compute acc values for a single thread.
        ${q_(n,p,g,r)}
        workgroupBarrier();
    }

    for (var innerRow = 0; innerRow < ${g}; innerRow++) {
        mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
    }
  }`}const xy=t=>t?`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          kStart + inputRow,
          globalRowStart + inputCol);
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          globalRowStart + inputRow,
          kStart + inputCol);
        `,K_=t=>t?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];";function $l(t,e,n=!1,r=32,o=!1,i=32,a=!1,u=!1){const l=t[1]*e[1],d=t[0]*e[0],f=n?l:r,p=n?r:l;re(p%e[1]===0&&f%e[0]===0&&r%e[1]===0,()=>`tileAHight ${p} must be divisible by workgroupSize[1]${e[1]}, tileAWidth ${f} must be divisible by workgroupSize[0]${e[0]}, tileInner ${r} must be divisible by workgroupSize[1]${e[1]}`);const h=p/e[1],g=f/e[0],y=r/e[1],x=t[1],v=t[0],w=a?`
      let localRow = i32(localId.y);
      let localCol = i32(localId.x);
      let globalRowStart = i32(workgroupId.y) * ${l};
      let globalColStart = i32(workgroupId.x) * ${d};

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        for (var inputRow = localRow; inputRow < ${p}; inputRow = inputRow + ${e[1]}) {
          for (var inputCol = localCol; inputCol < ${f}; inputCol = inputCol + ${e[0]}) {
            ${xy(n)}
          }
        }
        // Load one tile of B into local memory.
        for (var inputRow = localRow; inputRow < ${r}; inputRow = inputRow + ${e[1]}) {
              for (var inputCol = localCol; inputCol < ${d}; inputCol = inputCol + ${e[0]}) {
            mm_Bsub[inputRow][inputCol] = mm_readB(batchB,
              kStart + inputRow,
              globalColStart + inputCol);
          }
        }
        kStart = kStart + ${r};
        workgroupBarrier();

        // Compute acc values for a single thread.
        var BCached : array<f32, ${v}>;
        for (var k = 0; k < ${r}; k++) {
          for (var inner = 0; inner < ${v}; inner++) {
            BCached[inner] = mm_Bsub[k][localCol + inner * ${e[0]}];
          }
          for (var innerRow = 0; innerRow < ${x}; innerRow++) {
            let ACached = ${n?`mm_Asub[k][localRow + innerRow * ${e[1]}];`:`mm_Asub[localRow + innerRow * ${e[1]}][k];`}
            for (var innerCol = 0; innerCol < ${v}; innerCol++) {
              acc[innerRow][innerCol] =
                  fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);
            }
          }
        }
        workgroupBarrier();
      }
      for (var innerRow = 0; innerRow < ${x}; innerRow++) {
        let gRow = globalRowStart + localRow + innerRow * ${e[1]};
        for (var innerCol = 0; innerCol < ${v}; innerCol++) {
          let gCol = globalColStart + localCol + innerCol * ${e[0]};
          mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
        }
      }
      `:`
  let tileRow = i32(localId.y) * ${x};
  let tileCol = i32(localId.x) * ${v};

  let globalRow = i32(globalId.y) * ${x};
  let globalCol = i32(globalId.x) * ${v};
  let globalRowStart = i32(workgroupId.y) * ${l};

  let tileRowA = i32(localId.y) * ${h};
  let tileColA = i32(localId.x) * ${g};
  let tileRowB = i32(localId.y) * ${y};
  // Loop over shared dimension.
  for (var t = 0; t < numTiles; t++) {
    // Load one tile of A into local memory.
    for (var innerRow = 0; innerRow < ${h}; innerRow++) {
      for (var innerCol = 0; innerCol < ${g}; innerCol++) {
        let inputRow = tileRowA + innerRow;
        let inputCol = tileColA + innerCol;
        ${xy(n)}
      }
    }

    // Load one tile of B into local memory.
    for (var innerRow = 0; innerRow < ${y}; innerRow++) {
      for (var innerCol = 0; innerCol < ${v}; innerCol++) {
        let inputRow = tileRowB + innerRow;
        let inputCol = tileCol + innerCol;
        mm_Bsub[inputRow][inputCol] = mm_readB(batchB,
          kStart + inputRow,
          globalCol + innerCol);
      }
    }
    kStart = kStart + ${r};
    workgroupBarrier();

    // Compute acc values for a single thread.
    var BCached : array<f32, ${v}>;
    for (var k = 0; k < ${r}; k++) {
      for (var inner = 0; inner < ${v}; inner++) {
        BCached[inner] = mm_Bsub[k][tileCol + inner];
      }

      for (var innerRow = 0; innerRow < ${x}; innerRow++) {
        ${K_(n)}
        for (var innerCol = 0; innerCol < ${v}; innerCol++) {
          acc[innerRow][innerCol] =
              fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);
        }
      }
    }

    workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < ${x}; innerRow++) {
    for (var innerCol = 0; innerCol < ${v}; innerCol++) {
      mm_write(batch, globalRow + innerRow, globalCol + innerCol,
          acc[innerRow][innerCol]);
    }
  }
  `;return`
    var<workgroup> mm_Asub : array<array<f32, ${f}>, ${p}>;
    var<workgroup> mm_Bsub : array<array<f32, ${d}>, ${r}>;

    ${se()} {
      let batch = ${o?"0":"i32(globalId.z)"};
      let batchA = ${o||!u?"batch":"batch % uniforms.aShape[0]"};
      let batchB = ${o||!u?"batch":"batch % uniforms.bShape[0]"};
      let numTiles = ${o?`${Math.ceil(i/r)}`:`(uniforms.dimInner - 1) / ${r} + 1`};
      var kStart = ${o?`i32(globalId.z) * ${i}`:"0"};

      var acc : array<array<f32, ${v}>, ${x}>;

      // Without this initialization strange values show up in acc.
      for (var innerRow = 0; innerRow < ${x}; innerRow++) {
        for (var innerCol = 0; innerCol < ${v}; innerCol++) {
          acc[innerRow][innerCol] = 0.0;
        }
      }
      ${w}
    }
  `}const Y_=t=>t?`
      mm_readA(batchA, colA, globalRow),
      mm_readA(batchA, colA + 1, globalRow),
      mm_readA(batchA, colA + 2, globalRow),
      mm_readA(batchA, colA + 3, globalRow)
  `:`
      mm_readA(batchA, globalRow, colA),
      mm_readA(batchA, globalRow, colA + 1),
      mm_readA(batchA, globalRow, colA + 2),
      mm_readA(batchA, globalRow, colA + 3)
  `;function Q_(t,e=!1){re(t[1]===1&&t[2]===1,()=>`A linear work group size is required. But got ${t}.`);const n=t[0]*4;return`
    var<workgroup> mm_Asub : array<vec4<f32>, ${t[0]}>;

    ${se()} {
      let tileCol = i32(localId.x);
      let globalCol = i32(globalId.x);
      let globalRow = i32(globalId.y);

      let numTiles = (uniforms.dimInner - 1) / ${n} + 1;
      let batch = i32(globalId.z);
      let batchA = batch % uniforms.aShape[0];
      let batchB = batch % uniforms.bShape[0];
      // Without this initialization strange values show up in acc.
      var acc = 0.0;

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        let colA = t * ${n} + tileCol * 4;
        mm_Asub[tileCol] = vec4<f32>(${Y_(e)});
        workgroupBarrier();

        // Compute acc values for a single thread.
        for (var k = 0; k < ${n/4}; k++) {
          let rowB = t * ${n} + k * 4;
          let BCached = vec4<f32>(mm_readB(batchB, rowB, globalCol),
                              mm_readB(batchB, rowB + 1, globalCol),
                              mm_readB(batchB, rowB + 2, globalCol),
                              mm_readB(batchB, rowB + 3, globalCol));

          let ACached = mm_Asub[k];
          acc = acc + dot(ACached, BCached);
        }

        workgroupBarrier();
      }

      mm_write(batch, globalRow, globalCol, acc);
    }
  `}let Z_=class{constructor(e,n,r=!1,o=!1,i=null,a=null,u=null,l=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=n,this.dispatchLayout={x:[2],y:[1],z:[0]};const d=r?e[1]:e[2];if(this.isVec4=(d%4===0&&!r||n[1]%4===0&&r)&&n[2]%4===0&&!o,this.outputComponent=this.isVec4?4:1,this.isVectorA=n[1]===1&&!r,!this.isVec4&&this.isVectorA)this.elementsPerThread=[1,1,1],this.workgroupSize=[32,1,1];else{const h=IE(n[1],d,n[2],r);this.workgroupSize=h.workgroupSize,this.elementsPerThread=h.elementsPerThread}this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread);const f=i!=null,p=u!=null;f&&this.variableNames.push("bias"),p&&this.variableNames.push("preluActivationWeights"),this.sequentialAccessByThreads=l,this.transposeA=r,this.transposeB=o,this.addBias=f,this.activation=a,this.hasPreluActivationWeights=p,[this.fitAOuter,this.fitBOuter,this.fitInner]=this.getShapeFit(n[1],n[2],d),this.shaderKey=`matMulPacked_${this.elementsPerThread}_${r}_${o}_${this.activation}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.isVectorA}_${this.sequentialAccessByThreads}`}getShapeFit(e,n,r){const o=this.workgroupSize[1]*this.elementsPerThread[1],i=this.workgroupSize[0]*this.elementsPerThread[0];!this.isVec4&&this.isVectorA?this.tileInner=this.workgroupSize[0]*4:this.tileInner=i;const a=e%o===0,u=n%i===0,l=r%this.tileInner===0;return[a,u,l]}getUserCode(){return`
      ${Jn(this.activation,this.hasPreluActivationWeights,this.isVec4)}
      ${Lp(this.addBias,this.activation,!1,this.transposeB,this.fitAOuter,this.fitBOuter,this.fitInner,this.isVec4?4:1)}
      ${this.isVec4?Il(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,!0):this.isVectorA?Q_(this.workgroupSize,this.transposeA):$l(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,this.sequentialAccessByThreads,!0)}
    `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J_(t){return`
    var<workgroup> sumValues : array<f32, ${t}>;
    ${se()} {
      let coords = getOutputCoords();
      let batch = coords[0];
      let batchA = batch % uniforms.aShape[0];
      let batchB = batch % uniforms.bShape[0];
      let row = coords[1];
      let col = coords[2];
      var sum = 0.0;
      let Length = uniforms.dimInner;
      for (var k = i32(localId.x); k < Length; k = k + ${t}) {
        let dataA = mm_readA(batchA, row, k);
        let dataB = mm_readB(batchB, k, col);
        sum = sum + dataA * dataB;
      }
      sumValues[localId.x] = sum;
      workgroupBarrier();

      for(var currentSize = ${t/2}u; currentSize > 1u;
          currentSize = currentSize / 2u) {
        if (localId.x < currentSize)
        {
          sumValues[localId.x] = sumValues[localId.x] + sumValues[localId.x + currentSize];
        }
        workgroupBarrier();
      }

      if (localId.x == 0u) {
        sum = sumValues[0] + sumValues[1];
        mm_write(batch, row, col, sum);
      }
    }
  `}class eP{constructor(e,n=!1,r=!1,o=null,i=null,a=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout={x:[],y:[1,2],z:[0]},this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize);const u=o!=null,l=a!=null;u&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),this.transposeA=n,this.transposeB=r,this.addBias=u,this.activation=i,this.hasPreluActivationWeights=l,this.shaderKey=`matMulReduce_${this.activation}_${n}_${r}`}getUserCode(){return`
      ${Jn(this.activation,this.hasPreluActivationWeights)}
      ${Lp(this.addBias,this.activation,this.transposeA,this.transposeB)}
      ${J_(this.workgroupSize[0])}
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tP(t){const e=t[1],n=t[0],r=e>n?e:n;return`
  var<workgroup> mm_Asub : array<array<f32, ${r}>, ${e}>;
  var<workgroup> mm_Bsub : array<array<f32, ${n}>, ${r}>;

  // If the output size is small for matrix multiplication, avoid to use vec4
  // and handle some elements per thread to optimally utilize the ALU.
  // Read data from global memory to registers firstly, then store them into
  // shared memory, so it is instruction-Level parallelism for arithmetic
  // operations and others handle IO operations between barrier api, makes ALU
  // and load/store units work simultaneously, could improves the performance.
  ${se()} {
    let tileRow = i32(localId.y);
    let tileCol = i32(localId.x);
    let globalRow = i32(globalId.y);
    let globalCol = i32(globalId.x);
    let batch = i32(globalId.z);
    let batchA = batch % uniforms.aShape[0];
    let batchB = batch % uniforms.bShape[0];

    // uniforms.dimInner should be greater than 0.
    let numTiles = (uniforms.dimInner - 1) / ${r} + 1;
    var acc = 0.0;

    var globalColA = tileCol;
    var globalRowB = 0;
    var regA = mm_readA(batchA, globalRow, globalColA);
    var regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);
    var regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);
    globalColA = globalColA + ${r};
    globalRowB = globalRowB + ${r};

    for (var t = 0; t < numTiles; t = t + 1) {
      mm_Asub[tileRow][tileCol] = regA;
      mm_Bsub[2 * tileRow][tileCol] = regB0;
      mm_Bsub[2 * tileRow + 1][tileCol] = regB1;

      workgroupBarrier();

      regA = mm_readA(batchA, globalRow, globalColA);
      regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);
      regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);
      globalColA = globalColA + ${r};
      globalRowB = globalRowB + ${r};

      for (var k = 0; k < ${r}; k = k + 1) {
        acc = acc + mm_Asub[tileRow][k] * mm_Bsub[k][tileCol];
      }
      workgroupBarrier();
    }

    mm_write(batch, globalRow, globalCol, acc);
  }
  `}class nP{constructor(e,n,r,o=!1,i=!1,a=null,u=null,l=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[16,8,1],this.outputShape=r,this.dispatchLayout={x:[2],y:[1],z:[0]},this.dispatch=[Math.ceil(r[2]/this.workgroupSize[0]),Math.ceil(r[1]/this.workgroupSize[1]),r[0]];const d=a!=null;d&&this.variableNames.push("bias");const f=l!=null;f&&this.variableNames.push("preluActivationWeights"),this.transposeA=o,this.transposeB=i,this.addBias=d,this.activation=u,this.hasPreluActivationWeights=f,this.shaderKey=`matMulSmallOutputSize_${this.activation}_${o}_${i}`}getUserCode(){return`
      ${Jn(this.activation,this.hasPreluActivationWeights)}
      ${Lp(this.addBias,this.activation,this.transposeA,this.transposeB)}
      ${tP(this.workgroupSize)}
    `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rP{constructor(e,n,r=!1,o=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[8,8,1],this.atomic=!0,this.splitedDimInner=128,re(e[0]===1,()=>"MatMulSplitKProgram only supports batch = 1."),this.outputShape=e,this.dispatchLayout={x:[2],y:[1],z:[0,3]};const i=(r&&this.outputShape[1]%4===0||!r&&n%4===0)&&this.outputShape[2]%4===0;this.elementsPerThread=[4,4,this.splitedDimInner],this.outputComponent=i?4:1,i||(this.outputShape[1]<16&&(this.elementsPerThread[1]=1),this.outputShape[2]<16&&(this.elementsPerThread[0]=1)),this.dispatch=ae(this.dispatchLayout,[this.outputShape[0],this.outputShape[1],this.outputShape[2],n],this.workgroupSize,this.elementsPerThread),this.transposeA=r,this.transposeB=o,this.shaderKey=`matMulSplitK_${r}_${o}_${this.elementsPerThread}_${this.outputComponent}`}getUserCode(){const e=this.outputComponent;return`
      ${Iw(!1,this.transposeB,!1,!1,!1,e)}
      fn mm_write(batch: i32, row : i32, col : i32, value : ${_e(e)}) {
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
          let coords = vec3<i32>(batch, row, col);
          let flatIndex = getOutputIndexFromCoords(coords);
          // The problem is that we should initialize output to zero before using.
          // Otherwise, the original value will be added to the result.
          for (var i = 0; i < ${e}; i = i + 1) {
            ${Lr("&result[flatIndex + i]",`${e>1?"value[i]":"value"}`,"float32")}
          }
        }
      }
      ${e===4?Il(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner):$l(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner)}
    `}}class oP{constructor(e,n=null,r=null,o=null){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=ce(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=n!=null,this.hasPreluActivationWeights=o!=null,this.activation=r,this.addBias&&this.variableNames.push("bias"),this.hasPreluActivationWeights&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`biasActivation_${r}`}getUserCode(){return`
    ${Jn(this.activation,this.hasPreluActivationWeights)}
    ${se("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        var value = getXByOutputIndex(index);
        ${Vo(this.addBias,this.activation)}
        setOutputAtIndex(index, value);
      }
    }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let iP=class{constructor(e){this.variableNames=[],this.outputShape=[],this.uniforms="value : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=ce(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="fill"}getUserCode(){return`
    ${se("index")} {
      if (index < uniforms.size) {
        setOutputAtIndex(index, uniforms.value);
      }
    }
  `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $t(t){const{backend:e,attrs:n}=t,{shape:r,value:o}=n;let{dtype:i}=n;if(i=i||Gi(o),i==="string"){const a=nt(i,Y(r));return a.fill(o),e.makeTensorInfo(r,i,a)}else{const a=new iP(r),u=[{type:"float32",data:[o]}];return e.runWebGPUProgram(a,[],i,u)}}const sP={kernelName:Uf,backendName:"webgpu",kernelFunc:$t};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pe(t){const{inputs:e,attrs:n}=t,{x:r}=e,{shape:o}=n,i=Y(r.shape),a=Bv(o,i),u=Y(a);return re(i===u,()=>`The new shape (${a}) has ${u} elements and the old shape (${r.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`),t.backend.incRef(r.dataId),{dataId:r.dataId,shape:a,dtype:r.dtype}}const aP={kernelName:qf,backendName:"webgpu",kernelFunc:pe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rl({a:t,b:e,transposeA:n,transposeB:r,backend:o,bias:i=null,preluActivationWeights:a=null,leakyreluAlpha:u=0,activation:l=null}){const d=t.shape.length,f=e.shape.length,p=n?t.shape[d-2]:t.shape[d-1],h=r?e.shape[f-1]:e.shape[f-2],g=n?t.shape[d-1]:t.shape[d-2],y=r?e.shape[f-2]:e.shape[f-1],x=t.shape.slice(0,-2),v=e.shape.slice(0,-2),w=Y(x),S=Y(v),E=He(t.shape.slice(0,-2),e.shape.slice(0,-2)).concat([g,y]);re(p===h,()=>`Error in matMul: inner shapes (${p}) and (${h}) of Tensors with shapes ${t.shape} and ${e.shape} and transposeA=${n} and transposeB=${r} must match.`);const R=n?[w,p,g]:[w,g,p],T=r?[S,y,h]:[S,h,y],k=pe({inputs:{x:t},backend:o,attrs:{shape:R}}),D=pe({inputs:{x:e},backend:o,attrs:{shape:T}}),N=[k,D],O=Math.max(w,S),_=[k,D],F=[{type:"int32",data:[g]},{type:"int32",data:[y]},{type:"int32",data:[p]}];let U,G;const j=[O,g,y];let Z=V().get("WEBGPU_MATMUL_PROGRAM_TYPE");if(Z<0){const X=V().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),ne=X>0?X:o.thresholdToIncreaseWorkgroups,Q=O*Math.ceil(g/32)*Math.ceil(y/32);Q<=ne||g<=8&&Q<=ne*2?O*g*y<=128?Z=kn.MatMulReduceProgram:O===1&&h>=2e3?Z=kn.MatMulSplitKProgram:Z=kn.MatMulSmallOutputSizeProgram:Z=kn.MatMulPackedProgram}switch(Z){case kn.MatMulReduceProgram:U=new eP(j,n,r,i,l,a);break;case kn.MatMulSplitKProgram:{if(G=$t({backend:o,attrs:{shape:j,value:0,dtype:t.dtype}}),U=new rP(j,h,n,r),i||l){G=o.runWebGPUProgram(U,_,t.dtype,F,G);const ne=new oP(G.shape,i,l,a);let Q=null;const H=[G];i&&H.push(i),a&&H.push(a),l==="leakyrelu"&&(Q=[{type:"float32",data:[u]}],ne.uniforms+=" alpha : f32,");const K=o.runWebGPUProgram(ne,H,G.dtype,Q);N.push(G);const J=pe({inputs:{x:K},backend:o,attrs:{shape:E}});N.push(K);for(const ge of N)o.disposeData(ge.dataId);return J}break}case kn.MatMulSmallOutputSizeProgram:U=new nP(R,T,j,n,r,i,l,a);break;case kn.MatMulPackedProgram:const X=o.adapterInfo.isIntel();U=new Z_(R,j,n,r,i,l,a,X);break;default:throw new Error(`Unsupported MatMulProgramType ${Z}.`)}i&&_.push(i),a&&_.push(a),l==="leakyrelu"&&(F.push({type:"float32",data:[u]}),U.uniforms+=" alpha : f32,"),G=o.runWebGPUProgram(U,_,t.dtype,F,G);const L=pe({inputs:{x:G},backend:o,attrs:{shape:E}});N.push(G);for(const X of N)o.disposeData(X.dataId);return L}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uP(t){const{inputs:e,backend:n,attrs:r}=t,{a:o,b:i,bias:a,preluActivationWeights:u}=e,{transposeA:l,transposeB:d,activation:f,leakyreluAlpha:p}=r;return Rl({a:o,b:i,transposeA:l,transposeB:d,backend:n,bias:a,preluActivationWeights:u,leakyreluAlpha:p,activation:f})}const lP={kernelName:p0,backendName:"webgpu",kernelFunc:uP};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let vy=class{constructor(e,n,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.workgroupSize=[128,1,1],this.size=!0,this.outputShape=He(n,r),this.dispatchLayout=ce(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`binaryOpComplex_${e}`,this.op=e}getUserCode(){return`
      fn binaryOpComplex(
          areal : f32, aimag : f32, breal : f32, bimag : f32) -> f32 {
        ${Fp(this.op,!1)}
      }

      ${se("index")} {
        if(index < uniforms.size) {
          let areal = getARealByOutputIndex(index);
          let aimag = getAImagByOutputIndex(index);
          let breal = getBRealByOutputIndex(index);
          let bimag = getBImagByOutputIndex(index);
          setOutputAtIndex(index, binaryOpComplex(areal, aimag, breal, bimag));
        }
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ul=class{constructor(e,n,r){if(this.size=!0,this.variableNames=["A","B"],this.outputShape=He(n,r),this.dispatchLayout=ce(this.outputShape),this.op=e,this.useSharedMemoryWithA=n.length<=1&&r.length>1&&n[0]<128,this.useSharedMemoryWithB=r.length<=1&&n.length>1&&r[0]<128,this.useSharedMemoryWithA||this.useSharedMemoryWithB)this.outputComponent=1,this.variableComponents=[1,1],this.lastDimensionSize=this.useSharedMemoryWithB?r[0]:n[0],this.shaderKey=`binary_${e}_${this.lastDimensionSize}`,this.type="shared",this.workgroupSize=[256,1,1];else{const o=n.length>0&&n[n.length-1]%4===0,i=r.length>0&&r[r.length-1]%4===0;o&&i?(this.outputComponent=4,this.variableComponents=[4,4]):o&&(zg(r)||r[r.length-1]===1)||i&&(zg(n)||n[n.length-1]===1)?(this.outputComponent=4,this.variableComponents=o?[4,1]:[1,4]):(this.outputComponent=1,this.variableComponents=[1,1]),this.type="nonshared",this.shaderKey=`binary_${e}_${this.variableComponents}`,this.workgroupSize=[128,1,1]}this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.outputComponent,1,1])}getUserCode(){let e;const n=this.outputComponent===4?"vec4<f32>":"f32",r=`
    fn binaryOperation(a : ${n}, b : ${n}) -> ${n} {
      ${Fp(this.op,this.outputComponent===4)}
    };
    `;if(this.type==="shared"){const o=this.lastDimensionSize>1?`coords[${this.outputShape.length-1}]`:"0",i=this.useSharedMemoryWithB?`let a = getAByOutputIndex(index);
          let b = sharedBuf[${o}];`:`let a = sharedBuf[${o}];
          let b = getBByOutputIndex(index);`;e=`
        ${r}
        var<workgroup> sharedBuf : array<f32, ${this.lastDimensionSize}>;
        ${se("index")} {
          // Fill in the shared memory buffer.
          let localIndex = i32(localId.x);
          if(localIndex < ${this.lastDimensionSize}) {
            sharedBuf[localIndex] = f32(${this.useSharedMemoryWithB?"B":"A"}[localIndex]);
          }
          workgroupBarrier();

          if(index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            ${i}
            setOutputAtIndex(index, binaryOperation(a, b));
          }
        }
        `}else e=`
       ${r}
       ${se("index")} {
         if (index < uniforms.size) {
           let coords = getCoordsFromIndex(index * ${this.outputComponent});
           let a = ${n}(getAByOutputCoords(coords));
           let b = ${n}(getBByOutputCoords(coords));
           setOutputAtIndex(index, binaryOperation(a, b));
         }
       }
       `;return e}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ot(t){const{inputs:e}=t,{x:n}=e;return t.backend.incRef(n.dataId),{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}const cP={kernelName:xl,backendName:"webgpu",kernelFunc:Ot};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zo(t){const{inputs:e,backend:n}=t,{real:r,imag:o}=e,i=n.makeTensorInfo(r.shape,"complex64"),a=n.tensorMap.get(i.dataId),u=Ot({inputs:{x:r},backend:n}),l=Ot({inputs:{x:o},backend:n});return a.complexTensorInfos={real:u,imag:l},i}const dP={kernelName:Ff,backendName:"webgpu",kernelFunc:zo};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ji=class{constructor(e,n,r=""){this.variableNames=["A"],this.size=!0;const o=128;this.workgroupSize=[o,1,1],this.outputShape=e,this.dispatchLayout=ce(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize),this.op=n,r!==""&&(this.uniforms=r),this.shaderKey=`unary_${n}`}getUserCode(){return`
      fn unaryOperation(a : f32) -> f32 {
        ${Eo(this.op,!1)}
      }
      ${se("index")} {
        if (index < uniforms.size) {
          let a = getAByOutputIndex(index);
          setOutputAtIndex(index, unaryOperation(a));
        }
      }
      `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Te({opType:t,cpuKernelImpl:e,dtype:n}){return({inputs:r,backend:o})=>{const{x:i}=r,a=o,u=n||i.dtype;if(a.shouldExecuteOnCPU([i])&&e!=null){const d=a.tensorMap.get(i.dataId),f=e(d.values,u);return a.makeTensorInfo(i.shape,u,f)}const l=new ji(i.shape,t);return a.runWebGPUProgram(l,[i],u)}}function st({opType:t,cpuKernelImpl:e,supportsComplex:n=!1,dtype:r}){return({inputs:o,backend:i})=>{const{a,b:u}=o,l=i;if(n&&a.dtype==="complex64"){const p=l.tensorMap.get(a.dataId),h=l.tensorMap.get(u.dataId);let g,y;if(t!==Ce.MUL)[g,y]=[[p.complexTensorInfos.real,h.complexTensorInfos.real],[p.complexTensorInfos.imag,h.complexTensorInfos.imag]].map(v=>{const[w,S]=v,I={dataId:w.dataId,dtype:w.dtype,shape:a.shape},E={dataId:S.dataId,dtype:S.dtype,shape:u.shape},R=new ul(t,a.shape,u.shape);return l.runWebGPUProgram(R,[I,E],Rt(w.dtype,S.dtype))});else{const v=new vy(Ce.COMPLEX_MULTIPLY_REAL,a.shape,u.shape),w=new vy(Ce.COMPLEX_MULTIPLY_IMAG,a.shape,u.shape),S=[{dataId:p.complexTensorInfos.real.dataId,dtype:p.complexTensorInfos.real.dtype,shape:a.shape},{dataId:p.complexTensorInfos.imag.dataId,dtype:p.complexTensorInfos.imag.dtype,shape:a.shape},{dataId:h.complexTensorInfos.real.dataId,dtype:h.complexTensorInfos.real.dtype,shape:u.shape},{dataId:h.complexTensorInfos.imag.dataId,dtype:h.complexTensorInfos.imag.dtype,shape:u.shape}];g=l.runWebGPUProgram(v,S,"float32"),y=l.runWebGPUProgram(w,S,"float32")}const x=zo({inputs:{real:g,imag:y},backend:l});return l.disposeData(g.dataId),l.disposeData(y.dataId),x}const d=r||Rt(a.dtype,u.dtype);if((a.dtype==="string"||u.dtype==="string"||l.shouldExecuteOnCPU([a,u]))&&e!=null){const p=l.tensorMap.get(a.dataId).values,h=l.tensorMap.get(u.dataId).values,g=a.dtype==="string"?Or(p):p,y=a.dtype==="string"?Or(h):h,[x,v]=e(a.shape,u.shape,g,y,d);return l.makeTensorInfo(v,d,x)}const f=new ul(t,a.shape,u.shape);return l.runWebGPUProgram(f,[a,u],d)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fP(t){const e=new Float32Array(t.length);for(let n=0;n<t.length;++n)e[n]=Math.abs(t[n]);return e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _t(t){return(e,n,r,o,i)=>{const a=He(e,n),u=a.length,l=Ke(a),d=Y(a),f=qn(i,d),p=e.length,h=n.length,g=Ke(e),y=Ke(n),x=Bi(e,a),v=Bi(n,a);if(x.length+v.length===0)for(let w=0;w<f.length;++w)f[w]=t(r[w%r.length],o[w%o.length]);else for(let w=0;w<f.length;++w){const S=Af(w,u,l),I=S.slice(-p);x.forEach(k=>I[k]=0);const E=of(I,p,g),R=S.slice(-h);v.forEach(k=>R[k]=0);const T=of(R,h,y);f[w]=t(r[E],o[T])}return[f,a]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pP(t,e,n,r){if(r==="int32"){const o=Int32Array.from(t);return[e,"int32",o]}if(r==="bool"){const o=Cl([0],n),[i,a]=_t((u,l)=>u!==l?1:0)(e,[],t,o,"bool");return[a,"bool",i]}throw new Error(`Error in Cast: failed to cast ${n} to ${r}`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hP=_t((t,e)=>t+e);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mP(t,e,n,r,o){const i=Y(r),a=Kn(o,n);for(let u=0;u<t.length;u++){const l=t[u];if(l<0)throw new Error("Input x must be non-negative!");l>=o||(i>0?a[l]+=e[u]:a[l]+=1)}return a}function gP(t,e,n,r=!1){const o=t.shape[0],i=t.shape[1],a=Xe([o,n],e.dtype);for(let u=0;u<o;u++)for(let l=0;l<i;l++){const d=t.get(u,l);if(d<0)throw new Error("Input x must be non-negative!");d>=n||(r?a.set(1,u,d):e.size>0?a.set(a.get(u,d)+e.get(u,l),u,d):a.set(a.get(u,d)+1,u,d))}return a}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yP=_t((t,e)=>t&e);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function er(t){return(e,n,r)=>{const o=nt(n,e.length);for(let i=0;i<e.length;++i)o[i]=t(e[i],r);return o}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xP=er(t=>Math.ceil(t));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vP(t,e,n,r){const o=nt(n,Y(e));if(r&&n!=="string"){let i=0;t.forEach(a=>{const u=Y(a.shape);o.set(a.vals,i),i+=u})}else{let i=0;t.forEach(a=>{const u=n==="string"?Or(a.vals):a.vals;let l=0;for(let d=0;d<a.shape[0];++d){const f=d*e[1]+i;for(let p=0;p<a.shape[1];++p)o[f+p]=u[l++]}i+=a.shape[1]})}return o}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CP=_t((t,e)=>t===e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wP=er(t=>Math.exp(t));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SP=er(t=>Math.expm1(t));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bP=er(t=>Math.floor(t));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IP=_t((t,e)=>Math.floor(t/e));/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $P(t,e,n,r,o,i,a,u,l){const d=Xe([r,i],n);for(let f=0;f<r;f++){const p=[];let h=0;for(let g=0;g<o;g++){const y=t[f*o+g];h+=y*a[g],p.push(y)}if(h<0||h>=l/i)throw new Error(`Invalid indices: ${p} does not index into ${u}`);for(let g=0;g<i;g++)d.values[f*i+g]=e.get(...e.indexToLoc(h*i+g))}return d}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RP(t,e,n){const r=Xe(n,t.dtype);for(let o=0;o<r.size;++o){const a=r.indexToLoc(o).slice(),u=a[0],l=a[2],d=e.locToIndex([u,l]);a[2]=e.values[d];const f=t.locToIndex(a);0<=f&&f<t.values.length&&(r.values[o]=t.values[f])}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EP=_t((t,e)=>t>e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _P=_t((t,e)=>t>=e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PP=_t((t,e)=>t<e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kP=_t((t,e)=>t<=e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TP(t,e,n){const r=(e-t)/(n-1),o=Kn(n,"float32");o[0]=t;for(let i=1;i<o.length;i++)o[i]=o[i-1]+r;return o}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AP=er(t=>Math.log(t));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NP(t,e,n,r){const o=qn(r,Y(n));for(let i=0;i<o.length;++i){const a=i*e;let u=t[a];for(let l=0;l<e;++l){const d=t[a+l];(Number.isNaN(d)||d>u)&&(u=d)}o[i]=u}return o}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OP=_t((t,e)=>Math.max(t,e));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DP=_t((t,e)=>Math.min(t,e));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $w=_t((t,e)=>t*e);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FP(t,e,n){const r=Hi(-1,n);return $w([],e,r,t,n)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LP=_t((t,e)=>t!==e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MP(t,e,n,r,o){const i=e.length,a=Y(e),u=Ke(e),l=Ke(o),d=qn(n,Y(o));for(let f=0;f<a;++f){const p=Af(f,i,u),h=new Array(p.length);for(let y=0;y<h.length;y++)h[y]=p[r[y]];const g=of(h,i,l);d[g]=t[f]}return d}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BP(t,e,n,r){const[o,i]=Ht(t,r),a=Rt(e,"int32"),u=Kn(Y(o),a),l=Y(i);for(let d=0;d<u.length;++d){const f=d*l;let p=1;for(let h=0;h<l;++h)p*=n[f+h];u[d]=p}return{outVals:u,outShape:o,outDtype:a}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UP(t,e,n){t.forEach((r,o)=>{if(r<0||r>=n){const i=Af(o,e.length,Ke(e)).join(",");throw new Error(`indices[${i}] = ${r} is not in [0, ${n})`)}})}function WP(t,e){for(let n=0;n<t.length;++n){const r=t[n],o=n===t.length-1?e:t[n+1].length;if(r.length===0)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>o)throw new Error("Ragged splits must not point past values");for(let i=1;i<r.length;++i)if(r[i-1]>r[i])throw new Error("Ragged splits must be sorted in ascending order")}}function VP(t,e,n,r){const o=[];let i=0;const a=e.length-1+n.length,u=new Array(a).fill(null).map(()=>[0]);WP(n,r);let l=1;for(let d=0;d<e.length-1;++d){l*=e[d];const f=e[d+1];for(let p=1;p<l+1;++p)u[d].push(p*f)}for(let d=0;d<t.length;++d){let f=t[d],p=t[d]+1;for(let h=0;h<n.length;++h){const g=n[h],y=h+e.length-1;if(y>=0){const x=u[y],v=x[x.length-1]-g[f];for(let w=f;w<p;++w)u[y].push(g[w+1]+v)}f=g[f],p=g[p]}p!==f&&(o.push([f,p]),i+=p-f)}return{outSplits:u,valueSlices:o,numValues:i}}function zP(t){const e=[];for(let n=0;n<t.length;++n){const r=t[n].length,o=nt("int32",r);e.push(o),t[n].forEach((i,a)=>o[a]=i)}return e}function Cy(t,e){const n=t.slice(0,e);for(;n.length<e;)n.push(1);for(let r=e;r<t.length;r++)n[e-1]*=t[r];return n}function GP(t,e,n,r,o,i){const a=Cy(e,2)[1],u=Cy(i,2)[1];let l=0;for(const d of n)for(let f=d[0];f<d[1];++f){for(let p=0;p<r;++p)o[l*u+p]=t[f*a+p];++l}}function HP(t,e,n,r,o){const i=e.slice();i[0]=o;const a=nt(n,Y(i)),u=t.length,l=u===0?0:u/e[0];return GP(t,e,r,l,a,i),[a,i]}function jP(t,e,n,r,o,i,a,u){if(t.length===0)throw new Error("paramsNestedSplits must be non empty");if(e[0].length===0)throw new Error("Split tensors must not be scalars");const l=e[0][0]-1;if(UP(i,a,l),r.length===0)throw new Error("params.rank must be nonzero");const d=r[0],{outSplits:f,valueSlices:p,numValues:h}=VP(i,a,t,d),g=zP(f),y=HP(n,r,o,p,h);return[g,y[0],y[1]]}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wy=2147483647;function XP(t,e,n,r,o,i,a){if(e.length>1)throw new Error("starts must be a scalar or vector");if(o.length>1)throw new Error("limits must be a scalar or vector");if(a.length>1)throw new Error("deltas must be a scalar or vector");const u=e.length===0,l=o.length===0,d=a.length===0,f=[];u||f.push(e[0]),l||f.push(o[0]),d||f.push(a[0]);for(let v=1;v<f.length;++v)if(f[v]!==f[v-1])throw new Error("starts, limits, and deltas must have the same shape");const p=f.length===0?1:f[0],h=nt("int32",p+1);h[0]=0;for(let v=0;v<p;++v){const w=u?t[0]:t[v],S=l?r[0]:r[v],I=d?i[0]:i[v];if(I===0)throw new Error("Requires delta != 0");let E;if(I>0&&S<w||I<0&&S>w)E=0;else if(E=Math.ceil(Math.abs((S-w)/I)),E>wy)throw new Error(`Requires ((limit - start) / delta) <= ${wy}`);h[v+1]=h[v]+E}const g=h[p],y=nt(n,g);let x=0;for(let v=0;v<p;++v){const w=h[v+1]-h[v];let S=u?t[0]:t[v];const I=d?i[0]:i[v];for(let E=0;E<w;++E)y[x++]=S,S+=I}return[h,y]}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Zt=gn;class ll{constructor(e,n,r,o,i,a,u,l,d,f){this.shape=e,this.shapeShape=n,this.values=r,this.valuesShape=o,this.valuesDType=i,this.defaultValue=a,this.defaultValueShape=u,this.rowPartitionValues=l,this.rowPartitionValuesShapes=d,this.rowPartitionTypes=rw(f),this.raggedRank=ow(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===Zt.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===Zt.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const n=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case Zt.VALUE_ROWIDS:return ll.getMaxWidthValueRowID(n);case Zt.ROW_SPLITS:return ll.getMaxWidthRowSplit(n);default:throw new Error(`Cannot handle partition type ${Zt[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){const n=e.length;if(n===0||n===1)return 0;let r=0;for(let o=0;o<n-1;++o){const i=e[o+1]-e[o];i>r&&(r=i)}return r}static getMaxWidthValueRowID(e){const n=e.length;if(n===0)return 0;let r=0,o=e[0],i=0;for(let a=1;a<n;++a){const u=e[a];u!==o&&(o=u,i=Math.max(a-r,i),r=a)}return Math.max(n-r,i)}tensorShapeFromTensor(e,n,r=!0){if(n.length===0){if(e[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return by(e,r)}calculateOutputSize(e){const n=this.valuesShape,r=this.defaultValueShape;iw(r,n);const o=this.tensorShapeFromTensor(this.shape,this.shapeShape),a=nw(this.raggedRank,o,n);a[0]<0&&(a[0]=e);for(let u=1;u<=this.raggedRank;++u)a[u]<0&&(a[u]=this.getMaxWidth(u));return a}calculateFirstParentOutputIndex(e,n,r){const o=Math.min(e,r),i=[];let a=0;for(let u=0;u<o;++u,a+=n)i.push(a);for(let u=o;u<e;++u)i.push(-1);return re(i.length===e,()=>"Final length of result must be equal to firstDimension."),i}calculateOutputIndexRowSplit(e,n,r,o){const i=e.length,a=[];for(let u=0;u<i-1;++u){const l=e[u+1]-e[u];let d=Math.min(o,l),f=n[u];f===-1&&(d=0);for(let p=0;p<d;++p)a.push(f),f+=r;for(let p=0;p<l-d;++p)a.push(-1)}if(i>0&&a.length!==e[i-1])throw new Error("Invalid row split size.");return a}calculateOutputIndexValueRowID(e,n,r,o){const i=e.length,a=[];if(i===0)return[];let u=0,l=e[0];if(l>=n.length)throw new Error(`Got currentValueRowId=${l}, which is not less than ${n.length}`);let d=n[l];a.push(d);for(let f=1;f<i;++f){const p=e[f];if(p===l)d>=0&&(++u,u<o?d+=r:d=-1);else{if(u=0,l=p,p>=n.length)throw new Error(`Got nextValueRowId=${p} which is not less than ${n.length}`);d=n[p]}a.push(d)}if(a.length!==e.length)throw new Error("Invalid row ids.");return a}calculateOutputIndex(e,n,r,o){const i=this.getRowPartitionTensor(e),a=this.getRowPartitionTypeByDimension(e);switch(a){case Zt.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(i,n,r,o);case Zt.ROW_SPLITS:if(i.length-1>n.length)throw new Error(`Row partition size is greater than output size: ${i.length-1} > ${n.length}`);return this.calculateOutputIndexRowSplit(i,n,r,o);default:throw new Error(`Unsupported partition type: ${Zt[a]}`)}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const n=this.rowPartitionTypes[0];switch(n){case Zt.FIRST_DIM_SIZE:return e[0];case Zt.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Zt.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${Zt[n]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const n=this.getFirstDimensionSize(),r=this.calculateOutputSize(n),o=new Array(this.raggedRank+1);o[o.length-1]=1;for(let l=o.length-2;l>=0;--l)o[l]=o[l+1]*r[l+1];const i=by(r,!1),a=nt(this.valuesDType,Y(i));if(o[0]*r[0]>0){let l=this.calculateFirstParentOutputIndex(n,o[0],r[0]);for(let d=1;d<=this.raggedRank;++d)l=this.calculateOutputIndex(d-1,l,o[d],r[d]);this.setOutput(this.raggedRank,l,a,i)}return[i,a]}setOutput(e,n,r,o){if(r.length===0)return;const i=this.values,a=r;let u=o.slice();u=u.slice(e+1);const l=Y(u),d=n.length;let f=this.defaultValue;if(f.length!==l&&f.length!==1){const y=this.defaultValueShape;tt(()=>{const x=ip(f,y);f=q$(x,u).dataSync()})}let p=0,h=0,g=0;for(let y=0;y<=d;++y){let x=y<d?n[y]:-1;if(x===g){++g;continue}if(h<g){const v=i.subarray(p*l),w=a.subarray(h*l),S=(g-h)*l;Sy(w,v,S)}if(y>=d){const v=r.length;x=Math.floor(v/l)}if(x>g)if(this.defaultValue.length===1)a.subarray(g*l,x*l).fill(this.defaultValue[0]),g=x;else for(;x>g;){const v=a.slice(g*l);Sy(v,f,l),++g}x<0?(p=y+1,h=g):(p=y,h=g,g=h+1)}}}function Sy(t,e,n){for(let r=0;r<n;r++)t[r]=e[r]}function by(t,e){const n=[];for(let r of t){if(r<0){if(!e)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}n.push(r)}return n}function qP(t,e,n,r,o,i,a,u,l,d){return new ll(t,e,n,r,o,i,a,u,l,d).compute()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KP(t,e,n,r){const o=t===e,i=t<e&&n<0,a=e<t&&n>1;if(o||i||a)return Kn(0,r);const u=Math.abs(Math.ceil((e-t)/n)),l=Kn(u,r);e<t&&n===1&&(n=-1),l[0]=t;for(let d=1;d<l.length;d++)l[d]=l[d-1]+n;return l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YP=er(t=>1/Math.sqrt(t));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QP(t,e,n,r,o,i,a,u,l,d){const f=[r/o,o],p=t.values,h=e.values;if(r===0)return Xe(n,e.dtype);const g=l instanceof ol?l:Xe(f,e.dtype);typeof l=="string"||typeof l=="number"?g.values.fill(l):typeof l=="boolean"&&g.values.fill(+l);for(let y=0;y<i;y++){const x=[];let v=0;for(let w=0;w<a;w++){const S=p[y*a+w];x.push(S),v+=S*u[w]}if(v<0||v>=r/o)throw new Error(`Invalid indices: ${x} does not index into ${n}`);for(let w=0;w<o;w++)d?g.values[v*o+w]+=h[y*o+w]:g.values[v*o+w]=e.rank===0?h[0]:h[y*o+w]}return g}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZP=er(t=>1/(1+Math.exp(-t)));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JP(t,e,n,r,o){const i=dp(r,e,n),a=Y(n),u=Ke(r);if(i){const p=fp(e,u);return o==="string"?t.slice(p,p+a):t.subarray(p,p+a)}const l=o==="string"?Or(t):t,d=Xe(r,o,l),f=Xe(n,o);for(let p=0;p<f.size;++p){const h=f.indexToLoc(p),g=h.map((y,x)=>y+e[x]);f.set(d.get(...g),...h)}return o==="string"?xw(f.values):f.values}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ek(t,e,n,r,o,i,a){const u=e[0],l=i[0],d=new Array(l),f=new Array(u),p=e[1];if(l===0){if(u!==0)throw new Error(sw(u));const v=nt(n,0),w=nt(o,0);return[v,[0,p],w,d,f]}let h=!0,g=0;const y=new Array(l).fill(0);for(let v=0;v<u;++v){const w=t[v*p];if(w<0)throw new Error(aw(v,w));if(w>=l)throw new Error(uw(v,w,l));++y[w],h=h&&w>=g,g=w}let x=!0;for(let v=0;v<l;++v){const w=y[v]===0;d[v]=w,x=x&&!w,y[v]=Math.max(y[v],1),v>0&&(y[v]+=y[v-1])}if(x&&h){const v=t,w=r;for(let S=0;S<u;++S)f[S]=S;return[v,[u,p],w,d,f]}else{const v=y[l-1],w=nt(n,v*p),S=nt(o,v),I=new Array(l).fill(0);for(let E=0;E<u;++E){const R=t[E*p],T=I[R],k=(R===0?0:y[R-1])+T;I[R]++;for(let D=0;D<p;++D)w[k*p+D]=t[E*p+D];S[k]=r[E],f[E]=k}for(let E=0;E<l;++E)if(I[E]===0){const T=E===0?0:y[E-1];w[T*p+0]=E;for(let k=1;k<p;++k)w[T*p+k]=0;S[T]=a}return[w,[v,p],S,d,f]}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tk(t,e,n,r,o){const i=Y(r),a=e[0],u=o.length,l=[];let d=1,f=-1;for(let v=0;v<u;++v){const w=o[v];if(w===-1){if(f!==-1)throw new Error(lw(f,v));f=v,l.push(1)}else{if(w<0)throw new Error(cw(v,w));d*=w,l.push(w)}}if(f!==-1){if(d<=0)throw new Error(dw());const v=Math.trunc(i/d);if(d*v!==i)throw new Error(fw(r,l));l[f]=v}if(Y(l)!==i)throw new Error(pw(r,l));const h=r.length,g=[];if(h>0){g[h-1]=1;for(let v=h-2;v>=0;--v)g[v]=g[v+1]*r[v+1]}const y=[];if(u>0){y[u-1]=1;for(let v=u-2;v>=0;--v)y[v]=y[v+1]*l[v+1]}const x=nt(n,a*u);for(let v=0;v<a;++v){let w=0;for(let S=0;S<h;++S)w+=t[v*h+S]*g[S];for(let S=0;S<u;++S)x[v*u+S]=Math.trunc(w/y[S]),w%=y[S]}return[x,[a,u],l]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nk(t,e,n,r,o,i=!1,a=0){const u=r.length,l=[e[0],t.length/e[0]],d=l[1],p=u>0?o[u-1]+1:0;if(p<0)throw new Error(yf());const h=e.slice();h[0]=p;const g=h.reduce((I,E)=>I*E,1),y=nt(n,g);if(u===0)return p>0&&y.fill(a),[y,h];if(p<=0)throw new Error(yf());let x=0,v=1,w=0,S=o[x];for(;;){let I=0;if(v<u){if(I=o[v],S===I){++v;continue}if(S>=I)throw new Error(hw())}if(S<0||S>=p)throw new Error(mw(S,p));S>w&&y.fill(a,w*d,S*d);for(let E=x;E<v;++E){const R=r[E];if(R<0||R>=l[0])throw new Error(gw(E,r[E],l[0]));for(let T=0;T<d;T++)y[S*d+T]+=t[R*d+T]}if(i)for(let E=0;E<d;E++)y[S*d+E]/=v-x;if(x=v,++v,w=S+1,S=I,v>u)break}return w<p&&y.fill(a,w*d,p*d),[y,h]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rk=er(t=>Math.sqrt(t));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ok=_t((t,e)=>{const n=t-e;return n*n});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ik=er((t,e)=>{const{pattern:n,replaceGlobal:r,rewrite:o}=e;return t.replace(new RegExp(n,r?"g":""),o)});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sk(t,e,n,r){const o=Xe(t,e.dtype);for(let i=0;i<o.size;i++){const a=o.indexToLoc(i),u=new Array(a.length);for(let l=0;l<u.length;l++)u[l]=a[l]*n[l]+r[l];o.set(e.get(...u),...a)}return o}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ak{constructor(e,n,r,o,i,a){this.separator=Ar(e),this.nGramWidths=n,this.leftPad=Ar(r),this.rightPad=Ar(o),this.padWidth=i,this.preserveShort=a}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,n){const r=this.getPadWidth(n);return Math.max(0,e+2*r-n+1)}createNGrams(e,n,r,o,i,a){for(let u=0;u<i;++u){const l=this.getPadWidth(a),d=Math.max(0,l-u),f=Math.max(0,l-(i-(u+1))),p=a-(d+f),h=n+(d>0?0:u-l);let g=0;g+=d*this.leftPad.length;for(let S=0;S<p;++S)g+=e[h+S].length;g+=f*this.rightPad.length;const y=d+f+p-1;g+=y*this.separator.length,r[o+u]=new Uint8Array(g);const x=r[o+u];let v=0;const w=S=>S.forEach(I=>x[v++]=I);for(let S=0;S<d;++S)w(this.leftPad),w(this.separator);for(let S=0;S<p-1;++S)w(e[h+S]),w(this.separator);if(p>0){w(e[h+p-1]);for(let S=0;S<f;++S)w(this.separator),w(this.rightPad)}else{for(let S=0;S<f-1;++S)w(this.rightPad),w(this.separator);w(this.rightPad)}}}compute(e,n){const r=e.length,o=n.length;if(o>0){let l=n[0];if(l!==0)throw new Error(`First split value must be 0, got ${l}`);for(let d=1;d<o;++d){let f=n[d]>=l;if(f=f&&n[d]<=r,!f)throw new Error(`Invalid split value ${n[d]}, must be in [${l}, ${r}]`);l=n[d]}if(l!==r)throw new Error(`Last split value must be data size. Expected ${r}, got ${l}`)}const i=o-1,a=nt("int32",o);if(r===0||o===0){const l=new Array(r);for(let d=0;d<=i;++d)a[d]=0;return[l,a]}a[0]=0;for(let l=1;l<=i;++l){const d=n[l]-n[l-1];let f=0;this.nGramWidths.forEach(p=>{f+=this.getNumNGrams(d,p)}),this.preserveShort&&d>0&&f===0&&(f=1),a[l]=a[l-1]+f}const u=new Array(a[i]);for(let l=0;l<i;++l){const d=n[l];let f=a[l];if(this.nGramWidths.forEach(p=>{const h=n[l+1]-n[l],g=this.getNumNGrams(h,p);this.createNGrams(e,d,u,f,g,p),f+=g}),this.preserveShort&&f===a[l]){const p=n[l+1]-n[l];if(p===0)continue;const h=p+2*this.padWidth;this.createNGrams(e,d,u,f,1,h)}}return[u,a]}}function uk(t,e,n,r,o,i,a,u){return new ak(n,r,o,i,a,u).compute(t,e)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lk(t,e,n,r){if(!t.length)return;if(e.length===0){for(let i=0;i<t.length;++i)r.push(t.subarray(i,i+1));return}if(e.length===1){const i=e[0];let a=t.indexOf(i);for(;a!==-1;){const u=t.subarray(0,a);(!n||u.length!==0)&&r.push(u),t=t.subarray(a+1),a=t.indexOf(i)}(!n||t.length!==0)&&r.push(t);return}let o=0;for(let i=0;i<t.length+1;i++)if(i===t.length||e.indexOf(t[i])!==-1){const a=t.subarray(o,i);(!n||a.length!==0)&&r.push(a),o=i+1}}function ck(t,e,n){const r=t.length,o=[];let i=0,a=0;const u=new Array(r);for(let h=0;h<r;++h){const g=o.length;lk(t[h],e,n,o);const y=o.length-g;u[h]=y,i+=y,a=Math.max(a,y)}const l=nt("int32",i*2),d=new Array(i),f=[r,a];let p=0;for(let h=0;h<r;++h)for(let g=0;g<u[h];++g)l[p*2]=h,l[p*2+1]=g,d[p]=o[p],++p;return[l,d,f]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dk(t,e){const n=nt("int32",t.length);for(let r=0;r<t.length;++r)n[r]=VI(t[r]).modulo(e).getLowBitsUnsigned();return n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fk=_t((t,e)=>t-e);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pk(t,e){const n=new Array(t.rank);for(let o=0;o<n.length;o++)n[o]=t.shape[o]*e[o];const r=Xe(n,t.dtype);for(let o=0;o<r.values.length;++o){const i=r.indexToLoc(o),a=new Array(t.rank);for(let l=0;l<a.length;l++)a[l]=i[l]%t.shape[l];const u=t.locToIndex(a);r.values[o]=t.values[u]}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aa=(t,e)=>{const n=e.value-t.value;return n===0?t.index-e.index:n};function Rw(t,e,n=0,r=t.length-1){for(;r>n;){if(r-n>600){const u=r-n+1,l=e-n+1,d=Math.log(u),f=.5*Math.exp(2*d/3),p=.5*Math.sqrt(d*f*(u-f)/u)*Math.sign(l-u/2),h=Math.max(n,Math.floor(e-l*f/u+p)),g=Math.min(r,Math.floor(e+(u-l)*f/u+p));Rw(t,e,h,g)}const o=t[e];let i=n,a=r;for(Gs(t,n,e),aa(t[r],o)>0&&Gs(t,n,r);i<a;){for(Gs(t,i,a),i++,a--;aa(t[i],o)<0;)i=i+1;for(;aa(t[a],o)>0;)a=a-1}aa(t[n],o)===0?Gs(t,n,a):(a=a+1,Gs(t,a,r)),a<=e&&(n=a+1),e<=a&&(r=a-1)}}function hk(t,e,n,r,o){const i=e[e.length-1],[a,u]=[t.length/i,i],l=qn(n,a*r),d=qn("int32",a*r);for(let p=0;p<a;p++){const h=p*u,g=t.subarray(h,h+u);let y=new Array(g.length);g.forEach((S,I)=>y[I]={value:S,index:I}),r<y.length&&(Rw(y,r),y=y.slice(0,r)),o&&y.sort(aa);const x=p*r,v=l.subarray(x,x+r),w=d.subarray(x,x+r);for(let S=0;S<r;S++)v[S]=y[S].value,w[S]=y[S].index}const f=e.slice();return f[f.length-1]=r,[Xe(f,n,l),Xe(f,"int32",d)]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mk(t,e,n,r){const o=Je(e,n)[0],i=[1,n[0],1];for(let y=0;y<o;y++)i[0]*=n[y];i[1]=n[o];for(let y=o+1;y<n.length;y++)i[2]*=n[y];const a=new Map,u=new Int32Array(n[o]),l=new ol(i,r,t),d=[],f=i[0]===1&&i[2]===1;for(let y=0;y<n[o];y++){let x;if(f)x=t[y].toString();else{const w=[];for(let S=0;S<i[0];S++)for(let I=0;I<i[2];I++)w.push(l.get(S,y,I));x=w.join(",")}const v=a.get(x);if(v!=null)u[y]=v;else{const w=a.size;a.set(x,w),u[y]=w,d.push(y)}}const p=i.slice();p[1]=a.size;const h=new ol(p,r);d.forEach((y,x)=>{for(let v=0;v<i[0];v++)for(let w=0;w<i[2];w++)h.set(l.get(v,y,w),v,x,w)});const g=n.slice();return g[o]=p[1],{outputValues:h.values,outputShape:g,indices:u}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ew=Object.freeze(Object.defineProperty({__proto__:null,addImpl:hP,bincountImpl:mP,bincountReduceImpl:gP,bitwiseAndImpl:yP,castImpl:pP,ceilImpl:xP,concatImpl:vP,equalImpl:CP,expImpl:wP,expm1Impl:SP,floorDivImpl:IP,floorImpl:bP,gatherNdImpl:$P,gatherV2Impl:RP,greaterEqualImpl:_P,greaterImpl:EP,lessEqualImpl:kP,lessImpl:PP,linSpaceImpl:TP,logImpl:AP,maxImpl:NP,maximumImpl:OP,minimumImpl:DP,multiplyImpl:$w,negImpl:FP,notEqualImpl:LP,prodImpl:BP,raggedGatherImpl:jP,raggedRangeImpl:XP,raggedTensorToTensorImpl:qP,rangeImpl:KP,rsqrtImpl:YP,scatterImpl:QP,sigmoidImpl:ZP,simpleAbsImpl:fP,sliceImpl:JP,sparseFillEmptyRowsImpl:ek,sparseReshapeImpl:tk,sparseSegmentReductionImpl:nk,sqrtImpl:rk,squaredDifferenceImpl:ok,staticRegexReplaceImpl:ik,stridedSliceImpl:sk,stringNGramsImpl:uk,stringSplitImpl:ck,stringToHashBucketFastImpl:dk,subImpl:fk,tileImpl:pk,topKImpl:hk,transposeImpl:MP,uniqueImpl:mk},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:gk,castImpl:yk,ceilImpl:xk,concatImpl:vk,equalImpl:Ck,expImpl:wk,expm1Impl:Sk,floorImpl:bk,floorDivImpl:Ik,gatherNdImpl:$k,gatherV2Impl:Rk,greaterEqualImpl:Ek,greaterImpl:_k,lessEqualImpl:Pk,lessImpl:kk,logImpl:Tk,maxImpl:Ak,maximumImpl:Nk,minimumImpl:Ok,multiplyImpl:Dk,negImpl:Fk,notEqualImpl:Lk,prodImpl:Mk,rangeImpl:Bk,rsqrtImpl:Uk,scatterImpl:Wk,simpleAbsImpl:Vk,sliceImpl:zk,stridedSliceImpl:Gk,stringNGramsImpl:Hk,subImpl:jk,tileImpl:Xk,topKImpl:qk,transposeImpl:Kk}=Ew;/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yk=Te({opType:ie.ABS,cpuKernelImpl:Vk}),Qk={kernelName:Df,backendName:"webgpu",kernelFunc:Yk};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zk=Te({opType:ie.ACOS}),Jk={kernelName:Gv,backendName:"webgpu",kernelFunc:Zk};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eT=Te({opType:ie.ACOSH}),tT={kernelName:Hv,backendName:"webgpu",kernelFunc:eT};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nT=st({opType:Ce.ADD,cpuKernelImpl:gk,supportsComplex:!0}),rT={kernelName:gl,backendName:"webgpu",kernelFunc:nT};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let oT=class{constructor(e){this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e[0],this.variableNames=e.map((n,r)=>`T${r}`),this.dispatchLayout=ce(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="addN"}getUserCode(){const e=[];this.variableNames.forEach(o=>{e.push(`let v${o} = get${o}ByOutputCoords(coords);`)});const n=this.variableNames.map(o=>`v${o}`).join(" + ");return`
      ${se("index")} {
        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if (flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            ${e.join(`
        `)}
            setOutputAtIndex(flatIndex, ${n});
          }
        }
      }
    `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iT(t){const{inputs:e,backend:n}=t,r=e;if(r.length===1)return Ot({inputs:{x:r[0]},backend:n});const o=r.map(u=>u.dtype).reduce((u,l)=>Rt(u,l)),i=r.map(u=>u.shape),a=new oT(i);return n.runWebGPUProgram(a,r,o)}const sT={kernelName:jv,backendName:"webgpu",kernelFunc:iT};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class aT{constructor(e,n){this.variableNames=["A"],this.workgroupSize=[16,16,1];const r=new Array(e.length);for(let o=0;o<r.length;o++)r[o]=e[n[o]];this.outputShape=r,this.dispatchLayout={x:[0],y:[1]},this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize,[1,1,1]),this.shaderKey="transposeShared"}getUserCode(){re(this.workgroupSize[0]===this.workgroupSize[1],()=>`Must be a square tile, current tile shape is ${this.workgroupSize[0]} x ${this.workgroupSize[1]}`);const e=this.workgroupSize[0];return`
      var<workgroup> tile : array<array<f32, ${this.workgroupSize[0]+1}>, ${this.workgroupSize[0]}>;
      ${se()} {
        var x = i32(workgroupId.x) * ${e} + i32(localId.x);
        var y = i32(workgroupId.y) * ${e} + i32(localId.y);
        let width = uniforms.outShape[0];
        let height = uniforms.outShape[1];
        if (x < width && y < height) {
          tile[localId.y][localId.x] = f32(A[y * width + x]);
        }
        workgroupBarrier();

        x = i32(workgroupId.y) * ${e} + i32(localId.x);
        y = i32(workgroupId.x) * ${e} + i32(localId.y);
        if (x < height && y < width) {
          setOutputAtIndex((y * height + x), tile[localId.x]
            [localId.y]);
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let uT=class{constructor(e,n){this.variableNames=["A"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0;const r=new Array(e.length);for(let o=0;o<r.length;o++)r[o]=e[n[o]];this.outputShape=r,this.dispatchLayout=ce(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.newDim=n,this.shaderKey=`transpose_${n}`}getUserCode(){const e=Ze(this.outputShape.length),n=_w(this.newDim);return`
      ${se("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            setOutputAtIndex(flatIndex, A[getIndexFromCoords${this.outputShape.length}D(
              ${e}(${n}), uniforms.aShape)]);
          }
        }
      }
    `}};function _w(t){const e=t.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const n=new Array(e);for(let r=0;r<t.length;r++)n[t[r]]=`coords.${Xn(r)}`;return n.join()}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dn(t){const{inputs:e,backend:n,attrs:r}=t,{x:o}=e,{perm:i}=r,a=n,u=o.shape.length,l=new Array(u);for(let f=0;f<l.length;f++)l[f]=o.shape[i[f]];if(n.shouldExecuteOnCPU([o])){const p=a.tensorMap.get(o.dataId).values,h=Kk(p,o.shape,o.dtype,i,l);return n.makeTensorInfo(l,o.dtype,h)}if(o.shape.length===2&&je(i,[1,0])){const f=new aT(o.shape,i);return a.runWebGPUProgram(f,[o],o.dtype)}const d=new uT(o.shape,i);return a.runWebGPUProgram(d,[o],o.dtype)}const lT={kernelName:u0,backendName:"webgpu",kernelFunc:Dn};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let cT=class{constructor(e,n,r){this.variableNames=["x"],this.uniforms="reduceSize : i32,",this.size=!0,this.inputShape=[e.batchSize,e.inSize];const[o]=Ht(this.inputShape,[1]);this.outputShape=o.length===0?[1]:o,e.inSize>=32768&&r>=512?this.workgroupSize=[512,1,1]:e.inSize>=4096?this.workgroupSize=[256,1,1]:this.workgroupSize=[64,1,1],this.dispatchLayout=ce(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,[1,1,1]),this.reduceType=n,this.shaderKey=`reduce_${n}`}getUserCode(){let e="",n="0.0";const r=this.workgroupSize[0];this.reduceType==="min"||this.reduceType==="max"?(e=`
         if (isnan(candidate)) {
          bestValue = uniforms.NAN;
         } else if (!isnan(bestValue) && candidate ${this.reduceType==="min"?"<":">"} bestValue)
           {  bestValue = candidate; }`,n="f32(x[offset])"):this.reduceType==="sum"||this.reduceType==="mean"?e=" bestValue = bestValue + candidate; ":this.reduceType==="prod"?(e=" bestValue = bestValue * candidate; ",n="1.0"):this.reduceType==="all"?(e=" bestValue = f32(bestValue >= 1.0 && candidate >= 1.0); ",n="1.0"):this.reduceType==="any"&&(e=" bestValue = f32(bestValue >= 1.0 || candidate >= 1.0); ",n="0.0");const o=this.reduceType==="mean"?"setOutputAtIndex(outputIndex, bestValue / f32(uniforms.reduceSize));":"setOutputAtIndex(outputIndex, bestValue);";return`
       fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
       }

       ${`
         var<workgroup> xBestValues : array<f32, ${r}>;
       `}
       fn getOffset(outputIndex : i32) -> i32 {
         let outputCoords = getCoordsFromIndex(outputIndex);
         let offset = ${this.outputShape.length===1?"outputCoords":"outputCoords[0]"} * uniforms.reduceSize;
          return offset;
       }
       ${se("index")} {
         let outputIndex = index / ${r};
         let offset = getOffset(outputIndex);
         var bestValue = ${n};
         let Length = uniforms.reduceSize;
         let WorkPerThread = DIV_CEIL(u32(Length), ${r}u);
         for (var k = i32(localId.x); k < Length && outputIndex < uniforms.size;
             k = k + ${r}) {
           let candidate = f32(x[offset + k]);
           ${e}
         }
         xBestValues[localId.x] = bestValue;
         workgroupBarrier();

         var reduceSize = min(u32(Length), ${r}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            ${e}
            xBestValues[localId.x] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (localId.x == 0u && outputIndex < uniforms.size) {
          ${o}
        }
       }
     `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dT={mean:"float32",all:"bool",any:"bool"};function Go(t,e,n,r,o){const i=t.shape.length,a=[],u=Je(e,t.shape);let l=u;const d=dt(l,i);let f=t;d!=null&&(f=Dn({inputs:{x:t},attrs:{perm:d},backend:o}),l=ft(l.length,i),a.push(f)),Ft(r,l,i);const[p,h]=Ht(f.shape,l);let g=p;n&&(g=Fn(p,u));let y;if((r==="max"||r==="prod")&&o.shouldExecuteOnCPU([f])){const x=o.tensorMap.get(f.dataId).values;switch(r){case"max":const v=Ak(x,Y(h),g,t.dtype);y=o.makeTensorInfo(g,t.dtype,v);break;case"prod":const{outVals:w,outShape:S,outDtype:I}=Mk(f.shape,f.dtype,x,l);y=o.makeTensorInfo(S,I,w);break;default:throw new Error(`${r} CPU implementation is not yet supported.`)}}else{const x=Y(h),w=Y(f.shape)/x,S={windowSize:x,inSize:x,batchSize:w,outSize:1},I=dT[r]||wl(t.dtype),E=[{type:"int32",data:[x]}],R=new cT(S,r,o.device.limits.maxComputeWorkgroupSizeX),T=o.runWebGPUProgram(R,[f],I,E);a.push(T),y=pe({inputs:{x:T},attrs:{shape:g},backend:o})}return a.forEach(x=>o.disposeData(x.dataId)),y}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fT(t){const{inputs:e,backend:n,attrs:r}=t,{x:o}=e,{keepDims:i,axis:a}=r;return Go(o,a,i,"all",n)}const pT={kernelName:Xv,backendName:"webgpu",kernelFunc:fT};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hT(t){const{inputs:e,backend:n,attrs:r}=t,{x:o}=e,{keepDims:i,axis:a}=r;return Go(o,a,i,"any",n)}const mT={kernelName:qv,backendName:"webgpu",kernelFunc:hT};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Pw=class{constructor(e,n,r){this.workgroupSize=[64,1,1],this.variableNames=["x"],this.uniforms="infinityValue : f32,",this.size=!0;const o=[n];this.op=r==="min"?"<":">";const[i,a]=Ht(e,o);this.outputShape=i.length===0?[1]:i,this.dispatchLayout=ce(this.outputShape),Y(a)<32?(this.type="plain",this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize)):(this.type="shared",this.dispatch=ae(this.dispatchLayout,this.outputShape,[1,1,1])),this.inputShape=e,this.shaderKey=`argMinMax_${this.op}_${this.type}`}getUserCode(){const e=this.workgroupSize[0],n=()=>this.inputShape.length===1?"uniforms.xShape":`uniforms.xShape.${Xn(this.inputShape.length-1)}`,r=()=>{let o="";if(this.outputShape.length===1)this.inputShape.length!==1&&(o+="outputCoords,");else for(let i=0;i<this.outputShape.length;i++)o+=`outputCoords.${Xn(i)},`;return o};return this.type==="shared"?`
      fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
      }

      ${`
      var<workgroup> xBestIndices : array<i32, ${e}>;
      var<workgroup> xBestValues : array<f32, ${e}>;
    `}

      ${se("index")} {
        let outputIndex = index / ${e};
        let reduceLength = ${n()};

        var bestIndex = i32(localId.x);
        var bestValue = uniforms.infinityValue;
        let outputCoords = getCoordsFromIndex(outputIndex);
        for (var k = i32(localId.x); k < reduceLength && outputIndex < uniforms.size;
            k = k + ${e}) {
          let candidate = getX(${r()} k);
          if (!isnan(candidate) && candidate ${this.op} bestValue) {
            bestValue = candidate;
            bestIndex = k;
          }
        }
        xBestValues[localId.x] = bestValue;
        xBestIndices[localId.x] = bestIndex;
        workgroupBarrier();

        var reduceSize = min(u32(reduceLength), ${e}u);
        for (var currentSize = reduceSize / 2u; reduceSize > 1u;
            currentSize = reduceSize / 2u) {
          let interval = DIV_CEIL(reduceSize, 2u);
          if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              xBestValues[localId.x] = bestValue;
              xBestIndices[localId.x] = xBestIndices[localId.x + interval];
            }
          }
          reduceSize = interval;
          workgroupBarrier();
        }

        if (localId.x == 0u && outputIndex < uniforms.size) {
          setOutputAtIndexI32(outputIndex, xBestIndices[localId.x]);
        }
      }
    `:`
      ${se("index")} {
        if (index < uniforms.size) {
          let outputCoords = getCoordsFromIndex(index);
          var bestIndex = 0;
          var bestValue = getX(${r()} 0);
          let reduceLength = ${n()};
          for (var i = 1; i < reduceLength; i++) {
            let candidate = getX(${r()} i);
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              bestIndex = i;
            }
          }
          setOutputAtIndexI32(index, bestIndex);
        }
      }
      `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gT(t){const{inputs:e,backend:n,attrs:r}=t,{x:o}=e,{axis:i}=r;let a=Je(i,o.shape);const u=dt(a,o.shape.length);let l=o;const d=[];u!=null&&(l=Dn({inputs:{x:o},backend:n,attrs:{perm:u}}),d.push(l),a=ft(a.length,l.shape.length)),Ft("argMax",[a[0]],l.shape.length);const f=new Pw(l.shape,a[0],"max"),p=[{type:"float32",data:[Number.NEGATIVE_INFINITY]}],h=n.runWebGPUProgram(f,[l],"int32",p);return d.forEach(g=>n.disposeData(g.dataId)),h}const yT={kernelName:Kv,backendName:"webgpu",kernelFunc:gT};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xT(t){const{inputs:e,backend:n,attrs:r}=t,{x:o}=e,{axis:i}=r;let a=Je(i,o.shape);const u=dt(a,o.shape.length);let l=o;const d=[];u!=null&&(l=Dn({inputs:{x:o},backend:n,attrs:{perm:u}}),d.push(l),a=ft(a.length,l.shape.length)),Ft("argMin",[a[0]],l.shape.length);const f=new Pw(l.shape,a[0],"min"),p=[{type:"float32",data:[Number.POSITIVE_INFINITY]}],h=n.runWebGPUProgram(f,[l],"int32",p);return d.forEach(g=>n.disposeData(g.dataId)),h}const vT={kernelName:Yv,backendName:"webgpu",kernelFunc:xT};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CT=Te({opType:ie.ASIN}),wT={kernelName:Qv,backendName:"webgpu",kernelFunc:CT};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ST=Te({opType:ie.ASINH}),bT={kernelName:Zv,backendName:"webgpu",kernelFunc:ST};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IT=Te({opType:ie.ATAN}),$T={kernelName:Jv,backendName:"webgpu",kernelFunc:IT};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RT=st({opType:Ce.ATAN2}),ET={kernelName:tC,backendName:"webgpu",kernelFunc:RT};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _T=Te({opType:ie.ATANH}),PT={kernelName:eC,backendName:"webgpu",kernelFunc:_T};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kT{constructor(e){this.variableNames=["x"],this.uniforms="strides : vec2<i32>,",this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=ce(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="poolWithFilterSizeEqualsOne"}getUserCode(){return`
      ${se("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let d = coords[3];

          let xRCCorner = coords.yz * uniforms.strides;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          let value = getX(batch, xRCorner, xCCorner, d);
          setOutputAtIndex(index, value);
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ma=class{constructor(e,n,r=!1,o=!1,i=!1){if(this.variableNames=["x"],this.uniforms="strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, convDims : vec2<i32>, filterDims : vec2<i32>,",this.workgroupSize=[128,1,1],this.size=!0,n==="avg"&&r)throw new Error("Cannot compute positions for average pool.");this.outputShape=e.outShape,this.dispatchLayout=ce(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize),this.poolType=n,this.computePositions=r,this.flattenPositions=o,this.includeBatchIndex=i,this.shaderKey=`pool2D_${n}_${r}_${o}_${i}`}getUserCode(){let e;this.poolType==="avg"?e="resultValue = resultValue + value; count = count + 1.0;":this.computePositions?e=`let currMaxValue = mix(value, maxValue, maxValueFound);
      if (value >= currMaxValue) {
        maxValue = value;
        maxValueFound = 1.0;
        maxPosition = ${this.flattenPositions?this.includeBatchIndex?"((batch * uniforms.xShape[1] + xR) * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d":"(xR * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d":"wR * uniforms.filterDims.y + wC"};
      }`:e="resultValue = max(value, resultValue);";let n="resultValue";return this.poolType==="avg"&&(n="resultValue / max(count, 1.0)"),`
      ${se("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let d = coords[3];
          let xRCCorner = vec2<i32>(coords.yz) * uniforms.strides - uniforms.pads;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          ${this.computePositions?`var maxValue = 0.0;
            var maxValueFound = 0.0;
            var maxPosition = 0;`:`var resultValue = ${this.poolType==="avg"?"0.0":"-1.0 / pow(10.0, -20.0)"};`}

          var count = 0.0;
          for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + uniforms.dilations.x) {
            let xR = xRCorner + wR;

            if (xR < 0 || xR >= uniforms.convDims.x) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + uniforms.dilations.y) {
              let xC = xCCorner + wC;
              if (xC < 0 || xC >= uniforms.convDims.y) {
                continue;
              }

              let value = getX(batch, xR, xC, d);
              ${e}
            }
          }

          ${this.computePositions?"setOutputAtIndexI32(index, maxPosition);":`setOutputAtIndex(index, ${n});`}
        }
      }
    `}},Mp=class{constructor(e,n,r=!1,o=!1,i=!1){if(this.variableNames=["x"],this.uniforms="strides : vec3<i32>, pads : vec3<i32>, convDims : vec3<i32>, filterDims : vec3<i32>,",this.workgroupSize=[128,1,1],this.size=!0,n==="avg"&&r)throw new Error("Cannot compute positions for average pool.");this.outputShape=e.outShape,this.dispatchLayout=ce(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize),this.poolType=n,this.computePositions=r,this.flattenPositions=o,this.includeBatchIndex=i,this.shaderKey=`pool3D_${n}_${r}_${o}_${i}`}getUserCode(){let e;this.poolType==="avg"?e="resultValue += value; count += 1.0;":this.computePositions?e=`let currMaxValue = mix(value, maxValue, maxValueFound);
      if (value >= currMaxValue) {
        maxValue = value;
        maxValueFound = 1.0;
        maxPosition = ${this.flattenPositions?this.includeBatchIndex?"(((batch * uniforms.xShape.y + xD) * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch":"((xD * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch":"wD * uniforms.filterDims.y * uniforms.filterDims.y + wR * uniforms.filterDims.z + wC"};
      }`:e="resultValue = max(value, resultValue);";let n="resultValue";return this.poolType==="avg"&&(n="resultValue / max(count, 1.0)"),`
      ${se("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let batch = coords.x;
          let ch = coords.u;

          let xCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;
          let xDCorner = xCorner.x;
          let xRCorner = xCorner.y;
          let xCCorner = xCorner.z;

          ${this.computePositions?`var maxValue = 0.0;
            var maxValueFound = 0.0;
            var maxPosition = 0;`:`var resultValue = ${this.poolType==="avg"?"0.0":"-1.0 / pow(10.0, -20.0)"};`}

          var count = 0.0;
          for (var wD = 0; wD < uniforms.filterDims.x; wD++) {
            let xD = xDCorner + wD;
            if (xD < 0 || xD >= uniforms.convDims.x) {
              continue;
            }

            for (var wR = 0; wR < uniforms.filterDims.y; wR++) {
              let xR = xRCorner + wR;
              if (xR < 0 || xR >= uniforms.convDims.y) {
                continue;
              }

              for (var wC = 0; wC < uniforms.filterDims.z; wC++) {
                let xC = xCCorner + wC;
                if (xC < 0 || xC >= uniforms.convDims.z) {
                  continue;
                }

                let value = getX(batch, xD, xR, xC, ch);
                ${e}
              }
            }
          }

          ${this.computePositions?"setOutputAtIndexI32(index, maxPosition);":`setOutputAtIndex(index, ${n});`}
        }
      }
    `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kw(t){const{inputs:e,backend:n,attrs:r}=t,{x:o}=e,{reductionIndices:i,keepDims:a}=r;return Go(o,i,a,"max",n)}const TT={kernelName:a1,backendName:"webgpu",kernelFunc:kw};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tw(t){const{inputs:e,backend:n,attrs:r}=t,{x:o}=e,{keepDims:i,axis:a}=r;return Go(o,a,i,"mean",n)}const AT={kernelName:p1,backendName:"webgpu",kernelFunc:Tw};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Aw(t,e,n,r){if(e.filterWidth===1&&e.filterHeight===1&&je(e.inShape,e.outShape))return Ot({inputs:{x:t},backend:r});if(e.filterWidth===e.inWidth&&e.filterHeight===e.inHeight&&e.batchSize===1&&e.padInfo.type==="VALID"){const a=t.shape.length,u=pe({inputs:{x:t},backend:r,attrs:{shape:[t.shape[a-3]*t.shape[a-2],t.shape[a-1]]}});let l;n==="avg"?l=Tw({inputs:{x:u},backend:r,attrs:{axis:0,keepDims:!1}}):(re(n==="max",()=>`Invalid pool type ${n}`),l=kw({inputs:{x:u},backend:r,attrs:{reductionIndices:0,keepDims:!1}}));const d=pe({inputs:{x:l},backend:r,attrs:{shape:e.outShape}});return r.disposeData(u.dataId),r.disposeData(l.dataId),d}let o;const i=[{type:"int32",data:[e.strideHeight,e.strideWidth]}];return e.filterHeight===1&&e.filterWidth===1?o=new kT(e):(n==="avg"?o=new ma(e,"avg"):(re(n==="max",()=>`Invalid pool type ${n}`),o=new ma(e,"max")),i.push({type:"int32",data:[e.padInfo.top,e.padInfo.left]},{type:"int32",data:[e.dilationHeight,e.dilationWidth]},{type:"int32",data:[e.inHeight,e.inWidth]},{type:"int32",data:[e.effectiveFilterHeight,e.effectiveFilterWidth]})),r.runWebGPUProgram(o,[t],t.dtype,i)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NT(t){const{inputs:e,backend:n,attrs:r}=t,{x:o}=e,{filterSize:i,strides:a,pad:u,dimRoundingMode:l}=r,f=vn(o.shape,i,a,1,u,l);return Aw(o,f,"avg",n)}const OT={kernelName:nC,backendName:"webgpu",kernelFunc:NT};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DT(t){const{inputs:e,backend:n,attrs:r}=t,{x:o}=e,{filterSize:i,strides:a,pad:u,dataFormat:l,dimRoundingMode:d}=r,f=[1,1,1],p=Zn(o.shape,i,a,f,u,d,l),h=new Mp(p,"avg"),g=[{type:"int32",data:[p.strideDepth,p.strideHeight,p.strideWidth]},{type:"int32",data:[p.padInfo.front,p.padInfo.top,p.padInfo.left]},{type:"int32",data:[p.inDepth,p.inHeight,p.inWidth]},{type:"int32",data:[p.effectiveFilterDepth,p.effectiveFilterHeight,p.effectiveFilterWidth]}];return n.runWebGPUProgram(h,[o],o.dtype,g)}const FT={kernelName:oC,backendName:"webgpu",kernelFunc:DT};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let LT=class{constructor(e){this.variableNames=["dy"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32, avgMultiplier : f32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=ce(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avgPool2DBackprop"}getUserCode(){return`
      ${se("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d = coords[3];

        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;
        let dyRCorner = dyRCCorner.x;
        let dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR = wR + uniforms.dilations[0]) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims[1]; wC = wC + uniforms.dilations[1]) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }
            let idyC = i32(dyC);

            let dyValue = getDy(batch, idyR, idyC, d);

            dotProd = dotProd + dyValue * uniforms.avgMultiplier;
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}},MT=class{constructor(e){this.variableNames=["dy"],this.uniforms=`strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,
       outDepth : i32, outHeight : i32, outWidth : i32, avgMultiplier : f32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=ce(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avgPool3DBackprop"}getUserCode(){return`
      ${se("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let ch = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyDCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {
          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);

          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {
            continue;
          }
          let idyD = i32(dyD);

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let dyValue = getDy(batch, idyD, idyR, idyC, ch);
              dotProd += dyValue * uniforms.avgMultiplier;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BT(t){const{inputs:e,backend:n,attrs:r}=t,{dy:o,input:i}=e,a=i,{filterSize:u,strides:l,pad:d,dimRoundingMode:f}=r,p=Zn(a.shape,u,l,1,d,f),h=new MT(p),g=1/(p.filterDepth*p.filterHeight*p.filterWidth),y=[{type:"int32",data:[p.strideDepth,p.strideHeight,p.strideWidth]},{type:"int32",data:[p.effectiveFilterDepth-1-p.padInfo.front,p.effectiveFilterHeight-1-p.padInfo.top,p.effectiveFilterWidth-1-p.padInfo.left]},{type:"int32",data:[p.effectiveFilterDepth,p.effectiveFilterHeight,p.effectiveFilterWidth]},{type:"int32",data:[p.outDepth]},{type:"int32",data:[p.outHeight]},{type:"int32",data:[p.outWidth]},{type:"float32",data:[g]}];return n.runWebGPUProgram(h,[o],a.dtype,y)}const UT={kernelName:iC,backendName:"webgpu",kernelFunc:BT};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WT(t){const{inputs:e,backend:n,attrs:r}=t,{dy:o,input:i}=e,a=i;bw([o,i],"avgPoolGrad");const{filterSize:u,strides:l,pad:d}=r,f=vn(a.shape,u,l,1,d),p=new LT(f),h=1/(f.filterHeight*f.filterWidth),g=[{type:"int32",data:[f.strideHeight,f.strideWidth]},{type:"int32",data:[f.effectiveFilterHeight-1-f.padInfo.top,f.effectiveFilterWidth-1-f.padInfo.left]},{type:"int32",data:[f.dilationHeight,f.dilationWidth]},{type:"int32",data:[f.effectiveFilterHeight,f.effectiveFilterWidth]},{type:"int32",data:[f.outHeight]},{type:"int32",data:[f.outWidth]},{type:"float32",data:[h]}];return n.runWebGPUProgram(p,[o],a.dtype,g)}const VT={kernelName:rC,backendName:"webgpu",kernelFunc:WT};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zT(t){const{inputs:e,backend:n,attrs:r}=t,{a:o,b:i}=e,{transposeA:a,transposeB:u}=r;return Rl({a:o,b:i,transposeA:a,transposeB:u,backend:n})}const GT={kernelName:sC,backendName:"webgpu",kernelFunc:zT};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let HT=class{constructor(e,n){this.variableNames=["source"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=n,this.rank=n.length,this.dispatchLayout=ce(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.start=e,this.uniforms=`start : ${Ze(e.length)}, `,this.shaderKey="slice"}getUserCode(){const e=Ze(this.rank),n=jT(this.rank);let r;return this.start.length===1?r=this.outputShape.map((i,a)=>"sourceLoc = uniforms.start + coords;"):r=this.outputShape.map((i,a)=>`sourceLoc.${xf[a]} = uniforms.start.${Xn(a)} + coords.${xf[a]};`),`
      ${se("index")} {
        if (index < uniforms.size) {
          var sourceLoc : ${e};
          let coords = getCoordsFromIndex(index);
          ${r.join(`
`)}
          setOutputAtIndex(index, getSource(${n}));
        }
      }
    `}};const xf=["x","y","z","w","u","v"];function jT(t){if(t===1)return"sourceLoc";if(t<=6)return xf.slice(0,t).map(e=>`sourceLoc.${e}`).join(",");throw Error(`Slicing for rank ${t} is not yet supported`)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xi(t){const{inputs:e,backend:n,attrs:r}=t,{x:o}=e,{begin:i,size:a}=r,[u,l]=pp(o,i,a);if(lp(o,u,l),n.shouldExecuteOnCPU([o])||o.dtype==="string"){const p=n.tensorMap.get(o.dataId),h=zk(p.values,u,l,o.shape,o.dtype);return n.makeTensorInfo(l,o.dtype,h)}if(Y(l)===0)return n.makeTensorInfo(l,o.dtype,[]);const d=new HT(u,l),f=[{type:"int32",data:u}];return n.runWebGPUProgram(d,[o],o.dtype,f)}const XT={kernelName:z1,backendName:"webgpu",kernelFunc:Xi};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qT=t=>{const{inputs:e,backend:n,attrs:r}=t,{x:o}=e,{blockShape:i,crops:a}=r;re(o.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGPU backend not implemented yet");const u=i.reduce((S,I)=>S*I),l=Ra(o.shape,i,u),d=Ea(l.length,i.length),f=_a(o.shape,i,u),p=xp(a,i.length),h=vp(f,a,i.length),g=[],y=pe({inputs:{x:o},backend:n,attrs:{shape:l}}),x=Dn({inputs:{x:y},backend:n,attrs:{perm:d}}),v=pe({inputs:{x},backend:n,attrs:{shape:f}}),w=Xi({inputs:{x:v},backend:n,attrs:{begin:p,size:h}});return g.push(y),g.push(x),g.push(v),g.forEach(S=>n.disposeData(S.dataId)),w},KT={kernelName:aC,backendName:"webgpu",kernelFunc:qT};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YT=`
  fn bincount_write(index: i32, value: f32) {
    ${Lr("&result[index]","value","float32")}
  }
`,QT=`
  fn bincount_write(index: i32, value: f32) {
    atomicStore(&result[index], bitcast<i32>(value));
  }
`;class Nw{constructor(e,n,r=!1){this.outputShape=[],this.variableNames=["x"],this.uniforms="binCountSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.hasWeights=!0,this.binaryOutput=!1,this.outputShape=e,this.rank=e.length,this.dispatchLayout=ce(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize),this.binaryOutput=r,r&&(this.atomic=!1),this.hasWeights=n,this.hasWeights&&this.variableNames.push("w"),this.shaderKey=`bincount_${this.hasWeights}_${this.binaryOutput}_${this.rank}`}getUserCode(){return`
    ${this.binaryOutput?QT:YT}
  ${se("index")} {
    ${this.rank===1?`if (index < uniforms.xShape) {
      let indexVal = i32(getX(index));
      if (indexVal < uniforms.binCountSize) {
        let value = ${this.binaryOutput?1:this.hasWeights?"getW(index)":"1."};
        bincount_write(indexVal, value);
      }
    }`:`let coord = getCoordsFromIndex(index);
    if (coordsInBounds2D(coord, uniforms.xShape)) {
      let indexVal = i32(getX(coord[0], coord[1]));
      if (indexVal < uniforms.binCountSize) {
        let value = ${this.binaryOutput?1:this.hasWeights?"getW(coord[0], coord[1])":"1."};
        bincount_write(coord.x * uniforms.binCountSize + indexVal, value);
      }
    }`}
  }
  `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZT(t){const{inputs:e,backend:n,attrs:r}=t,{x:o,weights:i}=e,{size:a}=r,u=Y(o.shape),d=Y(i.shape)>0,f=[a],p=i.dtype,h=$t({backend:n,attrs:{shape:f,value:0,dtype:p}}),g=new Nw([u],d),y=[{type:"int32",data:[a]}],x=d?[o,i]:[o];return n.runWebGPUProgram(g,x,p,y,h)}const JT={kernelName:uC,backendName:"webgpu",kernelFunc:ZT};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class eA{constructor(e){this.outputShape=[],this.variableNames=["s0","s1"],this.uniforms="s0Size : i32, s1Size : i32, ",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e],this.dispatchLayout=ce(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="broadcastArgs"}getUserCode(){return`
  ${se("index")} {
    if (index < uniforms.size) {
      var s0 = 1.0;
      var s1 = 1.0;
      let indexS0 = index - uniforms.size + uniforms.s0Size;
      let indexS1 = index - uniforms.size + uniforms.s1Size;
      if (indexS0 >= 0) {
        s0 = getS0(indexS0);
      }
      if (indexS1 >= 0) {
        s1 = getS1(indexS1);
      }

      if (s0 == 1.0) {
        setOutputAtIndex(index, s1);
      } else if (s1 == 1.0) {
        setOutputAtIndex(index, s0);
      } else if (s0 != s1) {
        setOutputAtIndex(index, uniforms.NAN);
      } else {
        setOutputAtIndex(index, s0);
      }
    }
  }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tA(t){const{inputs:e,backend:n}=t,{s0:r,s1:o}=e;if(n.shouldExecuteOnCPU([r,o])){const f=n.tensorMap.get(r.dataId),p=n.tensorMap.get(o.dataId),h=f.values,g=p.values,y=He(Array.from(h),Array.from(g));return n.makeTensorInfo([y.length],"int32",Int32Array.from(y))}const i=Y(r.shape),a=Y(o.shape),u=Math.max(i,a),l=new eA(u),d=[{type:"int32",data:[i]},{type:"int32",data:[a]}];return n.runWebGPUProgram(l,[r,o],"int32",d)}const nA={kernelName:lC,backendName:"webgpu",kernelFunc:tA};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ow=st({opType:Ce.NOT_EQUAL,dtype:"bool",cpuKernelImpl:Lk}),rA={kernelName:C1,backendName:"webgpu",kernelFunc:Ow};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pa(t){const{inputs:e,backend:n}=t,{input:r}=e,o=n.tensorMap.get(r.dataId);return Ot({inputs:{x:o.complexTensorInfos.real},backend:n})}const oA={kernelName:P1,backendName:"webgpu",kernelFunc:Pa};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iA(t,e){const n=new ji(t.shape,ie.TO_INT),r=e.runWebGPUProgram(n,[t],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vf(t){const{inputs:e,backend:n,attrs:r}=t,{x:o}=e,{dtype:i}=r;if(i==="complex64"){if(o.dtype==="complex64")return Ot({inputs:{x:o},backend:n});const a=al(o.shape),u=vf({inputs:{x:o},backend:n,attrs:{dtype:"float32"}}),l=zo({inputs:{real:u,imag:a},backend:n});return a.dispose(),n.disposeData(u.dataId),l}if(o.dtype==="complex64"){const a=Pa({inputs:{input:o},backend:n}),u=vf({inputs:{x:a},backend:n,attrs:{dtype:i}});return n.disposeData(a.dataId),u}if(!Uv(o.dtype,i)){const a=Ot({inputs:{x:o},backend:n});return{dataId:a.dataId,shape:a.shape,dtype:i}}if(n.shouldExecuteOnCPU([o])){const a=n.tensorMap.get(o.dataId).values,[u,l,d]=yk(a,o.shape,o.dtype,i);return n.makeTensorInfo(u,l,d)}if(i==="int32")return iA(o,n);if(i==="bool"){const a=n.makeTensorInfo([],"bool",qn("bool",1)),l=Ow({inputs:{a:o,b:a},backend:n});return n.disposeData(a.dataId),l}throw new Error(`Error in Cast: failed to cast ${o.dtype} to ${i}`)}const sA={kernelName:yl,backendName:"webgpu",kernelFunc:vf};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aA=Te({opType:ie.CEIL,cpuKernelImpl:xk}),uA={kernelName:cC,backendName:"webgpu",kernelFunc:aA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lA{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workPerThread=4,this.workgroupSize=[64,1,1],this.outputComponent=4,this.size=!0,this.outputShape=e,this.dispatchLayout=ce(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="clipVec4"}getUserCode(){return`
      ${se("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          var clampedValue = clamp(
              value, vec4<f32>(uniforms.minVal), vec4<f32>(uniforms.maxVal));
          clampedValue = select(clampedValue, value, isnanVec4(value));
          setOutputAtIndex(index, clampedValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let cA=class{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=ce(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="clip"}getUserCode(){return`
      ${se("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          if (isnan(value)) {
            setOutputAtIndex(index, value);
            return;
          }
          setOutputAtIndex(index, clamp(value, uniforms.minVal, uniforms.maxVal));
        }
      }
    `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dA(t){const{inputs:e,backend:n,attrs:r}=t,{x:o}=e,{clipValueMin:i,clipValueMax:a}=r;let u;const l=[{type:"float32",data:[i]},{type:"float32",data:[a]}];return Y(o.shape)%4===0?u=new lA(o.shape):u=new cA(o.shape),n.runWebGPUProgram(u,[o],o.dtype,l)}const fA={kernelName:dC,backendName:"webgpu",kernelFunc:dA};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let pA=class{constructor(e){this.outputShape=[],this.variableNames=["real","imag"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=ce(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="complexAbs"}getUserCode(){return`
    ${se("index")} {
      if (index < uniforms.size) {
        let re = abs(getRealByOutputIndex(index));
        let im = abs(getImagByOutputIndex(index));
        let mx = max(re, im);

        // The length function in wgsl may be not underflow-safe on some GPUs.
        // So the safe solution is to ensure underflow-safety in all cases.
        setOutputAtIndex(index, select(mx * length(vec2<f32>(1, min(re, im)/mx)), 0.0, mx == 0.0));
      }
    }
  `}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Iy(t,e){return{dataId:e.dataId,dtype:e.dtype,shape:t.shape}}function hA(t){const{inputs:e,backend:n}=t,{x:r}=e,o=n.tensorMap.get(r.dataId),i=new pA(r.shape),a=[Iy(r,o.complexTensorInfos.real),Iy(r,o.complexTensorInfos.imag)];return n.runWebGPUProgram(i,a,a[0].dtype)}const mA={kernelName:Lf,backendName:"webgpu",kernelFunc:hA};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let gA=class{constructor(e){this.uniforms="",this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=tn(e,1),this.variableNames=e.map((n,r)=>`T${r}`),this.dispatchLayout=ce(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.offsetLength=e.length-1;for(let n=0;n<this.offsetLength;n++)this.uniforms+=`offset${n} : i32,`;this.shaderKey="concat"}getUserCode(){const e=[];if(this.offsetLength>0){e.push("if (yC < uniforms.offset0){ setOutputAtCoords(coords.x, coords.y, getT0(yR, yC)); }");for(let i=1;i<this.offsetLength;i++)e.push(`else if (yC < uniforms.offset${[i]}){ setOutputAtCoords(coords.x, coords.y, getT${i}(yR, yC - uniforms.offset${i-1})); }`);const r=this.offsetLength,o=this.offsetLength-1;e.push(`else { setOutputAtCoords(coords.x, coords.y, getT${r}(yR, yC - uniforms.offset${o})); }`)}else e.push("setOutputAtCoords(coords.x, coords.y, getT0(yR, yC));");return`
      ${se("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            let yR = coords.x;
            let yC = coords.y;

            ${e.join(`
        `)}
          }
        }
      }
    `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function El(t){const{inputs:e,backend:n}=t,{input:r}=e,o=n.tensorMap.get(r.dataId);return Ot({inputs:{x:o.complexTensorInfos.imag},backend:n})}const yA={kernelName:XC,backendName:"webgpu",kernelFunc:El};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ua(t,e,n){const r=t[0].dtype;if(r==="complex64"){const y=t.map(I=>Pa({inputs:{input:I},backend:n})),x=t.map(I=>El({inputs:{input:I},backend:n})),v=ua(y,e,n),w=ua(x,e,n),S=zo({inputs:{real:v,imag:w},backend:n});return y.forEach(I=>n.disposeData(I.dataId)),x.forEach(I=>n.disposeData(I.dataId)),n.disposeData(v.dataId),n.disposeData(w.dataId),S}let o=n.shouldExecuteOnCPU(t);if(r==="string"&&(o=!0),o){const y=t.map(R=>{const k=[-1,Y(R.shape.slice(e))];return pe({inputs:{x:R},backend:n,attrs:{shape:k}})}),x=y.map(R=>({vals:n.readSync(R.dataId),shape:R.shape})),v=tn(y.map(R=>R.shape),1),w=y[0].shape[0]===1,S=vk(x,v,r,w),I=tn(t.map(R=>R.shape),e),E=n.makeTensorInfo(I,r,S);return y.forEach(R=>n.disposeData(R.dataId)),E}const i=n.device.limits.maxStorageBuffersPerShaderStage-1;if(t.length>i){const y=[];for(let v=0;v<t.length;v+=i){const w=t.slice(v,v+i);y.push(ua(w,e,n))}const x=ua(y,e,n);for(const v of y)n.disposeData(v.dataId);return x}const{tensors2D:a,outShape:u}=xA(t,e,n),l=a.map(y=>y.shape),d=new gA(l),f=[],p=new Array(l.length-1);if(p.length>0){p[0]=l[0][1],f.push({type:"int32",data:[p[0]]});for(let y=1;y<p.length;y++)p[y]=p[y-1]+l[y][1],f.push({type:"int32",data:[p[y]]})}const h=n.runWebGPUProgram(d,a,a[0].dtype,f);a.forEach(y=>n.disposeData(y.dataId));const g=pe({inputs:{x:h},backend:n,attrs:{shape:u}});return n.disposeData(h.dataId),g}function xA(t,e,n){const r=tn(t.map(i=>i.shape),e);return{tensors2D:t.map(i=>pe({inputs:{x:i},backend:n,attrs:{shape:[Y(i.shape.slice(0,e)),Y(i.shape.slice(e))]}})),outShape:r}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dw(t){const{inputs:e,backend:n,attrs:r}=t,{axis:o}=r,i=Je(o,e[0].shape)[0],a=e.map(d=>d.shape);mp(a,i);const u=tn(e.map(d=>d.shape),i);if(Y(u)===0)return n.makeTensorInfo(u,e[0].dtype,[]);const l=e.filter(d=>Y(d.shape)>0);return l.length===1?Ot({inputs:{x:l[0]},backend:n}):ua(l,i,n)}const vA={kernelName:fC,backendName:"webgpu",kernelFunc:Dw};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CA(t,e,n,r,o=!1,i=null,a=!1,u=4,l=4,d=4){const f=N=>{switch(N){case 1:return"resData = f32(x[xIndex]);";case 3:return"resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);";case 4:return"resData = vec4<f32>(x[xIndex / 4]);";default:throw new Error(`innerElementSize ${N} is not supported.`)}},p=N=>{switch(N){case 1:return"return f32(W[row * uniforms.wShape[3] + col]);";case 4:return"return vec4<f32>(W[(row * uniforms.wShape[3] + col) / 4]);";default:throw new Error(`innerElementSize ${N} is not supported.`)}},h=t?`
      let coord = vec4<i32>(batch, xRow, xCol, xCh);
      `:`
      let coord = vec4<i32>(batch, xCh, xRow, xCol);
      `,g=t?`
      let coords = vec4<i32>(
        batch,
        row / outWidth,
        row % outWidth,
        col);
      `:`
      let coords = vec4<i32>(
        batch,
        row,
        col / outWidth,
        col % outWidth);
      `,y=t?"uniforms.xShape[1]":"uniforms.xShape[2]",x=t?"uniforms.xShape[2]":"uniforms.xShape[3]",v=t?"row":"col",w=t?"col":"row",S=`
      let inChannels = uniforms.wShape[2];
      let outWidth = ${t?"uniforms.outShape[2]":"uniforms.outShape[3]"};
      let outRow = ${v} / outWidth;
      let outCol = ${v} % outWidth;

      let WRow = ${w} / (uniforms.filterDims[1] * inChannels);
      let WCol = ${w} / inChannels % uniforms.filterDims[1];
      let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * WRow - uniforms.pads[0];
      let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * WCol - uniforms.pads[1];
      let xCh = ${w} % inChannels;
      var resData = ${_e(u)}(0.0);
      // The bounds checking is always needed since we use it to pad zero for
      // the 'same' padding type.
      if (xRow >= 0 && xRow < ${y} && xCol >= 0 && xCol < ${x}) {
        ${h}
        let xIndex = getIndexFromCoords4D(coord, uniforms.xShape);
        ${f(u)}
      }
      return resData;`,I=t?e&&r?`
      ${S}`:`
      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${S}
      }
      return ${_e(u)}(0.0);`:r&&n?`
      ${S}`:`
      if (row < uniforms.dimInner && col < uniforms.dimBOuter) {
        ${S}
      }
      return ${_e(u)}(0.0);`,E=`${p(l)}`,R=_e(d),T=_e(t?u:l),k=_e(t?l:u);return`
      ${Jn(i,a,d===4,4)}
      fn mm_readA(batch: i32, row : i32, col : i32) -> ${T} {
        ${t?I:E}
      }

      fn mm_readB(batch: i32, row : i32, col : i32) -> ${k} {
        ${t?E:I}
      }

      fn mm_write(batch: i32, row : i32, col : i32, valueIn : ${R}) {
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)
        {
        var value = valueIn;
        let outWidth = ${t?"uniforms.outShape[2]":"uniforms.outShape[3]"};
        ${g}
        ${Vo(o,i)}
        setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }`}class wA{constructor(e,n,r,o,i=!1,a=null,u=!1,l=!1){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.outShape,this.isChannelsLast=e.dataFormat==="channelsLast",this.isVec4=((e.inChannels%4===0||e.inChannels%3===0)&&this.isChannelsLast||e.outWidth%4===0&&!this.isChannelsLast)&&e.outChannels%4===0,this.dispatchLayout=this.isChannelsLast?{x:[3],y:[1,2],z:[0]}:{x:[2,3],y:[1],z:[0]},this.workgroupSize=Cw(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=ww(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4?(this.outputComponent=4,this.isChannelsLast&&e.inChannels%4!==0?(this.innerElementSize=3,this.variableComponents=[1,4]):(this.innerElementSize=4,this.variableComponents=[4,4]),i&&(this.variableNames.push("bias"),this.variableComponents.push(4)),u&&(this.variableNames.push("preluActivationWeights"),this.variableComponents.push(4))):(this.innerElementSize=this.elementsPerThread[0],i&&this.variableNames.push("bias"),u&&this.variableNames.push("preluActivationWeights")),this.sequentialAccessByThreads=l,this.addBias=i,this.activation=a,this.hasPreluActivationWeights=u,this.tileAOuter=this.workgroupSize[1]*this.elementsPerThread[1],this.tileBOuter=this.workgroupSize[0]*this.elementsPerThread[0],this.tileInner=Math.max(this.workgroupSize[0]*this.innerElementSize,this.workgroupSize[1]),this.fitAOuter=n%this.tileAOuter===0,this.fitBOuter=r%this.tileBOuter===0,this.fitInner=o%this.tileInner===0,this.shaderKey=`conv2DMM_${this.elementsPerThread}_${this.activation}}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.innerElementSize}_${this.isChannelsLast}_${this.sequentialAccessByThreads}`}getUserCode(){const e=this.isVec4?Il(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner):$l(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner,!1,null,this.sequentialAccessByThreads),n=this.isVec4?[this.innerElementSize,4,4]:[1,1,1];return`
    ${CA(this.isChannelsLast,this.fitAOuter,this.fitBOuter,this.fitInner,this.addBias,this.activation,this.hasPreluActivationWeights,n[0],n[1],n[2])}
    ${e}
  `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class SA{constructor(e,n=!1,r=null,o=!1){this.variableNames=["x","W"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>,",this.workgroupSize=[4,4,8],this.outputShape=e.outShape,this.isChannelsLast=e.dataFormat==="channelsLast",this.dispatchLayout=this.isChannelsLast?{x:[2],y:[1],z:[0,3]}:{x:[3],y:[2],z:[0,1]},this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=n,this.activation=r,this.hasPreluActivationWeights=o,n&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`conv2dnaive_${this.activation}_${this.isChannelsLast}`}getUserCode(){return`
       ${Jn(this.activation,this.hasPreluActivationWeights,!1,4)}
       fn readInp(batch : i32, row : i32, col : i32, chan : i32) -> f32{
         let coords = vec4<i32>(batch, row, col, chan);
         if (coordsInBounds4D(coords, uniforms.xShape)) {
           return  getX(batch, row, col, chan);
         } else {
          return 0.0;
         }
       }
       fn readFilt(row : i32, col : i32, xChannel : i32, outChannel : i32) -> f32{
         let coords = vec4<i32>(row, col, xChannel, outChannel);
         if(coordsInBounds4D(coords, uniforms.wShape)) {
           return getW(row, col, xChannel, outChannel);
          } else {
            return 0.0;
          }
       }
       fn writeResult(batch : i32, row : i32, col : i32, chan : i32, valueIn : f32) {
         let coords = ${this.isChannelsLast?"vec4<i32>(batch, row, col, chan);":"vec4<i32>(batch, chan, row, col);"}
         if (coordsInBounds4D(coords, uniforms.outShape)) {
           var value = valueIn;
           ${Vo(this.addBias,this.activation)}
           setOutputAtCoords(coords.x, coords.y, coords.z, coords.w, value);
         }
       }
       ${se("index")} {
         let coords = getOutputCoords();
         let batch = coords[0];
         let outChannel = ${this.isChannelsLast?"coords[3];":"coords[1];"}
         let outRow = ${this.isChannelsLast?"coords[1];":"coords[2];"}
         let outCol = ${this.isChannelsLast?"coords[2];":"coords[3];"}
         var acc : f32 = 0.0;
         for (var row = 0; row < uniforms.filterDims[0]; row = row + 1) {
           for (var col = 0; col < uniforms.filterDims[1]; col = col + 1) {
             let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * row - uniforms.pads[0];
             let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * col - uniforms.pads[1];
             for (var xChannel = 0; xChannel < ${this.isChannelsLast?"uniforms.xShape[3];":"uniforms.xShape[1];"} xChannel = xChannel + 1) {
               ${this.isChannelsLast?"let v = readInp(batch, xRow, xCol, xChannel);":"let v = readInp(batch, xChannel, xRow, xCol);"}
               let f = readFilt(row, col, xChannel, outChannel);
               acc = acc + v * f;
             }
           }
         }
         writeResult(batch, outRow, outCol, outChannel, acc);
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bA{constructor(e,n){this.variableNames=["x"],this.uniforms=`pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, outWidth : i32, itemsPerBlockRow : i32,
       inChannels : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=ce(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=n,this.shaderKey=`im2col_${this.isChannelsLast}`}getUserCode(){const e=this.isChannelsLast?1:2,n=this.isChannelsLast?2:3,r=this.isChannelsLast?"coords[1]":"coords[2]",o=this.isChannelsLast?"coords[2]":"coords[1]",i=this.isChannelsLast?"getX(batch, xRow, xCol, ch)":"getX(batch, ch, xRow, xCol)";return`
    ${se("index")} {
      let coords = getCoordsFromIndex(index);
      if(index < uniforms.size) {
        let batch = coords[0];
        let row = ${r};
        let col = ${o};
        let offsetY = (row / uniforms.outWidth) * uniforms.strides[0] - uniforms.pads[0];
        let xRow = offsetY + uniforms.dilations[0] * (col / uniforms.itemsPerBlockRow);
        var value = 0.0;
        if(xRow < uniforms.xShape[${e}] && xRow >= 0) {
          let offsetX = (row % uniforms.outWidth) * uniforms.strides[1] -
              uniforms.pads[1];
          let xCol = offsetX + uniforms.dilations[1] * ((col %
              uniforms.itemsPerBlockRow) / uniforms.inChannels);
          let ch = col % uniforms.inChannels;
          if(xCol < uniforms.xShape[${n}] && xCol >= 0) {
            value = ${i};
          }
        }
        setOutputAtIndex(index, value);
      }
    }
   `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cl(t,e){const n=t.length;return n>=3?e?[...t.slice(0,-3),t[n-3]*t[n-2],t[n-1]]:[...t.slice(0,-3),t[n-3],t[n-2]*t[n-1]]:!e&&n===1&&t[0]>1?[t[0],1]:null}function IA({x:t,filter:e,convInfo:n,backend:r,bias:o=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:u=null}){const l=n.dataFormat==="channelsLast",d=!l,f=!1,p=l&&n.filterHeight===n.inHeight&&n.filterWidth===n.inWidth&&n.padInfo.type==="VALID",h=[];let g,y;if(p){const w=n.inHeight*n.inWidth*n.inChannels;g=pe({inputs:{x:t},backend:r,attrs:{shape:[1,n.batchSize,w]}}),y=pe({inputs:{x:e},backend:r,attrs:{shape:[1,w,n.outChannels]}})}else g=pe({inputs:{x:t},backend:r,attrs:{shape:l?[n.batchSize,n.inHeight*n.inWidth,n.inChannels]:[n.batchSize,n.inChannels,n.inHeight*n.inWidth]}}),y=pe({inputs:{x:e},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}});if(h.push(g),h.push(y),i!=null){const w=cl(i.shape,l);w!=null&&(i=pe({inputs:{x:i},backend:r,attrs:{shape:w}}),h.push(i))}if(o!=null){const w=cl(o.shape,l);w!=null&&(o=pe({inputs:{x:o},backend:r,attrs:{shape:w}}),h.push(o))}const x=Rl({a:l?g:y,b:l?y:g,transposeA:d,transposeB:f,backend:r,bias:o,activation:u,preluActivationWeights:i,leakyreluAlpha:a}),v=pe({inputs:{x},backend:r,attrs:{shape:n.outShape}});h.push(x);for(const w of h)r.disposeData(w.dataId);return v}function $A({x:t,filter:e,convInfo:n,backend:r,bias:o=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:u=null}){const{filterWidth:l,filterHeight:d,inChannels:f,strideWidth:p,strideHeight:h,padInfo:g,outWidth:y,outHeight:x,dilationWidth:v,dilationHeight:w,dataFormat:S}=n,I=S==="channelsLast",E=l*d*f,R=x*y,T=I?[n.batchSize,R,E]:[n.batchSize,E,R],k=new bA(T,I),D=[{type:"int32",data:[g.top,g.left]},{type:"int32",data:[h,p]},{type:"int32",data:[w,v]},{type:"int32",data:[y]},{type:"int32",data:[f*l]},{type:"int32",data:[f]}],N=r.runWebGPUProgram(k,[t],t.dtype,D),O=[];O.push(N);const _=pe({inputs:{x:e},backend:r,attrs:{shape:[1,E,-1]}});if(O.push(_),i!=null){const Z=cl(i.shape,I);Z!=null&&(i=pe({inputs:{x:i},backend:r,attrs:{shape:Z}}),O.push(i))}if(o!=null){const Z=cl(o.shape,I);Z!=null&&(o=pe({inputs:{x:o},backend:r,attrs:{shape:Z}}),O.push(o))}const G=Rl({a:I?N:_,b:I?_:N,transposeA:!I,transposeB:!1,backend:r,bias:o,activation:u,preluActivationWeights:i,leakyreluAlpha:a}),j=pe({inputs:{x:G},backend:r,attrs:{shape:n.outShape}});O.push(G);for(const Z of O)r.disposeData(Z.dataId);return j}function Fw({x:t,filter:e,convInfo:n,backend:r,bias:o=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:u=null}){const l=o!=null,d=i!=null,f=n.dataFormat==="channelsLast",p=f&&n.filterHeight===n.inHeight&&n.filterWidth===n.inWidth&&n.padInfo.type==="VALID",h=V().getBool("WEBGPU_USE_NAIVE_CONV2D_DEBUG");if(!h&&(p||n.filterHeight===1&&n.filterWidth===1&&n.dilationHeight===1&&n.dilationWidth===1&&n.strideHeight===1&&n.strideWidth===1&&(n.padInfo.type==="SAME"||n.padInfo.type==="VALID")))return IA({x:t,filter:e,convInfo:n,backend:r,bias:o,activation:u,preluActivationWeights:i,leakyreluAlpha:a});const g=V().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),y=g>-1?g:r.thresholdToIncreaseWorkgroups,x=n.batchSize*Math.ceil(n.outHeight*n.outWidth/32)*Math.ceil(n.outChannels/32);if(V().getBool("WEBGPU_CONV_SEPARATE_IM2COL_SHADER")||x<=y)return $A({x:t,filter:e,convInfo:n,backend:r,bias:o,preluActivationWeights:i,leakyreluAlpha:a,activation:u});let v;const w=[n.padInfo.top,n.padInfo.left],S=[{type:"int32",data:[n.filterHeight,n.filterWidth]},{type:"int32",data:[...w]},{type:"int32",data:[n.strideHeight,n.strideWidth]},{type:"int32",data:[n.dilationHeight,n.dilationWidth]}];if(h)v=new SA(n,l,u,d);else{const T=f?n.outHeight*n.outWidth:n.outChannels,k=f?n.outChannels:n.outHeight*n.outWidth,D=n.filterHeight*n.filterWidth*n.inChannels;S.push({type:"int32",data:[T]},{type:"int32",data:[k]},{type:"int32",data:[D]});const N=r.adapterInfo.isIntel();v=new wA(n,T,k,D,l,u,d,N)}const I=[],E=[t,e];l&&(!f&&o.shape.length===1&&(o=pe({inputs:{x:o},backend:r,attrs:{shape:[o.shape[0],1,1]}}),I.push(o)),E.push(o)),d&&(!f&&i.shape.length===1&&(i=pe({inputs:{x:i},backend:r,attrs:{shape:[i.shape[0],1,1]}}),I.push(i)),E.push(i)),u==="leakyrelu"&&(S.push({type:"float32",data:[a]}),v.uniforms+=" alpha : f32,");const R=r.runWebGPUProgram(v,E,t.dtype,S);for(const T of I)r.disposeData(T.dataId);return R}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RA(t){const{inputs:e,attrs:n,backend:r}=t,{x:o,filter:i}=e,{strides:a,pad:u,dataFormat:l,dilations:d,dimRoundingMode:f}=n,p=Cn(l),h=it(o.shape,i.shape,a,d,u,f,!1,p);return Fw({x:o,filter:i,convInfo:h,backend:r})}const EA={kernelName:pC,backendName:"webgpu",kernelFunc:RA};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let _A=class{constructor(e){this.variableNames=["dy","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>,",this.workgroupSize=[64,1,1],this.size=!1,this.isVec4=!1,this.workPerThread=1,this.outputShape=e.inShape,this.isChannelsLast=e.dataFormat==="channelsLast",this.isVec4=this.isChannelsLast&&e.outChannels%4===0&&e.inChannels%4===0,this.isVec4?(this.workPerThread=2,this.outputComponent=4,this.workgroupSize=[4,4,4],this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize,[4,this.workPerThread,1])):(this.size=!0,this.workPerThread=1,this.workgroupSize=[64,1,1],this.dispatchLayout=ce(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize)),this.shaderKey=`conv2DDerInput_${this.isChannelsLast}_${this.isVec4}_${this.workPerThread}`}getUserCode(){const e=this.isChannelsLast?1:2,n=this.isChannelsLast?2:3,r=this.isChannelsLast?3:1,o=`
    ${se()} {
      let batch = i32(globalId.z) / uniforms.outShape[1];
      let r = i32(globalId.z) % uniforms.outShape[1];
      let c = i32(globalId.y) * ${this.workPerThread};
      let d1 = i32(globalId.x) * 4;

      let dyCorner = vec2<i32>(r, c) - uniforms.pads;

      // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
      // ? = to be determined. : = across all values in that axis.
      var dotProd: array<vec4<f32>, ${this.workPerThread}>;
      for (var i = 0; i < ${this.workPerThread}; i++) {
        dotProd[i] = vec4<f32>(0.0);
      }
      for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
        let dyR = f32(dyCorner.x + wR) / f32(uniforms.strides.x);
        let wRPerm = uniforms.filterDims.x - 1 - wR;
        if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) ||
            fract(dyR) > 0.0) {
          continue;
        }
        let idyR = i32(dyR);

        for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
          let dyC = f32(dyCorner.y + wC) / f32(uniforms.strides.y);
          let dyC2 = f32(dyCorner.y + 1 + wC) / f32(uniforms.strides.y);
          let wCPerm = uniforms.filterDims.y - 1 - wC;
          var bDyCVal = true;
          var bDyCVal2 = true;
          if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
              fract(dyC) > 0.0) {
            bDyCVal = false;
          }
          if (dyC2 < 0.0 || dyC2 >= f32(uniforms.outBackprop[2]) ||
              fract(dyC2) > 0.0) {
            bDyCVal2 = false;
          }

          let idyC = i32(dyC);
          let idyC2 = i32(dyC2);
          if (bDyCVal && bDyCVal2) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[0] = dotProd[0] + tmpval;
              xValue = getDy(batch, idyR, idyC2, d2);
              dotProd[1] = dotProd[1] + vec4<f32>(dot(xValue, wValue0),
                                                  dot(xValue, wValue1),
                                                  dot(xValue, wValue2),
                                                  dot(xValue, wValue3));
            }
          } else if (bDyCVal) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[0] = dotProd[0] + tmpval;
            }
          } else if (bDyCVal2) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC2, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[1] = dotProd[1] + tmpval;
            }
          }
        }
      }

      for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
        let coords = vec4<i32>(batch, r, c + i, d1);
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], dotProd[i]);
        }
      }
    }
    `;return this.isVec4?`
    ${o}
    `:`
    ${se("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d1 = coords[${r}];

        let dyCorner = vec2<i32>(coords[${e}], coords[${n}]) - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
          let dyR = (f32(dyRCorner) + f32(wR)) / f32(uniforms.strides.x);
          let wRPerm = uniforms.filterDims.x - 1 - wR;
          if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) || fract(dyR) > 0.0 ||
              wRPerm < 0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
            let dyC = (f32(dyCCorner) + f32(wC)) / f32(uniforms.strides.y);
            let wCPerm = uniforms.filterDims.y - 1 - wC;
            if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
                fract(dyC) > 0.0 || wCPerm < 0) {
              continue;
            }
            let idyC = i32(dyC);

            for (var d2 = 0; d2 < uniforms.outBackprop[3]; d2 = d2 + 1) {
              let xValue = ${this.isChannelsLast?"getDy(batch, idyR, idyC, d2)":"getDy(batch, d2, idyR, idyC)"};
              let wValue = getW(wRPerm, wCPerm, d1, d2);
              dotProd = dotProd + xValue * wValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}},PA=class{constructor(e){this.variableNames=["x","dy"],this.uniforms="pads : vec2<i32>, strides : vec2<i32>, batchSize : i32, outHeight : i32, outWidth : i32, inHeight : i32, inWidth : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=ce(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=e.dataFormat==="channelsLast",this.shaderKey=`conv2DDerFilter_${this.isChannelsLast}`}getUserCode(){return`
    ${se("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wR = coords[0];
        let wC = coords[1];
        let d1 = coords[2];
        let d2 = coords[3];

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b = b + 1) {
          for (var yR = 0; yR < uniforms.outHeight; yR = yR + 1) {
            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];
            if (xR < 0 || xR >= uniforms.inHeight) {
              continue;
            }

            for (var yC = 0; yC < uniforms.outWidth; yC = yC + 1) {
              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];

              if (xC < 0 || xC >= uniforms.inWidth) {
                continue;
              }

              if (${this.isChannelsLast}) {
                let dyValue = getDy(b, yR, yC, d2);
                let xValue = getX(b, xR, xC, d1);
                dotProd = dotProd + xValue * dyValue;
              } else {
                let dyValue = getDy(b, d2, yR, yC);
                let xValue = getX(b, d1, xR, xC);
                dotProd = dotProd + xValue * dyValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}},kA=class{constructor(e){this.variableNames=["x","dy"],this.uniforms=`pads : vec3<i32>, strides : vec3<i32>, batchSize : i32, outDepth : i32,
       outHeight : i32, outWidth : i32, inDepth : i32, inHeight : i32, inWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=ce(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3DDerFilter"}getUserCode(){return`
    ${se("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wF = coords.x;
        let wR = coords.y;
        let wC = coords.z;
        let d1 = coords.w;
        let d2 = coords.u;

        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b++) {
          for (var yF = 0; yF < uniforms.outDepth; yF++) {
            let xF = wF + yF * uniforms.strides[0] - uniforms.pads[0];
            if (xF < 0 || xF >= uniforms.inDepth) {
              continue;
            }

            for (var yR = 0; yR < uniforms.outHeight; yR++) {
              let xR = wR + yR * uniforms.strides[1] - uniforms.pads[1];
              if (xR < 0 || xR >= uniforms.inHeight) {
                continue;
              }

              for (var yC = 0; yC < uniforms.outWidth; yC++) {
                let xC = wC + yC * uniforms.strides[2] - uniforms.pads[2];
                if (xC < 0 || xC >= uniforms.inWidth) {
                  continue;
                }

                let dyValue = getDy(b, yF, yR, yC, d2);
                let xValue = getX(b, xF, xR, xC, d1);
                dotProd += xValue * dyValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}},TA=class{constructor(e){this.variableNames=["dy","W"],this.uniforms=`filterDims : vec3<i32>, pads : vec3<i32>, strides : vec3<i32>,
      outDepth : i32, outHeight : i32, outWidth : i32, outChannels : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=ce(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3DDerInput"}getUserCode(){return`
    ${se("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let d1 = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyFCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        var dotProd = 0.0;
        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {
          let dyF = f32(dyFCorner + wF) / f32(uniforms.strides[0]);
          if (dyF < 0.0 || dyF >= f32(uniforms.outDepth) || fract(dyF) > 0.0) {
            continue;
          }
          let idyF = i32(dyF);

          let wFPerm = uniforms.filterDims[0] - 1 - wF;

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            let wRPerm = uniforms.filterDims[1] - 1 - wR;

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let wCPerm = uniforms.filterDims[2] - 1 - wC;

              for (var d2 = 0; d2 < uniforms.outChannels; d2++) {
                let xValue = getDy(batch, idyF, idyR, idyC, d2);
                let wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AA(t){const{inputs:e,backend:n,attrs:r}=t,{x:o,dy:i}=e,{strides:a,pad:u,dataFormat:l,dimRoundingMode:d,filterShape:f}=r,p=Cn(l),h=it(o.shape,f,a,1,u,d,!1,p),g=new PA(h),y=[{type:"int32",data:[h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.strideHeight,h.strideWidth]},{type:"int32",data:[h.batchSize]},{type:"int32",data:[h.outHeight]},{type:"int32",data:[h.outWidth]},{type:"int32",data:[h.inHeight]},{type:"int32",data:[h.inWidth]}];return n.runWebGPUProgram(g,[o,i],o.dtype,y)}const NA={kernelName:hC,backendName:"webgpu",kernelFunc:AA};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OA(t=4){const e=i=>{switch(i){case 1:return"return W[getIndexFromCoords4D(coord, uniforms.wShape)];";case 4:return`
            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);
            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);
            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);
            let v0 = W[getIndexFromCoords4D(coord, uniforms.wShape)];
            let v1 = W[getIndexFromCoords4D(coord1, uniforms.wShape)];
            let v2 = W[getIndexFromCoords4D(coord2, uniforms.wShape)];
            let v3 = W[getIndexFromCoords4D(coord3, uniforms.wShape)];
            return vec4<f32>(v0, v1, v2, v3);
            `;default:throw new Error(`innerElementSize ${i} is not supported.`)}},r=`if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${`
      let outRow = row / uniforms.outShape[2];
      let outCol = row % uniforms.outShape[2];

      let WRow = col / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
      let WCol = col / uniforms.outBackprop[3] % uniforms.filterDims[1];
      let xR = f32(outRow - uniforms.pads[0] + WRow) / f32(uniforms.strides[0]);
      let xC = f32(outCol - uniforms.pads[1] + WCol) / f32(uniforms.strides[1]);
      if (xR < 0.0 || xR >= f32(uniforms.outBackprop[1]) || fract(xR) > 0.0) {
        return ${_e(t)}(0.0);
      }
      if (xC < 0.0 || xC >= f32(uniforms.outBackprop[2]) || fract(xC) > 0.0) {
        return ${_e(t)}(0.0);
      }
      let coord = vec4<i32>(
          batch,
          i32(xR),
          i32(xC),
          col % uniforms.outBackprop[3]);
      return x[getIndexFromCoords4D(coord, uniforms.xShape)/${t}];`}
      }
      return ${_e(t)}(0.0);`;return`
  fn mm_readA(batch: i32, row : i32, col : i32) -> ${_e(t)} {
    ${r}
  }

  fn mm_readB(batch: i32, row : i32, col : i32) -> ${_e(t)} {
    let coordX = uniforms.filterDims.x - 1 -
        row / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
    let coordY = uniforms.filterDims.y - 1 -
        (row / uniforms.outBackprop[3]) % uniforms.filterDims[1];
    if (row < uniforms.dimInner && col < uniforms.dimBOuter &&
        coordX >= 0 && coordY >= 0) {
      let rowInner = row % uniforms.outBackprop[3];
      let coord = vec4<i32>(coordX, coordY, col, rowInner);
      ${e(t)}
    }
    return ${_e(t)}(0.0);
  }

  fn mm_write(batch: i32, row : i32, col : i32, valueInput : ${_e(t)}) {
    if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
      var value = valueInput;
      let outCoord = vec4<i32>(
          batch,
          row / uniforms.outShape[2],
          row % uniforms.outShape[2],
          col);
      result[getIndexFromCoords4D(outCoord, uniforms.outShape)/${t}] = value;
    }
  }`}class DA{constructor(e){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.inShape,re(e.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),this.isVec4=e.inChannels%4===0&&e.outChannels%4===0,this.dispatchLayout={x:[3],y:[1,2],z:[0]},this.workgroupSize=Cw(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=ww(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4&&(this.outputComponent=4,this.variableComponents=[4,1]),this.shaderKey=`conv2DDerInputMM_${this.isVec4}_${this.elementsPerThread}`}getUserCode(){const e=this.isVec4?Il(this.elementsPerThread,this.workgroupSize):$l(this.elementsPerThread,this.workgroupSize);return`
    ${OA(this.isVec4?4:1)}
    ${e}
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FA(t){const{inputs:e,backend:n,attrs:r}=t,{dy:o,filter:i}=e,{inputShape:a,strides:u,pad:l,dataFormat:d,dimRoundingMode:f}=r,p=Cn(d),h=it(a,i.shape,u,1,l,f,!1,p),g=[{type:"int32",data:[h.filterHeight,h.filterWidth]},{type:"int32",data:[h.filterHeight-1-h.padInfo.top,h.filterWidth-1-h.padInfo.left]},{type:"int32",data:[h.strideHeight,h.strideWidth]},{type:"int32",data:[h.batchSize,h.outHeight,h.outWidth,h.outChannels]}];let y;if(V().getBool("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE")||h.dataFormat!=="channelsLast")y=new _A(h);else{y=new DA(h);const x=h.inHeight*h.inWidth,v=h.inChannels,w=h.filterHeight*h.filterWidth*h.outChannels;g.push({type:"uint32",data:[x]},{type:"uint32",data:[v]},{type:"uint32",data:[w]})}return n.runWebGPUProgram(y,[o,i],"float32",g)}const LA={kernelName:mC,backendName:"webgpu",kernelFunc:FA};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class MA{constructor(e){this.variableNames=["x","W"],this.uniforms="filterDims: vec3<i32>, pads: vec3<i32>, strides: vec3<i32>, dilations: vec3<i32>,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=ce(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3dnaive"}getUserCode(){return`
    ${se("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let batch = coords.x;
        let d2 = coords.u;

        let xFRCCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;
        let xFCorner = xFRCCorner.x;
        let xRCorner = xFRCCorner.y;
        let xCCorner = xFRCCorner.z;

        let inputDepthNearestVec4 = (uniforms.xShape.u / 4) * 4;
        let inputDepthVec4Remainder = uniforms.xShape.u % 4;

        var dotProd = 0.0;
        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {
          let xF = xFCorner + wF * uniforms.dilations[0];
          if (xF < 0 || xF >= uniforms.xShape.y) {
            continue;
          }

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let xR = xRCorner + wR * uniforms.dilations[1];
            if (xR < 0 || xR >= uniforms.xShape.z) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let xC = xCCorner + wC * uniforms.dilations[2];
              if (xC < 0 || xC >= uniforms.xShape.w) {
                continue;
              }

              for (var d1 = 0; d1 < inputDepthNearestVec4; d1 += 4) {
                let xValues = vec4<f32>(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                let wValues = vec4<f32>(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (inputDepthVec4Remainder == 1) {
                dotProd += getX(batch, xF, xR, xC, inputDepthNearestVec4) *
                  getW(wF, wR, wC, inputDepthNearestVec4, d2);
              } else if (inputDepthVec4Remainder == 2) {
                let xValues = vec2<f32>(
                  getX(batch, xF, xR, xC, inputDepthNearestVec4),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1)
                );
                let wValues = vec2<f32>(
                  getW(wF, wR, wC, inputDepthNearestVec4, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (inputDepthVec4Remainder == 3) {
                let xValues = vec3<f32>(
                  getX(batch, xF, xR, xC, inputDepthNearestVec4),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2)
                );
                let wValues = vec3<f32>(
                  getW(wF, wR, wC, inputDepthNearestVec4, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }`}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BA(t){const{inputs:e,backend:n,attrs:r}=t,{x:o,filter:i}=e,{strides:a,pad:u,dilations:l}=r,d=Dr(o.shape,i.shape,a,l,u),f=[d.padInfo.front,d.padInfo.top,d.padInfo.left],p=[{type:"int32",data:[d.filterDepth,d.filterHeight,d.filterWidth]},{type:"int32",data:[...f]},{type:"int32",data:[d.strideDepth,d.strideHeight,d.strideWidth]},{type:"int32",data:[d.dilationDepth,d.dilationHeight,d.dilationWidth]}],h=new MA(d),g=Rt(o.dtype,i.dtype);return n.runWebGPUProgram(h,[o,i],g,p)}const UA={kernelName:gC,backendName:"webgpu",kernelFunc:BA};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WA(t){const{inputs:e,backend:n,attrs:r}=t,{x:o,dy:i}=e,{strides:a,pad:u,filterShape:l}=r,d=Dr(o.shape,l,a,1,u),f=new kA(d),p=[{type:"int32",data:[d.padInfo.front,d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.strideDepth,d.strideHeight,d.strideWidth]},{type:"int32",data:[d.batchSize]},{type:"int32",data:[d.outDepth]},{type:"int32",data:[d.outHeight]},{type:"int32",data:[d.outWidth]},{type:"int32",data:[d.inDepth]},{type:"int32",data:[d.inHeight]},{type:"int32",data:[d.inWidth]}];return n.runWebGPUProgram(f,[o,i],i.dtype,p)}const VA={kernelName:yC,backendName:"webgpu",kernelFunc:WA};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zA(t){const{inputs:e,backend:n,attrs:r}=t,{dy:o,filter:i}=e,{strides:a,pad:u,inputShape:l}=r,d=Dr(l,i.shape,a,1,u),f=new TA(d),p=[{type:"int32",data:[d.filterDepth,d.filterHeight,d.filterWidth]},{type:"int32",data:[d.filterDepth-1-d.padInfo.front,d.filterHeight-1-d.padInfo.top,d.filterWidth-1-d.padInfo.left]},{type:"int32",data:[d.strideDepth,d.strideHeight,d.strideWidth]},{type:"int32",data:[d.outDepth]},{type:"int32",data:[d.outHeight]},{type:"int32",data:[d.outWidth]},{type:"int32",data:[d.outChannels]}];return n.runWebGPUProgram(f,[o,i],o.dtype,p)}const GA={kernelName:xC,backendName:"webgpu",kernelFunc:zA};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HA=Te({opType:ie.COS}),jA={kernelName:vC,backendName:"webgpu",kernelFunc:HA};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XA=Te({opType:ie.COSH}),qA={kernelName:CC,backendName:"webgpu",kernelFunc:XA};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let KA=class{constructor(e,n,r,o){this.variableNames=["Image","Boxes","BoxInd"],this.uniforms="extrapolationValue : f32,",this.workgroupSize=[64,1,1],this.size=!0;const[i]=n;this.outputShape=[i,r[0],r[1],e],this.dispatchLayout=ce(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize),this.methodId=o==="bilinear"?1:0,this.cropHeightBiggerThan1=this.outputShape[1]>1,this.cropWidthBiggerThan1=this.outputShape[2]>1,this.shaderKey=`cropAndResize_${this.methodId}_${this.cropHeightBiggerThan1}_${this.cropWidthBiggerThan1}`}getUserCode(){const[e,n]=["f32(uniforms.imageShape[1] - 1)","f32(uniforms.imageShape[2] - 1)"],[r,o,i]=this.cropHeightBiggerThan1?[`(${e} / f32(uniforms.outShape[1] - 1))`,"(y2-y1) * height_ratio",`y1*${e} + f32(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${e}`],[a,u,l]=this.cropWidthBiggerThan1?[`(${n} / f32(uniforms.outShape[2] - 1))`,"(x2-x1) * width_ratio",`x1*${n} + f32(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${n}`];return`
    ${se("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let height_ratio = f32(${r});
        let width_ratio = f32(${a});
        let b = coords[0];
        let y = coords[1];
        let x = coords[2];
        let d = coords[3];
        // get box vals
        let y1 = getBoxes(b, 0);
        let x1 = getBoxes(b, 1);
        let y2 = getBoxes(b, 2);
        let x2 = getBoxes(b, 3);
        // get image in batch index
        let bInd = i32(round(getBoxInd(b)));
        if(bInd < 0 || bInd >= uniforms.outShape[0]) {
          return;
        }
        let height_scale = ${o};
        let width_scale = ${u};
        let in_y = ${i};
        if( in_y < 0.0 || in_y > ${e} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let in_x = ${l};
        if( in_x < 0.0 || in_x > ${n} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let sourceFracIndexCR = vec2<f32>(in_x,in_y);
        if(${this.methodId} == 1) {
          // Compute the four integer indices.
          let sourceFloorCR = vec2<i32>(sourceFracIndexCR);
          let sourceCeilCR = vec2<i32>(ceil(sourceFracIndexCR));
          let topLeft = getImage(bInd, sourceFloorCR.y, sourceFloorCR.x, d);
          let bottomLeft = getImage(bInd, sourceCeilCR.y, sourceFloorCR.x, d);
          let topRight = getImage(bInd, sourceFloorCR.y, sourceCeilCR.x, d);
          let bottomRight = getImage(bInd, sourceCeilCR.y, sourceCeilCR.x, d);
          let fracCR = sourceFracIndexCR - vec2<f32>(sourceFloorCR);
          let top = topLeft + (topRight - topLeft) * fracCR.x;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          let newValue = top + (bottom - top) * fracCR.y;
          setOutputAtIndex(index, newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          let sourceNearestCR = vec2<i32>(floor(
            sourceFracIndexCR + vec2<f32>(0.5,0.5)));
          let newValue = getImage(
            bInd, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutputAtIndex(index, newValue);
        }
      }
    }
    `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YA=t=>{const{inputs:e,backend:n,attrs:r}=t,{image:o,boxes:i,boxInd:a}=e,{cropSize:u,method:l,extrapolationValue:d}=r,f=new KA(o.shape[3],i.shape,u,l),p=[{type:"float32",data:[d]}];return n.runWebGPUProgram(f,[o,i,a],"float32",p)},QA={kernelName:bC,backendName:"webgpu",kernelFunc:YA};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var ga;(function(t){t.Prod="*",t.Sum="+"})(ga||(ga={}));let $y=class{constructor(e,n,r,o){this.variableNames=["x"],this.uniforms="index : f32,",this.size=!0,this.workgroupSize=[128,1,1],this.outputShape=n,this.dispatchLayout=ce(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize),this.exclusive=r,this.reverse=o,this.op=e,this.shaderKey=`cum_${this.op}_${this.exclusive}_${this.reverse}`}getUserCode(){const e=this.outputShape.length,n=this.op===ga.Prod?"1.0":"0.0",r=this.exclusive?n:`getX(${Ry(e,"coords",this.op)})`,o=this.outputShape[this.outputShape.length-1];let i="",a="";return this.exclusive?(i=this.reverse?`end != ${o-1}`:"end != 0",a=this.reverse?"end + 1":"end - 1"):(i=this.reverse?`end + pow2 < ${o}`:"end >= pow2",a=this.reverse?"end + pow2":"end - pow2"),`
      ${se("index")} {
       if (index < uniforms.size) {
         var coords = getCoordsFromIndex(index);

         let end = ${Ey(e,"coords",this.op)};
         var val = ${r};
         let pow2 = i32(pow(2.0, uniforms.index));
         if (${i}) {
           let idx = ${a};
           ${Ey(e,"coords",this.op)} = idx;
           val ${this.op}= getX(${Ry(e,"coords",this.op)});
         }
         setOutputAtIndex(index, val);
       }
      }
    `}};function Ry(t,e,n){if(t===1)return`${e}`;if(t===2)return`${e}.x, ${e}.y`;if(t===3)return`${e}.x, ${e}.y, ${e}.z`;if(t===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw Error(`Cumulative ${n} for rank ${t} is not yet supported`)}function Ey(t,e,n){if(t===1)return`${e}`;if(t===2)return`${e}.y`;if(t===3)return`${e}.z`;if(t===4)return`${e}.w`;throw Error(`Cumulative ${n} for rank ${t} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lw(t,e,n,r,o,i){const a=e.shape.length,u=dt([r],a);let l=e;u!=null&&(l=Dn({inputs:{x:e},backend:n,attrs:{perm:u}}));const d=ft(1,a)[0];if(d!==a-1)throw new Error(`WebGPU cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${r}`);const f=l.shape[d];let p=Ot({inputs:{x:l},backend:n});for(let h=0;h<=Math.ceil(Math.log2(f))-1;h++){const g=new $y(t,l.shape,!1,i),y=p,x=[{type:"float32",data:[h]}];p=n.runWebGPUProgram(g,[p],p.dtype,x),n.disposeData(y.dataId)}if(o){const h=new $y(t,l.shape,o,i),g=p,y=[{type:"float32",data:[0]}];p=n.runWebGPUProgram(h,[p],p.dtype,y),n.disposeData(g.dataId)}if(u!=null){const h=$a(u),g=Dn({inputs:{x:p},backend:n,attrs:{perm:h}});return n.disposeData(p.dataId),n.disposeData(l.dataId),g}return p}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZA(t){const{inputs:e,backend:n,attrs:r}=t,{x:o}=e,{axis:i,exclusive:a,reverse:u}=r;return Lw(ga.Prod,o,n,i,a,u)}const JA={kernelName:wC,backendName:"webgpu",kernelFunc:ZA};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eN(t){const{inputs:e,backend:n,attrs:r}=t,{x:o}=e,{axis:i,exclusive:a,reverse:u}=r;return Lw(ga.Sum,o,n,i,a,u)}const tN={kernelName:SC,backendName:"webgpu",kernelFunc:eN};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nN(t){const{inputs:e,backend:n,attrs:r}=t,{x:o,weights:i}=e,{size:a,binaryOutput:u}=r,l=o.shape.length===1,f=Y(i.shape)>0,p=i.dtype,h=l?[o.shape[0]]:[o.shape[0],o.shape[1]],g=l?[a]:[o.shape[0],a],y=$t({backend:n,attrs:{shape:g,value:0,dtype:p}}),x=new Nw(h,f,u),v=[{type:"int32",data:[a]}],w=f?[o,i]:[o];return n.runWebGPUProgram(x,w,p,v,y)}const rN={kernelName:IC,backendName:"webgpu",kernelFunc:nN};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let oN=class{constructor(e,n){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.uniforms="blockSize : i32,",this.outputShape=e,this.dispatchLayout=ce(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`depthToSpace_${n}`,this.dataFormat=n}getUserCode(){return`
      ${se("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let h = ${this.getHeightCoordString()};
          let w = ${this.getWidthCoordString()};
          let d = ${this.getDepthCoordString()};

          let in_h = h / uniforms.blockSize;
          let offset_h = h % uniforms.blockSize;
          let in_w = w / uniforms.blockSize;
          let offset_w = w % uniforms.blockSize;
          let offset_d = (offset_h * uniforms.blockSize + offset_w) *
            ${this.getOutputDepthSize()};
          let in_d = d + offset_d;

          let rlt = ${this.getInputSamplingString()};
          setOutputAtIndex(index, rlt);
        }
      }`}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?"uniforms.outShape[3]":"uniforms.outShape[1]"}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iN(t){const{inputs:e,backend:n,attrs:r}=t,{x:o}=e,{blockSize:i,dataFormat:a}=r,u=o.shape[0],l=a==="NHWC"?o.shape[1]:o.shape[2],d=a==="NHWC"?o.shape[2]:o.shape[3],f=a==="NHWC"?o.shape[3]:o.shape[1],p=l*i,h=d*i,g=f/(i*i),y=a==="NHWC"?[u,p,h,g]:[u,g,p,h],x=[{type:"int32",data:[i]}],v=new oN(y,a);return n.runWebGPUProgram(v,[o],o.dtype,x)}const sN={kernelName:$C,backendName:"webgpu",kernelFunc:iN};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class aN{constructor(e,n,r,o=!1,i=null,a=!1){this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>,",this.workgroupSize=[16,16,1],this.outputShape=e,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize),o&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),this.addBias=o,this.activation=i,this.hasPreluActivation=a,this.filterHeight=n,this.filterWidth=r,this.shaderKey=`depthwiseNCHW_${this.activation}_${this.filterHeight}_${this.filterWidth}`}getUserCode(){const e=this.filterWidth*this.filterHeight,n=this.workgroupSize[0]*this.workgroupSize[1]*this.workgroupSize[2],r=this.workgroupSize[1]+this.filterHeight-1,o=this.workgroupSize[0]+this.filterWidth-1;return`
      ${Jn(this.activation,this.hasPreluActivation,!1,4)}

      var<workgroup> mm_Asub : array<array<f32, ${o}>, ${r}>;
      var<workgroup> mm_Bsub : array<array<f32, ${this.filterWidth}>, ${this.filterHeight}>;
      fn readX(batch : i32, channel : i32, row : i32, col : i32) -> f32 {
        var value = 0.0;
        if (row >=0 && row < uniforms.inDims[0] && col >=0 && col < uniforms.inDims[1])
        {
          value = getX(batch, channel, row, col);
        }
        return value;
      }

      ${se()} {
        let coords = getOutputCoords();
        let batch = coords[0];
        let xRCCorner = vec2<i32>(coords.zw) - uniforms.pads;
        let channelMul = uniforms.wShape[3];
        let d1 = coords[1] / channelMul;
        let q = coords[1] % channelMul;

        let inputRowStart = xRCCorner.x;
        let inputColStart = xRCCorner.y;

        let localRow = i32(localId.y);
        let localCol = i32(localId.x);

        // Load one tile of X into local memory.
        for (var inputRow = localRow; inputRow < ${r}; inputRow = inputRow + ${this.workgroupSize[1]}) {
          for (var inputCol = localCol; inputCol < ${o}; inputCol = inputCol + ${this.workgroupSize[0]}) {
            let rowOffset = inputRow - localRow;
            let colOffset = inputCol - localCol;
            mm_Asub[inputRow][inputCol] = readX(batch, d1, inputRowStart + rowOffset, inputColStart + colOffset);
          }
        }

        // Load one tile of W into local memory.
        var wIndex = i32(localIndex);
        ${e<n?`if (wIndex < ${e})`:`for(; wIndex < ${e}; wIndex = wIndex + ${n})`}

        {
          let wRow = wIndex / ${this.filterWidth};
          let wCol = wIndex % ${this.filterWidth};
          mm_Bsub[wRow][wCol] = getW(wRow, wCol, d1, q);
        }

        workgroupBarrier();

        var value = 0.0;
        for (var wR = 0; wR < ${this.filterHeight}; wR = wR + 1) {
          for (var wC = 0; wC < ${this.filterWidth}; wC = wC + 1) {
            let xVal = mm_Asub[localRow + wR][localCol + wC];
            let wVal = mm_Bsub[wR][wC];
            value = fma(xVal, wVal, value);
          }
        }
        ${Vo(this.addBias,this.activation)}
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Mw{constructor(e,n=!1,r=null,o=!1){this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>, virtualWidth : i32,",this.workgroupSize=[64,1,1],this.workPerThread=4,this.outputComponent=4,this.outputShape=e.outShape,this.virtualWidth=Math.ceil(this.outputShape[2]/this.workPerThread)*this.workPerThread;const i=[this.outputShape[0],this.outputShape[1],this.virtualWidth,this.outputShape[3]];this.dispatchLayout=ce(i),this.dispatch=ae(this.dispatchLayout,i,this.workgroupSize,[this.outputComponent*this.workPerThread,1,1]),re(e.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),n&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=n,this.activation=r,this.hasPreluActivation=o,this.shaderKey=`depthwiseVec4_${r}_${this.convInfo.filterHeight}_${this.convInfo.filterWidth}_${this.convInfo.strideHeight}_${this.convInfo.strideWidth}_${this.workPerThread}`}getUserCode(){const e=(this.workPerThread-1)*this.convInfo.strideWidth+this.convInfo.filterWidth,n=this.convInfo.strideHeight,r=this.convInfo.strideWidth;return`
      ${Jn(this.activation,this.hasPreluActivation,!0,4)}
      fn readX(batch : i32, row : i32, col : i32, channel : i32) -> vec4<f32> {
        var value = vec4<f32>(0.0);
        if (col >=0 && col < uniforms.inDims[1]) {
          value = getX(batch, row, col, channel);
        }
        return value;
      }

      ${se("index")} {
        let width0 = uniforms.outShape[3] / ${this.outputComponent};
        let d1 = (index % width0) * ${this.outputComponent};
        var index1 = index / width0;
        let width1 = uniforms.virtualWidth / ${this.workPerThread};
        let c = (index1 % width1) * ${this.workPerThread};
        index1 = index1 / width1;
        let r = index1 % uniforms.outShape[1];
        let batch = index1 / uniforms.outShape[1];

        let xRCCorner = vec2<i32>(r, c) * vec2<i32>(${n}, ${r}) - uniforms.pads;

        let xRCorner = xRCCorner.x;
        let xCCorner = xRCCorner.y;
        var xVals : array<vec4<f32>, ${e}>;
        var dotProd : array<vec4<f32>, ${this.workPerThread}>;
        for (var i = 0; i < ${this.workPerThread}; i++) {
          dotProd[i] = vec4<f32>(0.0);
        }

        // Use constant instead of uniform can give better performance.
        for (var wR = 0; wR < ${this.convInfo.filterHeight}; wR = wR + 1) {
          let xR = xRCorner + wR;
          if (xR >=0 && xR < uniforms.inDims[0]) {
            for (var i = 0; i < ${e}; i++) {
              xVals[i] = readX(batch, xR, xCCorner + i, d1);
            }
            for (var wC = 0; wC < ${this.convInfo.filterWidth}; wC = wC + 1) {
              let wValue = getW(wR, wC, d1, 0);
              for (var i = 0; i < ${this.workPerThread}; i++) {
                dotProd[i] = fma(xVals[i * ${r} + wC], wValue, dotProd[i]);
              }
            }
          }
        }

        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let coords = vec4<i32>(batch, r, c + i, d1);
          if (coordsInBounds4D(coords, uniforms.outShape)) {
            var value = dotProd[i];
            ${Vo(this.addBias,this.activation)}
            setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Bw=class{constructor(e,n=!1,r=null,o=!1){this.variableNames=["x","W"],this.uniforms=`pads : vec2<i32>, inDims : vec2<i32>, filterHeight : i32,
      filterWidth : i32, strides : vec2<i32>, dilations : vec2<i32>,`,this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=ce(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=e.dataFormat==="channelsLast",n&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=n,this.activation=r,this.hasPreluActivation=o,this.shaderKey=`depthwise_${this.activation}_${this.isChannelsLast}`}getUserCode(){const e=this.isChannelsLast?"getX(batch, xR, xC, d1);":"getX(batch, d1, xR, xC);";return`
      ${Jn(this.activation,this.hasPreluActivation,!1,4)}

      ${se("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let batch = coords[0];
          let xRCCorner = vec2<i32>(coords.${this.isChannelsLast?"yz":"zw"}) * uniforms.strides - uniforms.pads;
          let d2 = coords[${this.isChannelsLast?3:1}];
          let channelMul = uniforms.wShape[3];
          let d1 = d2 / channelMul;
          let q = d2 % channelMul;

          let inputRowStart = xRCCorner.x;
          let inputColStart = xRCCorner.y;
          let inputRowEnd = inputRowStart + uniforms.filterHeight *
              uniforms.dilations[0];
          let inputColEnd = inputColStart + uniforms.filterWidth *
              uniforms.dilations[1];

          // Convolve x(?, ?, d1)|x(d1, ?, ?) with w(:, :, d1, q) to get
          // y(yR, yC, d2)|y(d2, yR, yC). ? = to be determined. : = across all
          // values in that axis. x(?, ?, d1) and y(yR, yC, d2) is for NHWC.
          // x(d1, ?, ?) and y(d2, yR, yC) is for NCHW.
          var value = 0.0;

          // Extract if checking out of for loop for performance.
          if (inputRowStart >= 0 && inputColStart >= 0 &&
            inputRowEnd < uniforms.inDims[0] &&
                inputColEnd < uniforms.inDims[1]) {
              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
                let xR = inputRowStart + wR * uniforms.dilations[0];

                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                  let xC = inputColStart + wC * uniforms.dilations[1];

                  let xVal = ${e};
                  let wVal = getW(wR, wC, d1, q);
                  value = value + xVal * wVal;
                }
              }
            } else {
              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
                let xR = inputRowStart + wR * uniforms.dilations[0];

                if (xR < 0 || xR >= uniforms.inDims[0]) {
                  continue;
                }

                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                  let xC = inputColStart + wC * uniforms.dilations[1];

                  if (xC < 0 || xC >= uniforms.inDims[1]) {
                    continue;
                  }

                  let xVal = ${e};
                  let wVal = getW(wR, wC, d1, q);
                  value = value + xVal * wVal;
                }
              }
            }
            ${Vo(this.addBias,this.activation)}
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uN(t){const{inputs:e,backend:n,attrs:r}=t,{x:o,filter:i}=e,{strides:a,pad:u,dataFormat:l,dilations:d,dimRoundingMode:f}=r,p=Cn(l);let h=d;h==null&&(h=[1,1]);const g=it(o.shape,i.shape,a,h,u,f,!0,p),y=[{type:"int32",data:[g.padInfo.top,g.padInfo.left]},{type:"int32",data:[g.inHeight,g.inWidth]}],x=g.dataFormat==="channelsLast";let v;return!x&&g.inHeight>16&&g.inWidth>16&&g.strideHeight===1&&g.strideWidth===1&&g.dilationWidth===1&&g.dilationHeight===1&&g.inChannels===g.outChannels?v=new aN(g.outShape,g.filterHeight,g.filterWidth):x&&g.outHeight>4&&g.outWidth>4&&g.strideWidth<=2&&g.inChannels===g.outChannels&&g.dilationHeight===1&&g.dilationWidth===1&&g.inChannels%4===0?(v=new Mw(g),y.push({type:"int32",data:[v.virtualWidth]})):(v=new Bw(g),y.push({type:"int32",data:[g.filterHeight]},{type:"int32",data:[g.filterWidth]},{type:"int32",data:[g.strideHeight,g.strideWidth]},{type:"int32",data:[g.dilationHeight,g.dilationWidth]})),n.runWebGPUProgram(v,[o,i],o.dtype,y)}const lN={kernelName:RC,backendName:"webgpu",kernelFunc:uN};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let cN=class{constructor(e){this.variableNames=["x","dy"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>, outHeight : i32,
      outWidth : i32, inHeight : i32, inWidth : i32, batchSize : i32, channelMul : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=ce(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthwise_conv2d_backprop_filter"}getUserCode(){return`
      ${se("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wR = coords[0];
        let wC = coords[1];
        let d1 = coords[2];
        let dm = coords[3];
        let d2 = d1 * uniforms.channelMul + dm;

        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b++) {
          for (var yR = 0; yR < uniforms.outHeight; yR++) {
            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];

            if (xR < 0 || xR >= uniforms.inHeight) {
              continue;
            }

            for (var yC = 0; yC < uniforms.outWidth; yC++) {
              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];

              if (xC < 0 || xC >= uniforms.inWidth) {
                continue;
              }

              let dyValue = getDy(b, yR, yC, d2);
              let xValue = getX(b, xR, xC, d1);
              dotProd += xValue * dyValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}},dN=class{constructor(e){this.variableNames=["dy","W"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32, channelMul : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=ce(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthwise_conv2d_backprop_input"}getUserCode(){return`
      ${se("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d1 = coords[3];
        let dyCorner = coords.yz - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }

          let idyR = i32(dyR);
          let wRPerm = uniforms.filterDims[0] - 1 - wR;

          for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }

            let idyC = i32(dyC);
            let wCPerm = uniforms.filterDims[1] - 1 - wC;

            for (var dm = 0; dm < uniforms.channelMul; dm++) {
              let d2 = d1 * uniforms.channelMul + dm;
              let xValue = getDy(batch, idyR, idyC, d2);
              let wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fN(t){const{inputs:e,backend:n,attrs:r}=t,{x:o,dy:i}=e,{strides:a,dilations:u,pad:l,dimRoundingMode:d,filterShape:f}=r,p=it(o.shape,f,a,u,l,d,!0),h=new cN(p),g=[{type:"int32",data:[p.strideHeight,p.strideWidth]},{type:"int32",data:[p.padInfo.top,p.padInfo.left]},{type:"int32",data:[p.filterHeight,p.filterWidth]},{type:"int32",data:[p.outHeight]},{type:"int32",data:[p.outWidth]},{type:"int32",data:[p.inHeight]},{type:"int32",data:[p.inWidth]},{type:"int32",data:[p.batchSize]},{type:"int32",data:[p.outChannels/p.inChannels]}];return n.runWebGPUProgram(h,[o,i],"float32",g)}const pN={kernelName:EC,backendName:"webgpu",kernelFunc:fN};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hN(t){const{inputs:e,backend:n,attrs:r}=t,{dy:o,filter:i}=e,{strides:a,dilations:u,pad:l,dimRoundingMode:d,inputShape:f}=r,p=it(f,i.shape,a,u,l,d,!0),h=new dN(p),g=[{type:"int32",data:[p.strideHeight,p.strideWidth]},{type:"int32",data:[p.filterHeight-1-p.padInfo.top,p.filterWidth-1-p.padInfo.left]},{type:"int32",data:[p.filterHeight,p.filterWidth]},{type:"int32",data:[p.outHeight]},{type:"int32",data:[p.outWidth]},{type:"int32",data:[p.outChannels/p.inChannels]}];return n.runWebGPUProgram(h,[o,i],o.dtype,g)}const mN={kernelName:_C,backendName:"webgpu",kernelFunc:hN};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let gN=class{constructor(e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,e],this.dispatchLayout=ce(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="diag"}getUserCode(){return`
      ${se("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let value = select(0.0, getX(coords[0]), coords[0] == coords[1]);
          setOutputAtIndex(index, value);
        }
      }
    `}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yN(t){const{inputs:e,backend:n}=t,{x:r}=e,o=[...r.shape,...r.shape],i=Y(r.shape),a=pe({inputs:{x:r},backend:n,attrs:{shape:[i]}}),u=new gN(i),l=n.runWebGPUProgram(u,[a],a.dtype),d=pe({inputs:{x:l},backend:n,attrs:{shape:o}});return n.disposeData(a.dataId),n.disposeData(l.dataId),d}const xN={kernelName:PC,backendName:"webgpu",kernelFunc:yN};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let vN=class{constructor(e){this.variableNames=["x","w"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=ce(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="dilation2d"}getUserCode(){return`
       ${se("index")} {
         if (index < uniforms.size) {
           let neg_infinity = -3.4e38;
           let coords = getOutputCoords();
           let batch = coords.x;
           let d1 = coords.w;
           let outTopLeftCorner = coords.yz * uniforms.strides - uniforms.pads;
           let hBeg = outTopLeftCorner.x;
           let wBeg = outTopLeftCorner.y;

           var curVal = neg_infinity;
           for (var h = 0; h < uniforms.filterDims[0]; h = h + 1) {
             let hIn = hBeg + h * uniforms.dilations[0];

             if (hIn >= 0 && hIn < uniforms.xShape[1]) {
               for (var w = 0; w < uniforms.filterDims[1]; w = w + 1) {
                 let wIn = wBeg + w * uniforms.dilations[1];

                 if (wIn >= 0 && wIn < uniforms.xShape[2]) {
                   let val = getX(batch, hIn, wIn, d1) + getW(h, w, d1);
                   if (val > curVal) {
                     curVal = val;
                   }
                 }
               }
             }
           }

           setOutputAtIndex(index, curVal);
         }
       }
     `}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CN(t){const{inputs:e,backend:n,attrs:r}=t,{x:o,filter:i}=e,{strides:a,pad:u,dilations:l}=r,d=Ia(o.shape,i.shape,a,u,"NHWC",l),f=[d.padInfo.top,d.padInfo.left],p=[{type:"int32",data:[d.filterHeight,d.filterWidth]},{type:"int32",data:[...f]},{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]}],h=new vN(d);return n.runWebGPUProgram(h,[o,i],o.dtype,p)}const wN={kernelName:kC,backendName:"webgpu",kernelFunc:CN};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class SN{constructor(e,n){if(this.variableNames=["x","w","dy"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e.inShape,this.dispatchLayout=ce(e.outShape),this.dispatch=ae(this.dispatchLayout,e.outShape,this.workgroupSize),n!=="float32"&&n!=="int32")throw new Error(`Dilation2DBackpropInput only supports float32 and int32
          types, does not support ${n} type.`);this.type=n,this.shaderKey="dilation2DBackpropInput"}getUserCode(){return`
       ${se("index")} {
         if (index < uniforms.dySize) {
           let coords = getDyCoordsFromIndex(index);
           let b = coords[0];
           let r = coords[1];
           let c = coords[2];
           let d = coords[3];

           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;
           var curVal = -3.4e38;  // neg_infinity
           var xRMax = 0;
           var xCMax = 0;

           // In the case of multiple argmax branches, we only back-propagate
           // along the last branch, i.e., the one with largest value of
           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling
           // backward routines.
           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
             let xR = dyCorner.x + wR * uniforms.dilations[0];

             if (xR >= 0 && xR < uniforms.xShape[1]) {
               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
                 let xC = dyCorner.y + wC * uniforms.dilations[1];

                 if (xC >= 0 && xC < uniforms.xShape[2]) {
                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);
                   if (val > curVal) {
                     curVal = val;
                     xRMax = xR;
                     xCMax = xC;
                   }
                 }
               }
             }
           }

           let flatIndexIn = d + uniforms.xShape[3] *
               (xCMax + uniforms.xShape[2] * (xRMax + uniforms.xShape[1] * b));
           let value = getDy(b, r, c, d);
           ${Lr("&result[flatIndexIn]","value",this.type)}
         }
       }
     `}}class bN{constructor(e,n,r){if(this.variableNames=["x","w","dy"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e.filterShape,this.dispatchLayout=ce(e.outShape),this.dispatch=ae(this.dispatchLayout,e.outShape,this.workgroupSize),r!=="float32"&&r!=="int32")throw new Error(`Dilation2DBackpropFilter only supports float32 and int32
          types, does not support ${r} type.`);this.type=r,this.shaderKey="dilation2DBackpropFilter"}getUserCode(){return`
       ${se("index")} {
         if (index < uniforms.dySize) {
           let coords = getDyCoordsFromIndex(index);
           let b = coords[0];
           let r = coords[1];
           let c = coords[2];
           let d = coords[3];

           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;
           var curVal = -3.4e38;  // neg_infinity
           var wRMax = 0;
           var wCMax = 0;

           // In the case of multiple argmax branches, we only back-propagate
           // along the last branch, i.e., the one with largest value of
           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling
           // backward routines.
           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
             let xR = dyCorner.x + wR * uniforms.dilations[0];

             if (xR >= 0 && xR < uniforms.xShape[1]) {
               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
                 let xC = dyCorner.y + wC * uniforms.dilations[1];

                 if (xC >= 0 && xC < uniforms.xShape[2]) {
                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);
                   if (val > curVal) {
                     curVal = val;
                     wRMax = wR;
                     wCMax = wC;
                   }
                 }
               }
             }
           }

           let flatIndexIn = d + uniforms.wShape[2] * (wCMax + wRMax * uniforms.wShape[1]);
           let value = getDy(b, r, c, d);
           ${Lr("&result[flatIndexIn]","value",this.type)}
         }
       }
     `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IN(t){const{inputs:e,backend:n,attrs:r}=t,{x:o,filter:i,dy:a}=e,{strides:u,pad:l,dilations:d}=r,f=Ia(o.shape,i.shape,u,l,"NHWC",d),p=i.dtype,h=new bN(f,i.shape,p),g=[{type:"int32",data:[f.filterHeight,f.filterWidth]},{type:"int32",data:[f.padInfo.top,f.padInfo.left]},{type:"int32",data:[f.strideHeight,f.strideWidth]},{type:"int32",data:[f.dilationHeight,f.dilationWidth]},{type:"int32",data:[Y(f.outShape)]}],y=$t({backend:n,attrs:{shape:i.shape,value:0,dtype:p}});return n.runWebGPUProgram(h,[o,i,a],p,g,y)}const $N={kernelName:SI,backendName:"webgpu",kernelFunc:IN};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RN(t){const{inputs:e,backend:n,attrs:r}=t,{x:o,filter:i,dy:a}=e,{strides:u,pad:l,dilations:d}=r,f=Ia(o.shape,i.shape,u,l,"NHWC",d),p=o.dtype,h=new SN(f,p),g=[{type:"int32",data:[f.filterHeight,f.filterWidth]},{type:"int32",data:[f.padInfo.top,f.padInfo.left]},{type:"int32",data:[f.strideHeight,f.strideWidth]},{type:"int32",data:[f.dilationHeight,f.dilationWidth]},{type:"int32",data:[Y(f.outShape)]}],y=$t({backend:n,attrs:{shape:f.inShape,value:0,dtype:p}});return n.runWebGPUProgram(h,[o,i,a],p,g,y)}const EN={kernelName:wI,backendName:"webgpu",kernelFunc:RN};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _N{constructor(e,n,r){this.variableNames=["Image"],this.uniforms="alpha: f32,",this.workgroupSize=[64,1,1],this.pixelsOpType=Wi.DRAW,this.size=!0,this.outputShape=e,this.dispatchLayout=ce(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize),this.type=n,this.textureFormat=r,this.shaderKey=`draw_${n}_${r}`}getUserCode(){let e;const n=this.type==="float32"?"value":"value / 255.0";return e=`
      if (uniforms.numChannels == 1) {
        rgba[0] = ${n};
        rgba[1] = ${n};
        rgba[2] = ${n};
      } else {
        rgba[d] = ${n};
      }`,`
       @group(0) @binding(0) var outImage : texture_storage_2d<${this.textureFormat}, write>;
       ${se("index")} {
         if (index < uniforms.size) {
           var rgba = vec4<f32>(0.0, 0.0, 0.0, uniforms.alpha);
           for (var d = 0; d < uniforms.numChannels; d = d + 1) {
             let value = f32(inBuf[index * uniforms.numChannels + d]);
             ${e}
           }
           rgba.x = rgba.x * rgba.w;
           rgba.y = rgba.y * rgba.w;
           rgba.z = rgba.z * rgba.w;
           let coords = getCoordsFromIndex(index);
           textureStore(outImage, vec2<i32>(coords.yx), rgba);
         }
       }
      `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use backend file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PN(t){const{inputs:e,backend:n,attrs:r}=t,{image:o}=e,{canvas:i,options:a}=r,[u,l]=o.shape.slice(0,2),{imageOptions:d}=a||{},f=d?.alpha||1,p=n.device.features.has("bgra8unorm-storage")?"bgra8unorm":"rgba8unorm",h=[u,l],g=new _N(h,o.dtype,p);i.width=l,i.height=u;const y="webgpu";let x=i.getContext(y),v;x||(v=new OffscreenCanvas(l,u),x=v.getContext(y));const w=o.shape.length===3?o.shape[2]:1;x.configure({device:n.device,format:p,usage:GPUTextureUsage.STORAGE_BINDING,alphaMode:"premultiplied"});const S="int32",I=n.makeTensorInfo(h,S),E=n.tensorMap.get(I.dataId);E.resource=x.getCurrentTexture(),E.external=!0;const R=[{type:"uint32",data:[w]},{type:"float32",data:[f]}];if(n.runWebGPUProgram(g,[o],S,R,I),v){const T=i.getContext("2d");if(!T)throw new Error("Please make sure this canvas has only been used for 2d or webgpu context!");T.drawImage(v,0,0)}return n.disposeData(I.dataId),o}const kN={kernelName:bI,backendName:"webgpu",kernelFunc:PN};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uw=st({opType:Ce.MUL,cpuKernelImpl:Dk,supportsComplex:!0}),TN={kernelName:Gf,backendName:"webgpu",kernelFunc:Uw};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ww(t){const{inputs:e,backend:n,attrs:r}=t,{x:o}=e,{axis:i,keepDims:a}=r;return Go(o,i,a,"sum",n)}const AN={kernelName:Zf,backendName:"webgpu",kernelFunc:Ww};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NN(t){const{inputs:e,backend:n,attrs:r}=t,{equation:o}=r,i=e,{allDims:a,summedDims:u,idDims:l}=_p(o,i.length);kp(a.length,l,i);const{path:d,steps:f}=Tp(u,l),p=f.length;let h=null,g=a.length;const y=[];for(let x=0;x<p;++x){for(const v of f[x]){const{permutationIndices:w,expandDims:S}=Pp(g,l[v]);let I;Ap(w)?I=i[v]:(I=Dn({inputs:{x:i[v]},backend:n,attrs:{perm:w}}),y.push(I));const E=I.shape.slice();for(let R=0;R<S.length;++R)E.splice(S[R],0,1);je(I.shape,E)||(I=pe({inputs:{x:I},backend:n,attrs:{shape:E}}),y.push(I)),h===null?h=I:(h=Uw({inputs:{a:I,b:h},backend:n}),y.push(h))}x<p-1&&(d[x]>=0&&(h=Ww({inputs:{x:h},backend:n,attrs:{axis:d[x]-(a.length-g),keepDims:!1}}),y.push(h)),g--)}for(const x of y)x!==h&&n.disposeData(x.dataId);return h}const ON={kernelName:TC,backendName:"webgpu",kernelFunc:NN};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DN=Te({opType:ie.ELU}),FN={kernelName:Bf,backendName:"webgpu",kernelFunc:DN};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LN=t=>{const{inputs:e,backend:n}=t,{dy:r,y:o}=e,i=new ul(Ce.ELU_DER,r.shape,o.shape);return n.runWebGPUProgram(i,[r,o],r.dtype)},MN={kernelName:AC,backendName:"webgpu",kernelFunc:LN};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BN=st({opType:Ce.EQUAL,dtype:"bool",cpuKernelImpl:Ck}),UN={kernelName:OC,backendName:"webgpu",kernelFunc:BN};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WN=Te({opType:ie.ERF}),VN={kernelName:NC,backendName:"webgpu",kernelFunc:WN};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zN=Te({opType:ie.EXP,cpuKernelImpl:wk,dtype:"float32"}),GN={kernelName:DC,backendName:"webgpu",kernelFunc:zN};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cf(t){const{inputs:e,attrs:n,backend:r}=t,{dim:o}=n,{input:i}=e,a=i.shape.length,u=i.shape.slice();let l=o;return o<0&&(re(-(a+1)<=o,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),l=a+o+1),u.splice(l,0,1),pe({inputs:{x:i},backend:r,attrs:{shape:u}})}const HN={kernelName:FC,backendName:"webgpu",kernelFunc:Cf};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jN=Te({opType:ie.EXPM1,cpuKernelImpl:Sk}),XN={kernelName:LC,backendName:"webgpu",kernelFunc:jN};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let _y=class{constructor(e,n){this.variableNames=["real","imag"],this.outputShape=[],this.uniforms="exponentMultiplier : f32, denominator: f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=n,this.dispatchLayout=ce(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize),this.component=e,this.shaderKey=`fft_${e}`}getUserCode(){return`
    fn unaryOpComplex(real: f32, expR: f32, imag: f32, expI: f32) -> f32 {
      ${this.component==="real"?"return real * expR - imag * expI;":"return real * expI + imag * expR;"}
    }

    fn mulMatDFT(batch: i32, index: i32) -> f32 {
      let indexRatio = f32(index) / f32(uniforms.realShape[1]);
      let exponentMultiplierTimesIndexRatio =
          uniforms.exponentMultiplier * indexRatio;

      var result = 0.0;

      for (var i = 0; i < uniforms.realShape[1]; i = i + 1) {
        // x = (-2|2 * PI / N) * index * i;
        let x = exponentMultiplierTimesIndexRatio * f32(i);
        let expR = cos(x);
        let expI = sin(x);
        let real = getReal(batch, i);
        let imag = getImag(batch, i);

        result = result +
            unaryOpComplex(real, expR, imag, expI) / uniforms.denominator;
      }

      return result;
    }

    ${se("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        setOutputAtIndex(index, mulMatDFT(coords[0], coords[1]));
      }
    }
  `}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vw(t,e,n){const r=n.tensorMap.get(t.dataId),o=Y(t.shape),i=t.shape[t.shape.length-1],a=o/i,u=[],l=pe({inputs:{x:t},backend:n,attrs:{shape:[a,i]}});u.push(l);const d=l.shape,f=new _y("real",d),p=new _y("imag",d),h=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:d},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:d}],g=e?2*Math.PI:-2*Math.PI,y=e?d[1]:1,x=[{type:"float32",data:[g]},{type:"float32",data:[y]}],v=n.runWebGPUProgram(f,h,"float32",x);u.push(v);const w=n.runWebGPUProgram(p,h,"float32",x);u.push(w);const S=zo({inputs:{real:v,imag:w},backend:n});u.push(S);const I=pe({inputs:{x:S},backend:n,attrs:{shape:t.shape}});return u.forEach(E=>n.disposeData(E.dataId)),I}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qN(t){const{inputs:e,backend:n}=t,{input:r}=e;return Vw(r,!1,n)}const KN={kernelName:MC,backendName:"webgpu",kernelFunc:qN};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let YN=class{constructor(e){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=ce(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="flipLeftRight"}getUserCode(){return`
      ${se("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let coordX = uniforms.xShape[2] - coords[2] - 1;
          let outputValue = getX(coords[0], coords[1], coordX, coords[3]);
          setOutputAtIndex(index, outputValue);
        }
      }
    `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QN={kernelName:BC,backendName:"webgpu",kernelFunc:({inputs:t,backend:e})=>{const{image:n}=t,r=e,o=new YN(n.shape);return r.runWebGPUProgram(o,[n],n.dtype)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZN=Te({opType:ie.FLOOR,cpuKernelImpl:bk}),JN={kernelName:UC,backendName:"webgpu",kernelFunc:ZN};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eO=st({opType:Ce.FLOOR_DIV,cpuKernelImpl:Ik,dtype:"int32"}),tO={kernelName:Wf,backendName:"webgpu",kernelFunc:eO};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let nO=class{constructor(e,n,r=!1){this.pixelsOpType=Wi.FROM_PIXELS,this.outputShape=[0],this.variableNames=[],this.workgroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout=ce(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize,[n,1,1]),this.importVideo=r,this.shaderKey=`fromPixels_${this.importVideo}`}getUserCode(){const e=this.importVideo?"textureLoad(src, vec2<i32>(coords.yx));":"textureLoad(src, vec2<i32>(coords.yx), 0)";return`
      @binding(1) @group(0) var src: ${this.importVideo?"texture_external":"texture_2d<f32>"};
      ${se("index")} {
        let flatIndex = index * uniforms.numChannels;
        if (flatIndex < uniforms.size) {
          let coords = getCoordsFromIndex(flatIndex);
          let values = ${e};
          for (var i = 0; i < uniforms.numChannels; i = i + 1) {
            result[flatIndex + i] = i32(floor(255.0 * values[i]));
          }
        }
      }
  `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use backend file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rO={kernelName:d0,backendName:"webgpu",kernelFunc:oO};let bi,Od=V().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function oO(t){const{inputs:e,backend:n,attrs:r}=t;let{pixels:o}=e;const{numChannels:i}=r;if(o==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");const a=typeof HTMLVideoElement<"u"&&o instanceof HTMLVideoElement,u=typeof HTMLImageElement<"u"&&o instanceof HTMLImageElement,l=typeof HTMLCanvasElement<"u"&&o instanceof HTMLCanvasElement||typeof OffscreenCanvas<"u"&&o instanceof OffscreenCanvas,d=typeof ImageBitmap<"u"&&o instanceof ImageBitmap,[f,p]=a?[o.videoWidth,o.videoHeight]:[o.width,o.height],h=[p,f,i],g=V().getBool("WEBGPU_IMPORT_EXTERNAL_TEXTURE")&&a,y=a||u;if(d||l||y){let S;if(g)S=n.device.importExternalTexture({source:o});else{if(y){const U=V().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(bi==null||U!==Od)&&(Od=U,bi=document.createElement("canvas").getContext("2d",{willReadFrequently:Od})),bi.canvas.width=f,bi.canvas.height=p,bi.drawImage(o,0,0,f,p),o=bi.canvas}const O=GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,F=n.textureManager.acquireTexture(h[1],h[0],"rgba8unorm",O);n.queue.copyExternalImageToTexture({source:o},{texture:F},[h[1],h[0]]),S=F}const I=Y(h),E=Ke(h),R=new nO(h,i,g),T=[{type:"uint32",data:[I]},{type:"uint32",data:[i]},{type:"uint32",data:[...E]}],k=n.makeTensorInfo([p,f],"int32"),D=n.tensorMap.get(k.dataId);D.resource=S;const N=n.runWebGPUProgram(R,[k],"int32",T);return n.disposeData(k.dataId),N}const x=o.data;let v=x;if(i!=null&&i!==4){v=new Uint8Array(o.width*o.height*i);const S=x.length;let I=0;for(let E=0;E<S;E++)E%4<i&&(v[I++]=x[E])}const w=n.makeTensorInfo(h,"int32",new Int32Array(v));return n.uploadToGPU(w.dataId),w}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let iO=class{constructor(e,n,r,o,i){this.uniforms="varianceEpsilon : f32,",this.workgroupSize=[128,1,1],this.size=!0,this.variableNames=["x","mean","variance"],He(e,n),He(e,r),this.outputShape=e,this.dispatchLayout=ce(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize),o!=null&&(He(e,o),this.variableNames.push("offset")),i!=null&&(He(e,i),this.variableNames.push("scale")),this.offsetShape=o,this.scaleShape=i,this.shaderKey="batchNorm"}getUserCode(){let e="0.0";this.offsetShape!=null&&(e="getOffsetByOutputIndex(index)");let n="1.0";return this.scaleShape!=null&&(n="getScaleByOutputIndex(index)"),`
      ${se("index")} {
        if (index < uniforms.size)
        {
          let xValue = getXByOutputIndex(index);
          let meanValue = getMeanByOutputIndex(index);
          let varianValue = getVarianceByOutputIndex(index);
          let offsetValue = ${e};
          let scaleValue = ${n};
          let inv = scaleValue * inverseSqrt(varianValue + f32(uniforms.varianceEpsilon));
          setOutputAtIndex(index,dot(vec3<f32>(xValue, -meanValue, offsetValue), vec3<f32>(inv, inv, 1.0)));
        }
      }
  `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sO={kernelName:WC,backendName:"webgpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:r,scale:o,offset:i,mean:a,variance:u}=t,{varianceEpsilon:l}=e,d=n,f=[r,a,u];let p=null;i!=null&&(p=i.shape,f.push(i));let h=null;o!=null&&(h=o.shape,f.push(o));const g=new iO(r.shape,a.shape,u.shape,p,h),y=[{type:"float32",data:[l]}];return d.runWebGPUProgram(g,f,r.dtype,y)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aO(t){const{inputs:e,backend:n,attrs:r}=t,{x:o,filter:i,bias:a,preluActivationWeights:u}=e,{strides:l,pad:d,dataFormat:f,dilations:p,dimRoundingMode:h,activation:g,leakyreluAlpha:y}=r,x=Cn(f),v=it(o.shape,i.shape,l,p,d,h,!1,x);return Fw({x:o,filter:i,convInfo:v,backend:n,bias:a,preluActivationWeights:u,leakyreluAlpha:y,activation:g})}const uO={kernelName:h0,backendName:"webgpu",kernelFunc:aO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lO(t){const{inputs:e,backend:n,attrs:r}=t,{x:o,filter:i,bias:a,preluActivationWeights:u}=e,{strides:l,pad:d,dilations:f,dimRoundingMode:p,activation:h,leakyreluAlpha:g}=r;let y=f;y==null&&(y=[1,1]),re(Fr(l,y),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${y}'`);const x=it(o.shape,i.shape,l,y,d,p,!0),v=[o,i],w=a!=null,S=u!=null;w&&v.push(a),S&&v.push(u);const I=[{type:"int32",data:[x.padInfo.top,x.padInfo.left]},{type:"int32",data:[x.inHeight,x.inWidth]}];let E;return x.outHeight>4&&x.outWidth>4&&x.strideWidth<=2&&x.inChannels===x.outChannels&&x.dilationHeight===1&&x.dilationWidth===1&&x.inChannels%4===0?(E=new Mw(x,w,h,S),I.push({type:"int32",data:[E.virtualWidth]})):(E=new Bw(x,w,h,S),I.push({type:"int32",data:[x.filterHeight]},{type:"int32",data:[x.filterWidth]},{type:"int32",data:[x.strideHeight,x.strideWidth]},{type:"int32",data:[x.dilationHeight,x.dilationWidth]})),h==="leakyrelu"&&(I.push({type:"float32",data:[g]}),E.uniforms+=" alpha : f32,"),n.runWebGPUProgram(E,v,"float32",I)}const cO={kernelName:m0,backendName:"webgpu",kernelFunc:lO};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let dO=class{constructor(e,n){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=n,this.dispatchLayout=ce(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`gathernd_${e}`,this.sliceDim=e,this.uniforms=`sliceDim : i32, strides : ${Ze(e)},`}getUserCode(){let e;return this.sliceDim>1?e="uniforms.strides[j]":e="uniforms.strides",`
      ${se("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          var flattenIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexTemp = i32(round(getIndices(coords[0], j)));
            let strideNum = ${e};
            flattenIndex = flattenIndex + indexTemp * strideNum;
          }

          setOutputAtIndex(index, getA(flattenIndex, coords[1]));
        }
      }
      `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fO(t){const{inputs:e,backend:n}=t,{params:r,indices:o}=e,i=o.shape,a=i[i.length-1],u=Y(r.shape),[l,d,f,p]=up(r,o),h=pe({inputs:{x:o},backend:n,attrs:{shape:[d,a]}}),g=pe({inputs:{x:r},backend:n,attrs:{shape:[Y(r.shape)/f,f]}});if(n.shouldExecuteOnCPU([r,o])||r.dtype==="string"){const S=n.readSync(o.dataId),I=n.bufferSync(r),E=$k(S,I,r.dtype,d,a,f,p,r.shape,u);return n.makeTensorInfo(l,r.dtype,E.values)}const y=new dO(a,[d,f]),x=[{type:"int32",data:[a]},{type:"int32",data:p}],v=n.runWebGPUProgram(y,[g,h],g.dtype,x),w=pe({inputs:{x:v},backend:n,attrs:{shape:l}});return n.disposeData(h.dataId),n.disposeData(g.dataId),n.disposeData(v.dataId),w}const pO={kernelName:zC,backendName:"webgpu",kernelFunc:fO};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let hO=class{constructor(e,n){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.slice(),this.aShape=e,this.outputShape=n,this.dispatchLayout=ce(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="gather"}getUserCode(){const e=mO(this.aShape);return`
      ${se("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let indexZ = i32(getIndices(resRC.x, resRC.z));
          let inBounds = select(0.0, 1.0, indexZ >= 0 && indexZ < uniforms.aShape[2]);
          setOutputAtIndex(index, inBounds * getA(${e}));
        }
      }
    `}};function mO(t){const e=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let r=0;r<t.length;r++)r===2?n.push("indexZ"):n.push(`${e[r]}`);return n.join()}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zw(t){const{inputs:e,backend:n,attrs:r}=t,{x:o,indices:i}=e,{axis:a,batchDims:u}=r,l=Je(a,o.shape)[0],d=Dp(o,i,l,u),f=Y(i.shape),p=[],h=pe({inputs:{x:o},backend:n,attrs:{shape:[d.batchSize,d.outerSize,d.dimSize,d.sliceSize]}}),g=pe({inputs:{x:i},backend:n,attrs:{shape:[d.batchSize,f/d.batchSize]}});p.push(h),p.push(g);const y=[d.batchSize,d.outerSize,f/d.batchSize,d.sliceSize];if(n.shouldExecuteOnCPU([o,i])){const I=n.tensorMap.get(g.dataId).values,E=Xe(g.shape,g.dtype,I),T=n.tensorMap.get(h.dataId).values,k=Xe(h.shape,h.dtype,T),D=Rk(k,E,y);return p.forEach(N=>n.disposeData(N.dataId)),n.makeTensorInfo(d.outputShape,D.dtype,D.values)}const x=new hO(h.shape,y),v=n.runWebGPUProgram(x,[h,g],h.dtype);p.push(v);const w=pe({inputs:{x:v},backend:n,attrs:{shape:d.outputShape}});return p.forEach(S=>n.disposeData(S.dataId)),w}const gO={kernelName:VC,backendName:"webgpu",kernelFunc:zw};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yO=st({opType:Ce.GREATER,cpuKernelImpl:_k,dtype:"bool"}),xO={kernelName:GC,backendName:"webgpu",kernelFunc:yO};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vO=st({opType:Ce.GREATER_EQUAL,dtype:"bool",cpuKernelImpl:Ek}),CO={kernelName:HC,backendName:"webgpu",kernelFunc:vO};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wO(t){const{inputs:e,backend:n}=t,{input:r}=e;return Vw(r,!0,n)}const SO={kernelName:jC,backendName:"webgpu",kernelFunc:wO};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bO=Te({opType:ie.IS_FINITE,dtype:"bool"}),IO={kernelName:qC,backendName:"webgpu",kernelFunc:bO};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $O=Te({opType:ie.IS_INF,dtype:"bool"}),RO={kernelName:KC,backendName:"webgpu",kernelFunc:$O};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EO=Te({opType:ie.IS_NAN,dtype:"bool"}),_O={kernelName:YC,backendName:"webgpu",kernelFunc:EO};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PO(t){const{inputs:e,backend:n,attrs:r}=t,{x:o}=e,{alpha:i}=r,a=[{type:"float32",data:[i]}],u=new ji(o.shape,ie.LEAKYRELU,"alpha : f32,");return n.runWebGPUProgram(u,[o],"float32",a)}const kO={kernelName:Vf,backendName:"webgpu",kernelFunc:PO};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TO=st({opType:Ce.LESS,dtype:"bool",cpuKernelImpl:kk}),AO={kernelName:QC,backendName:"webgpu",kernelFunc:TO};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NO=st({opType:Ce.LESS_EQUAL,dtype:"bool",cpuKernelImpl:Pk}),OO={kernelName:ZC,backendName:"webgpu",kernelFunc:NO};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class DO{constructor(e){this.variableNames=[],this.outputShape=[],this.uniforms="start : f32, step : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e],this.dispatchLayout=ce(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="linSpace"}getUserCode(){return`
      ${se("index")} {
        if (index < uniforms.size) {
          setOutputAtIndex(index, uniforms.start + f32(index) * uniforms.step);
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FO(t){const{backend:e,attrs:n}=t,{start:r,stop:o,num:i}=n,a=(o-r)/(i-1),u=new DO(i),l=[{type:"float32",data:[r]},{type:"float32",data:[a]}];return e.runWebGPUProgram(u,[],"float32",l)}const LO={kernelName:JC,backendName:"webgpu",kernelFunc:FO};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MO=Te({opType:ie.LOG,cpuKernelImpl:Tk}),BO={kernelName:e1,backendName:"webgpu",kernelFunc:MO};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UO=Te({opType:ie.LOG1P}),WO={kernelName:t1,backendName:"webgpu",kernelFunc:UO};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VO=st({opType:Ce.LOGICAL_AND,dtype:"bool"}),zO={kernelName:n1,backendName:"webgpu",kernelFunc:VO};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GO=Te({opType:ie.LOGICAL_NOT}),HO={kernelName:r1,backendName:"webgpu",kernelFunc:GO};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jO=st({opType:Ce.LOGICAL_OR}),XO={kernelName:o1,backendName:"webgpu",kernelFunc:jO};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gw=`
  var powValue = 0.0;
  let basis = uniforms.bias + uniforms.alpha * sum;
  if (uniforms.beta == 0.5) {
    powValue = inverseSqrt(basis);
  } else if (uniforms.beta == 1.0) {
    powValue = 1.0 / basis;
  } else {
    powValue = exp(log(basis) * (-uniforms.beta));
  }
`;let qO=class{constructor(e){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=ce(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn"}getUserCode(){return`
    ${se("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let b = coords[0];
        let r = coords[1];
        let c = coords[2];
        let d = coords[3];

        let x = getX(b, r, c, d);
        var sum = 0.0;
        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {
          let idx = d + i;
          if (idx >= 0 && idx < uniforms.xShape[3]) {
            let z = getX(b, r, c, idx);
            sum = sum + z * z;
          }
        }
        ${Gw}

        setOutputAtIndex(index, x * powValue);
      }
    }
  `}};class KO{constructor(e,n){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[256,1,1],this.maxAllowRadius=16,re(n<=this.maxAllowRadius,()=>`Radius must be less than or equal to ${this.maxAllowRadius}, current radius is ${n}`),this.outputShape=e,this.elementsPerWorkgroup=this.workgroupSize[0]-2*this.maxAllowRadius,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=ae(this.dispatchLayout,this.outputShape,[this.elementsPerWorkgroup,this.workgroupSize[1],this.workgroupSize[2]]),this.shaderKey="lrn_shared"}getUserCode(){return`
    var <workgroup>lrnSub: array<f32, ${this.workgroupSize[0]}>;
    const elementsPerWorkgroup = ${this.elementsPerWorkgroup};
    const maxAllowRadius = ${this.maxAllowRadius};

    ${se()} {
      let localDepth = i32(localId.x);
      let workgroupDepth = i32(workgroupId.x) * elementsPerWorkgroup;
      let xDepth = workgroupDepth + localDepth - maxAllowRadius;
      let b = i32(globalId.z) / uniforms.xShape[1];
      let r = i32(globalId.z) - b * uniforms.xShape[1];
      let c = i32(globalId.y);
      let d = workgroupDepth + localDepth;

      var x = 0.0;
      if (xDepth >= 0 && xDepth < uniforms.xShape[3]) {
        x = getX(b, r, c, xDepth);
      }
      lrnSub[localDepth] = x;
      workgroupBarrier();

      if (localDepth < elementsPerWorkgroup && d < uniforms.outShape[3]) {
        var sum = 0.0;
        let index = localDepth + maxAllowRadius;
        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {
          let z = lrnSub[index + i];
          sum = sum + z * z;
        }
        ${Gw}

        setOutputAtCoords(b, r, c, d, lrnSub[index] * powValue);
      }
    } `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YO(t){const{inputs:e,backend:n,attrs:r}=t,{x:o}=e,{depthRadius:i,bias:a,alpha:u,beta:l}=r;let d;i>16?d=new qO(o.shape):d=new KO(o.shape,i);const f=[{type:"int32",data:[i]},{type:"float32",data:[a]},{type:"float32",data:[u]},{type:"float32",data:[l]}];return n.runWebGPUProgram(d,[o],o.dtype,f)}const QO={kernelName:i1,backendName:"webgpu",kernelFunc:YO};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ZO=class{constructor(e){this.outputShape=[],this.variableNames=["inputImage","outputImage","dy"],this.uniforms="depthRadius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=ce(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn_grad"}getUserCode(){return`
    ${se("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let b = coords[0];
        let r = coords[1];
        let c = coords[2];

        let MIN_DEPTH_BEGIN = 0;
        let MAX_DEPTH_END = uniforms.outShape[3];
        var result = 0.0;
        for (var d = MIN_DEPTH_BEGIN; d < MAX_DEPTH_END; d++) {
          let depthBegin = max(MIN_DEPTH_BEGIN, d - uniforms.depthRadius);
          let depthEnd = min(MAX_DEPTH_END, d + uniforms.depthRadius + 1);

          var norm = 0.0;
          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {
            if (k < depthBegin) {
              continue;
            } else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            } else {
              break;
            }
          }

          norm = uniforms.alpha * norm + uniforms.bias;

          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {
            if (k < depthBegin) {
              continue;
            } else if (k >= depthBegin && k < depthEnd) {
              var dyi = -2.0 * uniforms.alpha * uniforms.beta
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d) / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * uniforms.beta);
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            } else {
              break;
            }
          }
        }

        setOutputAtIndex(index, result);
      }
    }
  `}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JO(t){const{inputs:e,backend:n,attrs:r}=t,{x:o,y:i,dy:a}=e,{depthRadius:u,bias:l,alpha:d,beta:f}=r,p=new ZO(o.shape),h=[{type:"int32",data:[u]},{type:"float32",data:[l]},{type:"float32",data:[d]},{type:"float32",data:[f]}];return n.runWebGPUProgram(p,[o,i,a],o.dtype,h)}const eD={kernelName:s1,backendName:"webgpu",kernelFunc:JO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tD=st({opType:Ce.MAX,cpuKernelImpl:Nk}),nD={kernelName:zf,backendName:"webgpu",kernelFunc:tD};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rD(t){const{inputs:e,backend:n,attrs:r}=t,{x:o}=e,{filterSize:i,strides:a,pad:u,dimRoundingMode:l}=r,f=vn(o.shape,i,a,1,u,l);return Aw(o,f,"max",n)}const oD={kernelName:u1,backendName:"webgpu",kernelFunc:rD};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iD(t){const{inputs:e,backend:n,attrs:r}=t,{x:o}=e,{filterSize:i,strides:a,pad:u,dataFormat:l,dimRoundingMode:d}=r,f=[1,1,1],p=Zn(o.shape,i,a,f,u,d,l),h=new Mp(p,"max"),g=[{type:"int32",data:[p.strideDepth,p.strideHeight,p.strideWidth]},{type:"int32",data:[p.padInfo.front,p.padInfo.top,p.padInfo.left]},{type:"int32",data:[p.inDepth,p.inHeight,p.inWidth]},{type:"int32",data:[p.effectiveFilterDepth,p.effectiveFilterHeight,p.effectiveFilterWidth]}];return n.runWebGPUProgram(h,[o],o.dtype,g)}const sD={kernelName:c1,backendName:"webgpu",kernelFunc:iD};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let aD=class{constructor(e){this.variableNames=["dy","maxPos"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=ce(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="maxPool2DBackprop"}getUserCode(){return`
      ${se("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d = coords[3];

        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;
        let dyRCorner = dyRCCorner.x;
        let dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] - 1;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR += uniforms.dilations[0]) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims[1]; wC += uniforms.dilations[1]) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }
            let idyC = i32(dyC);

            let dyValue = getDy(batch, idyR, idyC, d);
            let maxPosValue = lastIndex - i32(getMaxPos(batch, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            let curPosValue = wR * uniforms.filterDims[1] + wC;
            let mask = select(0.0, 1.0, maxPosValue == curPosValue);
            dotProd += dyValue * mask;
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}},uD=class{constructor(e){this.variableNames=["dy","maxPos"],this.uniforms=`strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,
      outDepth : i32, outHeight : i32, outWidth : i32`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=ce(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="maxPool3DBackprop"}getUserCode(){return`
      ${se("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let ch = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyDCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] * uniforms.filterDims[2] - 1;

        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {
          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);

          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {
            continue;
          }
          let idyD = i32(dyD);

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let dyValue = getDy(batch, idyD, idyR, idyC, ch);
              let maxPosValue = lastIndex - i32(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              let curPosValue = wD * uniforms.filterDims[1] * uniforms.filterDims[2] + wR * uniforms.filterDims[2] + wC;
              let mask = select(0.0, 1.0, maxPosValue == curPosValue);
              dotProd += dyValue * mask;
            }
          }
        }

        setOutputAtIndex(index, dotProd);
      }
    }
    `}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lD(t){const{inputs:e,backend:n,attrs:r}=t,{dy:o,input:i}=e,a=i,{filterSize:u,strides:l,pad:d,dimRoundingMode:f}=r,p=[1,1,1],h=Zn(a.shape,u,l,p,d,f),g=new Mp(h,"max",!0);let y=[{type:"int32",data:[h.strideDepth,h.strideHeight,h.strideWidth]},{type:"int32",data:[h.padInfo.front,h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.inDepth,h.inHeight,h.inWidth]},{type:"int32",data:[h.effectiveFilterDepth,h.effectiveFilterHeight,h.effectiveFilterWidth]}];const x=n.runWebGPUProgram(g,[a],"int32",y),v=new uD(h);y=[{type:"int32",data:[h.strideDepth,h.strideHeight,h.strideWidth]},{type:"int32",data:[h.effectiveFilterDepth-1-h.padInfo.front,h.effectiveFilterHeight-1-h.padInfo.top,h.effectiveFilterWidth-1-h.padInfo.left]},{type:"int32",data:[h.effectiveFilterDepth,h.effectiveFilterHeight,h.effectiveFilterWidth]},{type:"int32",data:[h.outDepth]},{type:"int32",data:[h.outHeight]},{type:"int32",data:[h.outWidth]}];const w=n.runWebGPUProgram(v,[o,x],a.dtype,y);return n.disposeData(x.dataId),w}const cD={kernelName:d1,backendName:"webgpu",kernelFunc:lD};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dD(t){const{inputs:e,backend:n,attrs:r}=t,{dy:o,input:i,output:a}=e,u=i;bw([i,a],"maxPoolGrad");const{filterSize:l,strides:d,pad:f,dimRoundingMode:p}=r,h=vn(u.shape,l,d,1,f,p),g=new ma(h,"max",!0);let y=[{type:"int32",data:[h.strideHeight,h.strideWidth]},{type:"int32",data:[h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.dilationHeight,h.dilationWidth]},{type:"int32",data:[h.inHeight,h.inWidth]},{type:"int32",data:[h.effectiveFilterHeight,h.effectiveFilterWidth]}];const x=n.runWebGPUProgram(g,[u],"int32",y),v=new aD(h);y=[{type:"int32",data:[h.strideHeight,h.strideWidth]},{type:"int32",data:[h.effectiveFilterHeight-1-h.padInfo.top,h.effectiveFilterWidth-1-h.padInfo.left]},{type:"int32",data:[h.dilationHeight,h.dilationWidth]},{type:"int32",data:[h.effectiveFilterHeight,h.effectiveFilterWidth]},{type:"int32",data:[h.outHeight]},{type:"int32",data:[h.outWidth]}];const w=n.runWebGPUProgram(v,[o,x],u.dtype,y);return n.disposeData(x.dataId),w}const fD={kernelName:l1,backendName:"webgpu",kernelFunc:dD};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pD(t){const{inputs:e,backend:n,attrs:r}=t,{filterSize:o,strides:i,pad:a,includeBatchInIndex:u}=r,{x:l}=e;re(l.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${l.shape.length}.`);const d=[1,1];re(Fr(i,d),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${d}'`);const f=vn(l.shape,o,i,d,a),p=[{type:"int32",data:[f.strideHeight,f.strideWidth]},{type:"int32",data:[f.padInfo.top,f.padInfo.left]},{type:"int32",data:[f.dilationHeight,f.dilationWidth]},{type:"int32",data:[f.inHeight,f.inWidth]},{type:"int32",data:[f.effectiveFilterHeight,f.effectiveFilterWidth]}];let h=new ma(f,"max",!1);const g=n.runWebGPUProgram(h,[l],l.dtype,p);h=new ma(f,"max",!0,!0,u);const y=n.runWebGPUProgram(h,[l],"int32",p);return[g,y]}const hD={kernelName:f1,backendName:"webgpu",kernelFunc:pD};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mD(t){const{inputs:e,backend:n,attrs:r}=t,{x:o}=e,{axis:i,keepDims:a}=r;return Go(o,i,a,"min",n)}const gD={kernelName:h1,backendName:"webgpu",kernelFunc:mD};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yD=st({opType:Ce.MIN,cpuKernelImpl:Ok}),xD={kernelName:m1,backendName:"webgpu",kernelFunc:yD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let vD=class{constructor(e,n,r){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=n.map((o,i)=>o[0]+e[i]+o[1]),this.dispatchLayout=ce(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=e,n.map((o,i)=>{this.uniforms+=` pad${i} : vec2<i32>,`}),this.offset=r==="reflect"?0:1,this.shaderKey=`mirrorPad_${r}`}getUserCode(){const e=this.xShape.length,n=this.xShape.map((d,f)=>`uniforms.pad${f}[0]`).join(","),r=this.xShape.map((d,f)=>`uniforms.pad${f}[0] + uniforms.xShape${e>1?`[${f}]`:""}`).join(","),o=e===1?"start":"start[i]",i=e===1?"end":"end[i]",a=e===1?"outC":"outC[i]",u=Ze(e),l=e>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,e):"coords";return`
      ${se("index")} {
        if (index < uniforms.size) {
          let start = ${u}(${n});
          let end = ${u}(${r});
          var outC = getCoordsFromIndex(index);
          for (var i = 0; i < ${e}; i = i + 1) {
            if (${a} < ${o}) {
              ${a} = ${o} * 2 - ${a} - ${this.offset};
            } else if(${a} >= ${i}) {
              ${a} = (${i} - 1) * 2 - ${a} + ${this.offset};
            }
          }
          let coords = outC - start;
          setOutputAtIndex(index, getX(${l}));
        }
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CD={kernelName:g1,backendName:"webgpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:r}=t,{paddings:o,mode:i}=e,a=n,u=o.map(f=>({type:"int32",data:[f[0],f[1]]})),l=new vD(r.shape,o,i);return a.runWebGPUProgram(l,[r],r.dtype,u)}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wD=st({opType:Ce.MOD}),SD={kernelName:y1,backendName:"webgpu",kernelFunc:wD};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let bD=class{constructor(e,n){this.variableNames=["probs"],this.outputShape=[],this.uniforms="seed : f32, numOutcomes: i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,n],this.dispatchLayout=ce(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="multinomial"}getUserCode(){return`
    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    fn random (seed : f32, resultUV : vec2<f32>) -> f32 {
      let HASHSCALE1 = 443.8975;
      let p = resultUV * seed;
      var p3  = fract(vec3<f32>(p.xyx) * HASHSCALE1);
      p3 = p3 + dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${se("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let batch = coords[0];

        let resUV = vec2<f32>(f32(coords[1]) / f32(uniforms.outShape[1]),
            f32(coords[0]) / f32(uniforms.outShape[0]));
        let r = random(uniforms.seed, resUV);
        var cdf = 0.0;
        for (var i = 0; i < uniforms.numOutcomes - 1; i = i + 1) {
          cdf = cdf + getProbs(batch, i);

          if (r < cdf) {
            setOutputAtIndexI32(index, i);
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutputAtIndexI32(index, uniforms.numOutcomes - 1);
      }
    }
  `}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ID{constructor(e){this.variableNames=["logits"],this.outputShape=e,this.dispatchLayout=ce(this.outputShape),this.dispatch=[this.outputShape[0],1,1],this.outputShape[1]>=4096?this.workgroupSize=[256,1,1]:this.workgroupSize=[64,1,1],this.shaderKey="softmax"}getUserCode(){return`
    var<workgroup> buf : array<f32, ${this.workgroupSize[0]}>;
    var<workgroup> rowMaxShared : f32;
    var<workgroup> rowSumShared : f32;
    const blockSize = ${this.workgroupSize[0]};
    ${se("index")} {
      let row = index / blockSize;
      let tid = i32(localId.x);
      let cols = uniforms.outShape[1];

      var threadMax = -3.402823e+38f;
      for (var col = tid; col < cols; col += blockSize) {
        let value = getLogits(row, col);
        threadMax = max(threadMax, value);
      }
      if (tid < cols) {
        buf[tid] = threadMax;
      }
      workgroupBarrier();

      var reduceSize = min(cols, blockSize);
      for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
        reduceSize = currSize + (reduceSize & 1);
        if (tid < currSize) {
          buf[tid] = max(buf[tid], buf[tid + reduceSize]);
        }
        workgroupBarrier();
      }

      if (tid == 0) {
        rowMaxShared = buf[0];
      }
      workgroupBarrier();

      var threadSum = 0.0;
      for (var col = tid; col < cols; col += blockSize) {
        let subExp = exp(getLogits(row, col) - rowMaxShared);
        threadSum += subExp;
      }
      buf[tid] = threadSum;
      workgroupBarrier();

      for (var currSize = blockSize >> 1;  currSize > 0; currSize = currSize >> 1) {
        if (tid < currSize) {
          buf[tid] = buf[tid] + buf[tid + currSize];
        }
        workgroupBarrier();
      }

      if (tid == 0) {
        rowSumShared = buf[0];
      }
      workgroupBarrier();

      for (var col = tid; col < cols; col += blockSize) {
        let value = exp(getLogits(row, col) - rowMaxShared) / rowSumShared;
        setOutputAtCoords(row, col, value);
      }
  }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hw(t){const{inputs:e,backend:n,attrs:r}=t,{logits:o}=e,{dim:i}=r,a=pe({inputs:{x:o},backend:n,attrs:{shape:[Y(o.shape)/o.shape[i],o.shape[i]]}}),u=new ID(a.shape),l=n.runWebGPUProgram(u,[a],o.dtype),d=pe({inputs:{x:l},backend:n,attrs:{shape:o.shape}});return n.disposeData(a.dataId),n.disposeData(l.dataId),d}const $D={kernelName:Y1,backendName:"webgpu",kernelFunc:Hw};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RD(t){const{inputs:e,backend:n,attrs:r}=t,{logits:o}=e,{numSamples:i,seed:a,normalized:u}=r,l=u?o:Hw({inputs:{logits:o},backend:n,attrs:{dim:o.shape.length-1}}),d=l.shape[0],f=l.shape[1],p=new bD(d,i),h=[{type:"float32",data:[a]},{type:"int32",data:[f]}],g=n.runWebGPUProgram(p,[l],"int32",h);return u||n.disposeData(l.dataId),g}const ED={kernelName:x1,backendName:"webgpu",kernelFunc:RD};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _D(t){const{inputs:e,backend:n}=t,{x:r}=e;if(n.shouldExecuteOnCPU([r])){const i=n.tensorMap.get(r.dataId),[a,u]=Fk(i.values,r.shape,r.dtype);return n.makeTensorInfo(u,r.dtype,a)}const o=new ji(r.shape,ie.NEG);return n.runWebGPUProgram(o,[r],r.dtype)}const PD={kernelName:v1,backendName:"webgpu",kernelFunc:_D};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kD(t){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:r}=t,{boxes:o,scores:i}=e,{maxOutputSize:a,iouThreshold:u,scoreThreshold:l}=r,d=n.readSync(o.dataId),f=n.readSync(i.dataId),{selectedIndices:p}=H0(d,f,a,u,l);return n.makeTensorInfo([p.length],"int32",new Int32Array(p))}const TD={kernelName:w1,backendName:"webgpu",kernelFunc:kD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AD(t){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:r}=t,{boxes:o,scores:i}=e,{maxOutputSize:a,iouThreshold:u,scoreThreshold:l,softNmsSigma:d}=r,f=n.readSync(o.dataId),p=n.readSync(i.dataId),h=a,g=u,y=l,x=d,{selectedIndices:v,selectedScores:w}=j0(f,p,h,g,y,x);return[n.makeTensorInfo([v.length],"int32",new Int32Array(v)),n.makeTensorInfo([w.length],"float32",new Float32Array(w))]}const ND={kernelName:S1,backendName:"webgpu",kernelFunc:AD};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let OD=class{constructor(e,n){this.variableNames=["x"],this.uniforms="onValue : f32, offValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,n],this.dispatchLayout=ce(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="onehot"}getUserCode(){return`
      ${se("index")} {
        if(index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          setOutputAtIndex(index, mix(uniforms.offValue, uniforms.onValue,
                                      f32(i32(round(getX(coords.x))) == coords.y)));
        }
      }
    `}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DD(t){const{inputs:e,backend:n,attrs:r}=t,{indices:o}=e,{dtype:i,depth:a,onValue:u,offValue:l}=r,d=Y(o.shape),f=new OD(d,a),p=pe({inputs:{x:o},backend:n,attrs:{shape:[d]}}),h=[{type:"float32",data:[u]},{type:"float32",data:[l]}],g=n.runWebGPUProgram(f,[p],i,h);n.disposeData(p.dataId);const y=[...o.shape,a],x=pe({inputs:{x:g},backend:n,attrs:{shape:y}});return n.disposeData(g.dataId),x}const FD={kernelName:I1,backendName:"webgpu",kernelFunc:DD};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dl(t){const{inputs:e,backend:n}=t,{x:r}=e;if(r.dtype==="complex64"){const o=Pa({inputs:{input:r},backend:n}),i=dl({inputs:{x:o},backend:n}),a=El({inputs:{input:r},backend:n}),u=dl({inputs:{x:a},backend:n}),l=zo({inputs:{real:i,imag:u},backend:n});return n.disposeData(o.dataId),n.disposeData(i.dataId),n.disposeData(a.dataId),n.disposeData(u.dataId),l}else return $t({attrs:{shape:r.shape,dtype:r.dtype,value:r.dtype==="string"?"":0},backend:n})}const LD={kernelName:tp,backendName:"webgpu",kernelFunc:dl};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jw(t){const{inputs:e,backend:n}=t,{x:r}=e;if(r.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(r.dtype==="complex64"){const o=Pa({inputs:{input:r},backend:n}),i=jw({inputs:{x:o},backend:n}),a=El({inputs:{input:r},backend:n}),u=dl({inputs:{x:a},backend:n}),l=zo({inputs:{real:i,imag:u},backend:n});return n.disposeData(o.dataId),n.disposeData(i.dataId),n.disposeData(a.dataId),n.disposeData(u.dataId),l}else return $t({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:n})}const MD={kernelName:b1,backendName:"webgpu",kernelFunc:jw};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BD(t){const{inputs:e,backend:n,attrs:r}=t,{axis:o}=r;if(e.length===1)return Cf({inputs:{input:e[0]},backend:n,attrs:{dim:o}});const i=e[0].shape,a=e[0].dtype;e.forEach(f=>{Tf(i,f.shape,"All tensors passed to stack must have matching shapes"),re(a===f.dtype,()=>"All tensors passed to stack must have matching dtypes")});const u=[],l=e.map(f=>{const p=Cf({inputs:{input:f},backend:n,attrs:{dim:o}});return u.push(p),p}),d=Dw({inputs:l,backend:n,attrs:{axis:o}});return u.forEach(f=>n.disposeData(f.dataId)),d}const UD={kernelName:$1,backendName:"webgpu",kernelFunc:BD};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xw(t,e=!1){const n=t.length,r=Ze(n),o=t.map((p,h)=>`uniforms.pad${h}[0]`).join(","),i=t.map((p,h)=>`uniforms.pad${h}[0] + uniforms.xShape${n>1?`[${h}]`:""}`).join(","),a=n>1?`${r}(${o})`:`${o}`,u=n>1?`${r}(${i})`:`${i}`,l=n>1?"any(paddedCoords < start)":"paddedCoords < start",d=n>1?"any(paddedCoords >= end)":"paddedCoords >= end",f=n>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,n):"coords";return`
        let start = ${a};
        let end = ${u};
        if (${l} || ${d}) {
          setOutputAtIndex(index, ${e?0:"uniforms.constantValue"});
        } else {
          let coords = paddedCoords - start;
          setOutputAtIndex(index, getX(${f}));
        }
  `}let WD=class{constructor(e,n){this.variableNames=["x"],this.uniforms="constantValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=n.map((r,o)=>r[0]+e[o]+r[1]),this.dispatchLayout=ce(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize),n.map((r,o)=>{this.uniforms+=` pad${o} : vec2<i32>,`}),this.xShape=e,this.shaderKey="pad"}getUserCode(){return`
      ${se("index")} {
        if (index < uniforms.size) {
          let paddedCoords = getCoordsFromIndex(index);
          ${Xw(this.xShape)}
        }
      }
    `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VD=t=>{const{inputs:e,backend:n,attrs:r}=t,{x:o}=e,{paddings:i,constantValue:a}=r;if(i.every(d=>je(d,[0,0])))return Ot({inputs:{x:o},backend:n});if(Y(o.shape)===0){const d=i.map((f,p)=>f[0]+o.shape[p]+f[1]);return $t({backend:n,attrs:{shape:d,value:a,dtype:o.dtype}})}const u=[{type:"float32",data:[a]}];i.map(d=>u.push({type:"int32",data:[d[0],d[1]]}));const l=new WD(o.shape,i);return n.runWebGPUProgram(l,[o],o.dtype,u)},zD={kernelName:R1,backendName:"webgpu",kernelFunc:VD};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GD=st({opType:Ce.POW}),HD={kernelName:Hf,backendName:"webgpu",kernelFunc:GD};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jD(t){const{inputs:e,backend:n}=t,{x:r,alpha:o}=e,i=new ul(Ce.PRELU,r.shape,o.shape);return n.runWebGPUProgram(i,[r,o],"float32")}const XD={kernelName:jf,backendName:"webgpu",kernelFunc:jD};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qD(t){const{inputs:e,backend:n,attrs:r}=t,{x:o}=e,{axis:i,keepDims:a}=r;return Go(o,i,a,"prod",n)}const KD={kernelName:E1,backendName:"webgpu",kernelFunc:qD};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YD=t=>{const{backend:e,attrs:n}=t,{start:r,stop:o,step:i,dtype:a}=n,u=Bk(r,o,i,a);return e.makeTensorInfo([u.length],a,u)},QD={kernelName:_1,backendName:"webgpu",kernelFunc:YD};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZD=st({opType:Ce.DIV}),JD={kernelName:Mf,backendName:"webgpu",kernelFunc:ZD};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const e3=Te({opType:ie.RECIPROCAL}),t3={kernelName:k1,backendName:"webgpu",kernelFunc:e3};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const n3=Te({opType:ie.RELU}),r3={kernelName:Xf,backendName:"webgpu",kernelFunc:n3};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const o3=Te({opType:ie.RELU6}),i3={kernelName:Kf,backendName:"webgpu",kernelFunc:o3};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let s3=class{constructor(e,n,r){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, halfPixelCenters : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],n,r,e[3]],this.dispatchLayout=ce(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="resizeBilinear"}getUserCode(){return`
      ${se("index")} {
        if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC =
            (vec2<f32>(rc) + vec2<f32>(uniforms.halfPixelCenters)) *
            effectiveInputOverOutputRatioRC - vec2<f32>(uniforms.halfPixelCenters);

          // Compute the four integer indices.
          let sourceFloorRC = vec2<i32>(sourceFracIndexRC);
          let sourceCeilRC = vec2<i32>(
            min(vec2<f32>(uniforms.xShape.yz) - vec2<f32>(1.0), ceil(sourceFracIndexRC)));

          let topLeft = getX(b, sourceFloorRC.x, sourceFloorRC.y, d);
          let bottomLeft = getX(b, sourceCeilRC.x, sourceFloorRC.y, d);
          let topRight = getX(b, sourceFloorRC.x, sourceCeilRC.y, d);
          let bottomRight = getX(b, sourceCeilRC.x, sourceCeilRC.y, d);

          let fracRC = sourceFracIndexRC - vec2<f32>(sourceFloorRC);

          let top = topLeft + (topRight - topLeft) * fracRC.y;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
          let newValue = top + (bottom - top) * fracRC.x;

          setOutputAtIndex(index, newValue);
        }
      }
    `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a3(t){const{inputs:e,backend:n,attrs:r}=t,{images:o}=e,{alignCorners:i,size:a,halfPixelCenters:u}=r,[l,d]=a,f=i&&l>1?1:0,p=i&&d>1?1:0,g=[{type:"float32",data:[f,p]},{type:"float32",data:[u?.5:0]}],y=new s3(o.shape,l,d);return n.runWebGPUProgram(y,[o],"float32",g)}const u3={kernelName:N1,backendName:"webgpu",kernelFunc:a3};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let l3=class{constructor(e,n){this.variableNames=["dy"],this.uniforms=`effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, heightScale : f32, widthScale : f32,
       invHeightScale : f32, invWidthScale : f32, winHeight : i32, winWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=ce(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize),this.alignCorners=n,this.shaderKey=`resizeBilinearBackprop_${n}`}getUserCode(){return`
      ${se("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let b = coords[0];
          let d = coords[3];
          let r = coords[1];
          let c = coords[2];

          var accumulator = 0.0;

          // Compute bounds for where in dy we will look
          let startRLerp = floor(f32(r) * uniforms.invHeightScale);
          let startDyR = i32(startRLerp - f32(uniforms.winHeight / 2));

          let startCLerp = floor(f32(c) * uniforms.invWidthScale);
          let startDyC = i32(startCLerp - f32(uniforms.winWidth / 2));

          // Loop over dy
          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {
            let dyR = startDyR + dyROffset;

            // Guard against the window exceeding the bounds of dy
            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {
              continue;
            }

            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {
              let dyC = startDyC + dyCOffset;

              // Guard against the window exceeding the bounds of dy
              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {
                continue;
              }

              let dxR = f32(dyR) * uniforms.heightScale;
              let topDxRIndex = i32(floor(dxR));
              let bottomDxRIndex = i32(min(ceil(dxR), f32(uniforms.outShape[1] - 1)));
              let dxRLerp = dxR - f32(topDxRIndex);
              let inverseDxRLerp = 1.0 - dxRLerp;

              let dxC = f32(dyC) * uniforms.widthScale;
              let leftDxCIndex = i32(floor(dxC));
              let rightDxCIndex = i32(min(ceil(dxC), f32(uniforms.outShape[2] - 1)));
              let dxCLerp = dxC - f32(leftDxCIndex);
              let inverseDxCLerp = 1.0 - dxCLerp;

              if (r == topDxRIndex && c == leftDxCIndex) {
                // topLeft
                accumulator +=
                  getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
              }

              if (r == topDxRIndex && c == rightDxCIndex) {
                // topRight
                accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
              }

              if (r == bottomDxRIndex && c == leftDxCIndex) {
                // bottomLeft
                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
              }

              if (r == bottomDxRIndex && c == rightDxCIndex) {
                // bottomRight
                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
              }
            }
          }
          // End loop over dy

          setOutputAtIndex(index, accumulator);
        }
      }
    `}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c3(t){const{inputs:e,backend:n,attrs:r}=t,{images:o,dy:i}=e,{alignCorners:a}=r,[,u,l]=o.shape,[,d,f]=i.shape,p=[a&&d>1?u-1:u,a&&f>1?l-1:l],h=[a&&d>1?d-1:d,a&&f>1?f-1:f],g=p[0]/h[0],y=p[1]/h[1],x=1/g,v=1/y,w=Math.ceil(x)*2+2,S=Math.ceil(v)*2+2,I=new l3(o.shape,a),E=[{type:"int32",data:p},{type:"int32",data:h},{type:"float32",data:[g]},{type:"float32",data:[y]},{type:"float32",data:[x]},{type:"float32",data:[v]},{type:"int32",data:[w]},{type:"int32",data:[S]}];return n.runWebGPUProgram(I,[i],i.dtype,E)}const d3={kernelName:O1,backendName:"webgpu",kernelFunc:c3};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let f3=class{constructor(e,n,r,o){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, roundBase : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],n,r,e[3]],this.dispatchLayout=ce(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize),this.halfPixelCenters=o,this.shaderKey=`resizeNearest_${o}`}getUserCode(){let e;return this.halfPixelCenters?e="max((vec2<f32>(rc) + vec2<f32>(0.5)) * effectiveInputOverOutputRatioRC, vec2<f32>(0.0))":e="vec2<f32>(rc) * effectiveInputOverOutputRatioRC",`
      ${se("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC = ${e};

          // Compute the coordinators of nearest neighbor point.
          let inputShapeRC = vec2<f32>(f32(uniforms.xShape.y), f32(uniforms.xShape.z));
          let sourceNearestRC = vec2<i32>(
            min(inputShapeRC - 1.0, floor(sourceFracIndexRC + uniforms.roundBase)));
          let newValue = getX(b, sourceNearestRC.x, sourceNearestRC.y, d);

          setOutputAtIndex(index, newValue);
        }
      }
    `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p3(t){const{inputs:e,backend:n,attrs:r}=t,{images:o}=e,{alignCorners:i,halfPixelCenters:a,size:u}=r,[l,d]=u,f=i&&l>1?1:0,p=i&&d>1?1:0,g=[{type:"float32",data:[f,p]},{type:"float32",data:[i?.5:0]}],y=new f3(o.shape,l,d,a);return n.runWebGPUProgram(y,[o],o.dtype,g)}const h3={kernelName:T1,backendName:"webgpu",kernelFunc:p3};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let m3=class{constructor(e,n){this.variableNames=["dy"],this.uniforms=`effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, invHeightScale : f32, invWidthScale : f32,
       winHeight : i32, winWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=ce(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize),this.alignCorners=n,this.shaderKey=`resizeNearestNeigborBackprop_${n}`}getUserCode(){return`
      ${se("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let b = coords[0];
          let d = coords[3];
          let r = coords[1];
          let c = coords[2];

          var accumulator = 0.0;

          // Compute bounds for where in dy we will look
          let startRLerp = floor(f32(r) * uniforms.invHeightScale);
          let startDyR = i32(floor(startRLerp - f32(uniforms.winHeight / 2)));

          let startCLerp = floor(f32(c) * uniforms.invWidthScale);
          let startDyC = i32(floor(startCLerp - f32(uniforms.winWidth / 2)));

          // Loop over dy
          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {
            let dyR = startDyR + dyROffset;

            // Guard against the window exceeding the bounds of dy
            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {
              continue;
            }

            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {
              let dyC = startDyC + dyCOffset;

              // Guard against the window exceeding the bounds of dy
              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {
                continue;
              }

              let sourceFracRow = f32(uniforms.effectiveXSize[0]) *
                  (f32(dyR) / f32(uniforms.effectiveYSize[0]));

              let sourceFracCol = f32(uniforms.effectiveXSize[1]) *
                  (f32(dyC) / f32(uniforms.effectiveYSize[1]));

              let sourceNearestRow =
                  i32(min(f32(uniforms.outShape[1] - 1),
                  ${this.alignCorners?"floor(sourceFracRow + 0.5)":"floor(sourceFracRow)"}));

              let sourceNearestCol =
                  i32(min(f32(uniforms.outShape[2] - 1),
                  ${this.alignCorners?"floor(sourceFracCol + 0.5)":"floor(sourceFracCol)"}));

              if (r == sourceNearestRow && c == sourceNearestCol) {
                accumulator += getDy(b, dyR, dyC, d);
              }
            }
          }
          // End loop over dy

          setOutputAtIndex(index, accumulator);
        }
      }
    `}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g3(t){const{inputs:e,backend:n,attrs:r}=t,{images:o,dy:i}=e,{alignCorners:a}=r,[,u,l]=o.shape,[,d,f]=i.shape,p=[a&&d>1?u-1:u,a&&f>1?l-1:l],h=[a&&d>1?d-1:d,a&&f>1?f-1:f],g=p[0]/h[0],y=p[1]/h[1],x=1/g,v=1/y,w=Math.ceil(x)*2+2,S=Math.ceil(v)*2+2,I=new m3(o.shape,a),E=[{type:"int32",data:p},{type:"int32",data:h},{type:"float32",data:[x]},{type:"float32",data:[v]},{type:"int32",data:[w]},{type:"int32",data:[S]}];return n.runWebGPUProgram(I,[i],i.dtype,E)}const y3={kernelName:A1,backendName:"webgpu",kernelFunc:g3};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let x3=class{constructor(e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=ce(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=" axis : vec4<i32>,",this.shaderKey="reverse"}getUserCode(){return`
      
      // Using uniform variables as judging conditions, so the function has
      // coherent execution within all threads.
      fn getReverseCoords(coords : vec4<i32>) -> vec4<i32> {
        var reverseCoords = coords;
        if (uniforms.axis[0] == 1) {
          reverseCoords[0] = uniforms.xShape[0] - coords[0] - 1;
        }
        if (uniforms.axis[1] == 1) {
          reverseCoords[1] = uniforms.xShape[1] - coords[1] - 1;
        }
        if (uniforms.axis[2] == 1) {
          reverseCoords[2] = uniforms.xShape[2] - coords[2] - 1;
        }
        if (uniforms.axis[3] == 1) {
          reverseCoords[3] = uniforms.xShape[3] - coords[3] - 1;
        }

        return reverseCoords;
      }
    
      ${se("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let reverseCoords = getReverseCoords(coords);
          setOutputAtIndex(index, getX(reverseCoords[0],
              reverseCoords[1], reverseCoords[2], reverseCoords[3]));
        }
      }
    `}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v3(t){const{inputs:e,backend:n,attrs:r}=t,{x:o}=e,{dims:i}=r,a=o.shape.length;if(a===0)return Ot({inputs:{x:o},backend:n});const u=o.shape,l=[1,1,1,1];u.forEach((v,w)=>{const S=w+4-a;l[S]=v});const d=Je(i,o.shape),f=[0,0,0,0];d.forEach(v=>{const w=v+4-a;f[w]=1});const p=[{type:"int32",data:f}],h=pe({inputs:{x:o},backend:n,attrs:{shape:l}}),g=new x3(l),y=n.runWebGPUProgram(g,[h],h.dtype,p);n.disposeData(h.dataId);const x=pe({inputs:{x:y},backend:n,attrs:{shape:u}});return n.disposeData(y.dataId),x}const C3={kernelName:D1,backendName:"webgpu",kernelFunc:v3};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let w3=class{constructor(e,n){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=ce(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=`centerX : f32, centerY : f32, sinRadians : f32,
          cosRadians : f32,`,this.shaderKey="rotate",this.outputShape=e,typeof n=="number"?(this.uniforms+=" fillValue : f32,",this.fillSnippet="var outputValue = uniforms.fillValue;",this.shaderKey+="_float"):(this.uniforms+=" fillValue : vec3<f32>,",this.fillSnippet="var outputValue = uniforms.fillValue[coords[3]];",this.shaderKey+="_vec3")}getUserCode(){return`
        ${se("index")} {
          if (index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            let coordXFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.cosRadians - (f32(coords[1]) - uniforms.centerY) *
                uniforms.sinRadians;
            let coordYFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.sinRadians + (f32(coords[1]) - uniforms.centerY) *
                uniforms.cosRadians;
            let coordX = i32(round(coordXFloat + uniforms.centerX));
            let coordY = i32(round(coordYFloat + uniforms.centerY));
            ${this.fillSnippet}
            if(coordX >= 0 && coordX < uniforms.xShape[2] && coordY >= 0 &&
                coordY < uniforms.xShape[1]) {
              outputValue = getX(coords[0], coordY, coordX, coords[3]);
            }
            setOutputAtIndex(index, outputValue);
          }
        }
      `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const S3={kernelName:f0,backendName:"webgpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{image:r}=t,{radians:o,fillValue:i,center:a}=e,u=n,l=new w3(r.shape,i),[d,f]=yp(a,r.shape[1],r.shape[2]),p=[{type:"float32",data:[d]},{type:"float32",data:[f]},{type:"float32",data:[Math.sin(o)]},{type:"float32",data:[Math.cos(o)]}];return typeof i=="number"?p.push({type:"float32",data:[Number.parseFloat(i.toFixed(2))]}):p.push({type:"float32",data:i}),u.runWebGPUProgram(l,[r],r.dtype,p)}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const b3=Te({opType:ie.ROUND}),I3={kernelName:F1,backendName:"webgpu",kernelFunc:b3};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $3=Te({opType:ie.RSQRT,cpuKernelImpl:Uk}),R3={kernelName:L1,backendName:"webgpu",kernelFunc:$3};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let da=class{constructor(e,n,r,o,i,a,u,l=!0){this.variableNames=["updates","indices"],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=a,this.type=u,this.sumDupeIndices=l,this.dispatchLayout=ce(e),this.dispatch=ae(this.dispatchLayout,e,this.workgroupSize),this.sliceDimGreaterThanOne=n>1,this.shaderKey=`scatter_${r}_${o}_${this.sliceDimGreaterThanOne}_${u}_${l}_${i.length}`;const d=Ze(i.length);this.uniforms=`sliceDim : i32, strides: ${d}, updatesSize: i32,`,this.updatesRank=o,this.indicesRank=r}getUserCode(){let e="";this.indicesRank===1?e="coords[0]":this.indicesRank===2&&(e="coords[0], j");const n=`getIndices(${e})`,r=this.sliceDimGreaterThanOne?"uniforms.strides[j]":"uniforms.strides";let o="",i="";this.dispatchLayout.x.length===1?(o="flattenedIndex",i=`
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> i32 {
        return index;
      }
      `):this.dispatchLayout.x.length===2&&(o="vec2<i32>(flattenedIndex, coords[1])",i=`
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> vec2<i32> {
        // N.B. |updates| could be a scalar tensor, conceptually representing a
        // 2D tensor with all values equal to that. By design, its size must be
        // the same as |outShape[1]| in one dimension, and |indicesShape[0]|
        // gives the other.
        let sliceSize = uniforms.outShape[1];
        let d0 = index / sliceSize;
        let d1 = index - d0 * sliceSize;
        return vec2<i32>(d0, d1);
      }
      `);const u=`getUpdates(${Array.from({length:this.updatesRank},(d,f)=>`coords[${f}]`).join(", ")})`;return`
    ${i}
      ${se("index")} {
        if (index < uniforms.updatesSize) {
          let coords = getUpdatesCoordsFromFlatIndex(index);
          var flattenedIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexInside = i32(round(${n}));
            flattenedIndex = flattenedIndex + indexInside * ${r};
          }
          let updateValue =
              ${ko(this.type)}(${u});
          let flatIndex = getOutputIndexFromCoords(${o});

          ${this.sumDupeIndices?Lr("&result[flatIndex]","updateValue",this.type):"atomicStore(&result[flatIndex], bitcast<i32>(updateValue));"}
        }
      }`}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E3(t){const{inputs:e,backend:n,attrs:r}=t,{indices:o,updates:i}=e,{shape:a}=r,{sliceRank:u,numUpdates:l,sliceSize:d,strides:f,outputSize:p}=Uo(i,o,a),h=[p/d,d];if(p===0)return n.makeTensorInfo(a,o.dtype);const g=pe({inputs:{x:o},backend:n,attrs:{shape:[l,u]}}),y=pe({inputs:{x:i},backend:n,attrs:{shape:[l,d]}}),x=y.dtype,v=$t({backend:n,attrs:{shape:h,value:0,dtype:x}}),w=Y(y.shape),S=[{type:"int32",data:[u]},{type:"int32",data:f},{type:"int32",data:[w]}],I=new da(y.shape,u,g.shape.length,y.shape.length,f,h,x),E=n.runWebGPUProgram(I,[y,g],x,S,v),R=pe({inputs:{x:E},backend:n,attrs:{shape:a}});return n.disposeData(g.dataId),n.disposeData(y.dataId),n.disposeData(E.dataId),R}const _3={kernelName:M1,backendName:"webgpu",kernelFunc:E3};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let P3=class{constructor(e,n){this.outputShape=[],this.variableNames=["sortedSequence","values"],this.uniforms="numInputs : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=ce(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize),this.side=n,this.shaderKey=`search_sorted_${n}`}getUserCode(){return`
      fn findBound(batch: i32, value: f32) -> i32 {
        var left = i32(0);
        var right = uniforms.numInputs;
        while (left < right) {
          var mid = (left + right) / 2;
          if (getSortedSequence(batch, mid) ${this.side==="left"?"<":"<="} value) {
            left = mid + 1;
          } else {
            right = mid;
          }
        }
        return right;
      }

      ${se("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let value = getValuesByOutputIndex(index);
          setOutputAtIndexI32(index, findBound(coords[0], value));
        }
      }
    `}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k3(t){const{inputs:e,backend:n,attrs:r}=t,{sortedSequence:o,values:i}=e,{side:a}=r,u=new P3([i.shape[0],i.shape[1]],a),l=[{type:"int32",data:[o.shape[1]]}];return n.runWebGPUProgram(u,[o,i],"int32",l)}const T3={kernelName:U1,backendName:"webgpu",kernelFunc:k3};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let A3=class{constructor(e,n,r){this.variableNames=["c","a","b"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=n,this.dispatchLayout=ce(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize),this.cRank=e,this.rank=r,this.shaderKey="select"}getUserCode(){let e,n;if(this.rank>4)throw Error(`Where for rank ${this.rank} is not yet supported`);if(this.rank===1)n="resRC",e="resRC";else{const o=["resRC.x","resRC.y","resRC.z","resRC.w"],i=[],a=[];for(let u=0;u<this.outputShape.length;u++)a.push(`${o[u]}`),u<this.cRank&&i.push(`${o[u]}`);e=i.join(),n=a.join()}return`
      ${se("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let cVal = getC(${e});
          if (cVal >= 1.0) {
            setOutputAtIndex(index, getA(${n}));
          } else {
            setOutputAtIndex(index, getB(${n}));
          }
        }
      }
    `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N3(t){const{inputs:e,backend:n}=t,{condition:r,t:o,e:i}=e,a=new A3(r.shape.length,o.shape,o.shape.length);return n.runWebGPUProgram(a,[r,o,i],Rt(o.dtype,i.dtype))}const O3={kernelName:W1,backendName:"webgpu",kernelFunc:N3};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const D3=Te({opType:ie.SELU}),F3={kernelName:V1,backendName:"webgpu",kernelFunc:D3};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const L3=Te({opType:ie.SIGMOID}),M3={kernelName:Yf,backendName:"webgpu",kernelFunc:L3};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const B3=Te({opType:ie.SIGN}),U3={kernelName:j1,backendName:"webgpu",kernelFunc:B3};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const W3=Te({opType:ie.SIN}),V3={kernelName:G1,backendName:"webgpu",kernelFunc:W3};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const z3=Te({opType:ie.SINH}),G3={kernelName:H1,backendName:"webgpu",kernelFunc:z3};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const H3=Te({opType:ie.SOFTPLUS}),j3={kernelName:X1,backendName:"webgpu",kernelFunc:H3};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class X3{constructor(e,n,r,o,i,a){this.variableNames=["x"],this.outputShape=[],this.uniforms="",this.workgroupSize=[64,1,1],this.size=!0;const u=new Array(o.length);for(let l=0;l<u.length;l++)u[l]=o[i[l]];this.outputShape=u,this.newDim=i,this.dispatchLayout=ce(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=e,this.paddedXShape=n,this.uniforms+=`reshapedPaddedXShape : ${Ze(o.length)}, paddedXShapeStrides : ${Ze(a)}, `,r.map((l,d)=>{this.uniforms+=` pad${d} : vec2<i32>,`}),this.shaderKey=`spaceToBatchND_${i}`}getUserCode(){const e=Ze(this.outputShape.length),n=_w(this.newDim);return`
      ${Zu(this.paddedXShape,"PaddedX")}
      ${se("index")} {
        if(index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let switchedIndex = getIndexFromCoords${this.outputShape.length}D(${e}(${n}), uniforms.reshapedPaddedXShape);
          let paddedCoords = getPaddedXCoordsFromIndex(switchedIndex);
          ${Xw(this.xShape,!0)}
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const q3=t=>{const{inputs:e,backend:n,attrs:r}=t,{x:o}=e,{blockShape:i,paddings:a}=r;re(o.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGPU backend not implemented yet");const u=i.reduce((S,I)=>S*I),l=[[0,0]];l.push(...a);for(let S=1+i.length;S<o.shape.length;++S)l.push([0,0]);const d=l.map((S,I)=>S[0]+o.shape[I]+S[1]),f=Ra(d,i,u,!1),p=Ea(f.length,i.length,!1),h=_a(d,i,u,!1),g=Ke(d),y=new X3(o.shape,d,l,f,p,g.length),x=[{type:"int32",data:f},{type:"int32",data:g}];l.map(S=>x.push({type:"int32",data:[S[0],S[1]]}));const v=n.runWebGPUProgram(y,[o],o.dtype,x),w=pe({inputs:{x:v},backend:n,attrs:{shape:h}});return n.disposeData(v.dataId),w},K3={kernelName:q1,backendName:"webgpu",kernelFunc:q3};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Y3{constructor(e,n,r){this.variableNames=["input","indices","segmentIds"],this.outputShape=[],this.uniforms="segmentSize : i32, sparseSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e,this.type=r,this.dispatchLayout=ce([n]),this.dispatch=ae(this.dispatchLayout,[n],this.workgroupSize),this.shaderKey="sparseSegmentSum"}getUserCode(){return`
    ${se("index")} {
      if (index < uniforms.sparseSize) {
        let indexInSegmentIds = index / uniforms.segmentSize;
        let indexInSegment = index % uniforms.segmentSize;
        let indexInInput = indices[indexInSegmentIds];
        let segmentId = segmentIds[indexInSegmentIds];

        let value = input[indexInInput * uniforms.segmentSize + indexInSegment];
        let outIndex = segmentId * uniforms.segmentSize + indexInSegment;
        ${Lr("&result[outIndex]","value",this.type)}
      }
    }
  `}}class Q3{constructor(e,n){this.variableNames=["segmentIds"],this.outputShape=[],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=[e],this.dispatchLayout=ce(n),this.dispatch=ae(this.dispatchLayout,n,this.workgroupSize),this.shaderKey="sparseSegmentIdCountProgram"}getUserCode(){return`
    ${se("index")} {
      if (index < uniforms.segmentIdsShape) {
        let segmentId = segmentIds[index];
        ${Lr("&result[segmentId]","1","int32")}
      }
    }
  `}}class Z3{constructor(e,n){this.variableNames=["segmentSum","sameSegmentIdCount"],this.outputShape=[],this.uniforms="segmentSize : i32",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.type=n,this.dispatchLayout=ce(e),this.dispatch=ae(this.dispatchLayout,e,this.workgroupSize),this.shaderKey="sparseSegmentMean"}getUserCode(){return`
    ${se("index")} {
      if (index < uniforms.size) {
        let segmentId = index / uniforms.segmentSize;
        let count = sameSegmentIdCount[segmentId];
        if (count != 0) {
          ${this.type==="float32"?"setOutputAtIndex(index, segmentSum[index] / f32(count));":"setOutputAtIndexI32(index, segmentSum[index] / count);"}
        }
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qw(t,e,n,r=!1,o){const a=Y(t.shape)/t.shape[0],u=t.dtype,l=Y(e.shape),d=o.readSync(n.dataId),p=l>0?d[l-1]+1:0;let h;const g=t.shape.slice();g[0]=p;const y=l*a,x=$t({backend:o,attrs:{shape:g,value:0,dtype:u}});h=new Y3(g,y,u);let v=[{type:"int32",data:[a]},{type:"int32",data:[y]}];const w=o.runWebGPUProgram(h,[t,e,n],u,v,x);if(r)return w;const S=$t({backend:o,attrs:{shape:[p],value:0,dtype:"int32"}});h=new Q3(p,n.shape);const I=o.runWebGPUProgram(h,[n],"int32",null,S),E=$t({backend:o,attrs:{shape:g,value:0,dtype:u}});h=new Z3(g,u),v=[{type:"int32",data:[a]}];const R=o.runWebGPUProgram(h,[w,I],u,v,E);return o.disposeData(w.dataId),o.disposeData(I.dataId),R}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J3(t){const{inputs:e,backend:n}=t,{data:r,indices:o,segmentIds:i}=e;return qw(r,o,i,!1,n)}const eF={kernelName:Q1,backendName:"webgpu",kernelFunc:J3};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tF(t){const{inputs:e,backend:n}=t,{data:r,indices:o,segmentIds:i}=e;return qw(r,o,i,!0,n)}const nF={kernelName:Z1,backendName:"webgpu",kernelFunc:tF};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let rF=class{constructor(e,n){this.variableNames=["A"],this.workgroupSize=[64,1,1],this.size=!0;const r=new Array(e.length);for(let o=0;o<r.length;o++)r[o]=e[o]*n[o];this.outputShape=r,this.dispatchLayout=ce(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize),this.rank=this.outputShape.length,this.shaderKey="tile"}getUserCode(){const e=oF(this.rank,"uniforms.");return`
      ${se("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          setOutputAtIndex(index, getA(${e}));
        }
      }
    `}};function oF(t,e=""){if(t>=5)throw Error(`Tile for rank ${t} is not yet supported`);if(t===1)return`(resRC % ${e}aShape)`;const n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let o=0;o<t;o++)r.push(`(${n[o]} % ${e}aShape[${o}])`);return r.join()}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bp(t){const{inputs:e,backend:n,attrs:r}=t,{x:o}=e,{reps:i}=r;if(n.shouldExecuteOnCPU([o])||o.dtype==="string"||o.shape.length>=5){const l=n.readSync(o.dataId),d=o.dtype==="string"?l.map(h=>Yn(h)):l,f=Xe(o.shape,o.dtype,d),p=Xk(f,i);return n.makeTensorInfo(p.shape,p.dtype,p.values)}const a=new rF(o.shape,i);return n.runWebGPUProgram(a,[o],o.dtype)}const iF={kernelName:ep,backendName:"webgpu",kernelFunc:Bp};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sF(t){const{inputs:e,backend:n,attrs:r}=t,{sparseIndices:o,sparseValues:i,defaultValue:a}=e,{outputShape:u}=r,{sliceRank:l,numUpdates:d,sliceSize:f,strides:p,outputSize:h}=Uo(i,o,u),g=!1;if(i.dtype==="string"){const D=n.bufferSync(o),N=n.bufferSync(i),O=Yn(n.readSync(a.dataId)[0]),_=Wk(D,N,u,h,f,d,l,p,O,g);return n.makeTensorInfo(u,_.dtype,_.values)}const y=[h/f,f],x=pe({inputs:{x:o},backend:n,attrs:{shape:[d,l]}}),v=i.shape.length?pe({inputs:{x:i},backend:n,attrs:{shape:[d,f]}}):Ot({inputs:{x:i},backend:n}),w=v.dtype,S=n.makeTensorInfo([],w,Kn(1,w)),I=pe({inputs:{x:a},backend:n,attrs:{shape:Array(y.length).fill(1)}}),E=Bp({inputs:{x:I},backend:n,attrs:{reps:y}}),R=Y([d,f]),T=[{type:"int32",data:[l]},{type:"int32",data:p},{type:"int32",data:[R]}];switch(d){case 0:break;case 1:{const D=new da([d,f],l,x.shape.length,v.shape.length,p,y,w,g);n.runWebGPUProgram(D,[v,x],w,T,E)}break;default:{const D=new da([d,f],l,x.shape.length,S.shape.length,p,y,w,g);n.runWebGPUProgram(D,[S,x],w,T,E)}{const D=new da([d,f],l,x.shape.length,v.shape.length,p,y,w);n.runWebGPUProgram(D,[v,x],w,T,E)}}const k=pe({inputs:{x:E},backend:n,attrs:{shape:u}});return n.disposeData(x.dataId),n.disposeData(v.dataId),n.disposeData(I.dataId),n.disposeData(S.dataId),n.disposeData(E.dataId),k}const aF={kernelName:J1,backendName:"webgpu",kernelFunc:sF};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uF(t){const{inputs:e,backend:n,attrs:r}=t,{x:o}=e,{numOrSizeSplits:i,axis:a}=r,u=Je(a,o.shape)[0],l=Np(o,i,u),d=o.shape.length,f=new Array(d).fill(0),p=o.shape.slice();return l.map(h=>{const g=[...p];g[u]=h;const y=Xi({inputs:{x:o},backend:n,attrs:{begin:f,size:g}});return f[u]+=h,y})}const lF={kernelName:K1,backendName:"webgpu",kernelFunc:uF};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cF=Te({opType:ie.SQRT}),dF={kernelName:Qf,backendName:"webgpu",kernelFunc:cF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fF={kernelName:t0,backendName:"webgpu",kernelFunc:({inputs:t,backend:e})=>{const{x:n}=t,r=e,o=new ji(n.shape,ie.SQUARE);return r.runWebGPUProgram(o,[n],n.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pF=st({opType:Ce.SQUARED_DIFFERENCE}),hF={kernelName:e0,backendName:"webgpu",kernelFunc:pF};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mF({inputs:t,attrs:e,backend:n}){const{x:r}=t,o=new ji(r.shape,ie.STEP,"stepAlpha : f32,"),i=[{type:"float32",data:[e.alpha]}];return n.runWebGPUProgram(o,[r],r.dtype,i)}const gF={kernelName:np,backendName:"webgpu",kernelFunc:mF};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let yF=class{constructor(e){this.variableNames=["x"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=ce(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]);const n=Ze(this.outputShape.length);this.uniforms=`begin : ${n},  strides : ${n}, `,this.shaderKey="stridedSlice"}getUserCode(){const e=this.outputShape.length;let n="";if(e===1)n="coords * uniforms.strides + uniforms.begin";else{let o=0;n=this.outputShape.map((i,a)=>(o++,this.outputShape.length===1?`coords * uniforms.strides[${a}] + uniforms.begin[${a}]`:`coords[${o-1}] * uniforms.strides[${a}] + uniforms.begin[${a}]`)).join(",")}return`
       ${se("index")} {
         if (index < uniforms.size) {
           let coords = getCoordsFromIndex(index);
           setOutputAtIndex(index, getX(${n}));
         }
       }
     `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xF(t){const{inputs:e,backend:n,attrs:r}=t,{x:o}=e,{begin:i,end:a,strides:u,beginMask:l,endMask:d,ellipsisMask:f,newAxisMask:p,shrinkAxisMask:h}=r,{finalShapeSparse:g,finalShape:y,isIdentity:x,sliceDim0:v,isSimpleSlice:w,begin:S,end:I,strides:E}=hp(o.shape,i,a,u,l,d,f,p,h);let R;if(x)R=pe({inputs:{x:o},backend:n,attrs:{shape:y}});else if(v||w){re(o.shape.length>=1,()=>`Input must have rank at least 1, got: ${o.shape.length}`);const T=cp(S,I,E),k=Xi({inputs:{x:o},backend:n,attrs:{begin:S,size:T}});R=pe({inputs:{x:k},backend:n,attrs:{shape:y}}),n.disposeData(k.dataId)}else if(n.shouldExecuteOnCPU([o])){const k=n.readSync(o.dataId),D=Xe(o.shape,o.dtype,k),N=Gk(g,D,E,S);R=n.makeTensorInfo(y,o.dtype,N.values)}else{const k=new yF(g),D=[{type:"int32",data:S},{type:"int32",data:E}],N=n.runWebGPUProgram(k,[o],o.dtype,D);R=pe({inputs:{x:N},backend:n,attrs:{shape:y}}),n.disposeData(N.dataId)}return R}const vF={kernelName:n0,backendName:"webgpu",kernelFunc:xF};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CF(t){const{inputs:e,backend:n,attrs:r}=t,{separator:o,nGramWidths:i,leftPad:a,rightPad:u,padWidth:l,preserveShortSequences:d}=r,{data:f,dataSplits:p}=e,h=n.readSync(f.dataId),g=n.readSync(p.dataId),[y,x]=Hk(h,g,o,i,a,u,l,d);return[n.makeTensorInfo([y.length],"string",y),n.makeTensorInfo(p.shape,"int32",x)]}const wF={kernelName:r0,backendName:"webgpu",kernelFunc:CF};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SF=st({opType:Ce.SUB,cpuKernelImpl:jk,supportsComplex:!0}),bF={kernelName:Jf,backendName:"webgpu",kernelFunc:SF};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IF=Te({opType:ie.TAN}),$F={kernelName:o0,backendName:"webgpu",kernelFunc:IF};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RF=Te({opType:ie.TANH}),EF={kernelName:i0,backendName:"webgpu",kernelFunc:RF};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _F(t){const{inputs:e,backend:n,attrs:r}=t,{tensor:o,indices:i,updates:a}=e,{sliceRank:u,numUpdates:l,sliceSize:d,strides:f,outputSize:p}=Uo(a,i,o.shape),h=[p/d,d];if(p===0)return n.makeTensorInfo(o.shape,i.dtype);const g=[],y=pe({inputs:{x:i},backend:n,attrs:{shape:[l,u]}});g.push(y);const x=pe({inputs:{x:a},backend:n,attrs:{shape:[l,d]}});g.push(x);const v=pe({inputs:{x:o},backend:n,attrs:{shape:h}});g.push(v);const w=Bp({inputs:{x:v},backend:n,attrs:{reps:Array(h.length).fill(1)}}),S=new da([l,d],u,y.shape.length,x.shape.length,f,h,o.dtype,!1),I=Y([l,d]),E=[{type:"int32",data:[u]},{type:"int32",data:f},{type:"int32",data:[I]}],R=n.runWebGPUProgram(S,[x,y],v.dtype,E,w);g.push(R);const T=pe({inputs:{x:R},backend:n,attrs:{shape:o.shape}});return g.forEach(k=>n.disposeData(k.dataId)),T}const PF={kernelName:B1,backendName:"webgpu",kernelFunc:_F};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let kF=class{constructor(e){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=ce(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=`inputSize : i32, firstPass : i32, negativeInf : f32,
        dir : i32, inc : i32,`,this.shaderKey="swap"}getUserCode(){return`
        ${se("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // We compare elements pair-wise within a group of size 2 * inc.
            // The comparing rule for each group alternates between ascending
            // and descending. Within each group, we compare each pair at
            // positions i and i+inc. To decide whether an element at position i
            // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
            // inc, it is in the first half of the group, we denote it as x0,
            // otherwise we denote it as x1.
            // For example, as shown in the Bitonic top K paper referenced
            // above, Figure5(a) shows that element[1] is in the second half of
            // the group when group size is 2, but it is in the first half of
            // the group when group size is 4.
            let isFirstInPair = elemIdx % (2 * uniforms.inc) < uniforms.inc;
            var i = 0;
            if (isFirstInPair) {
              i = elemIdx;
            } else {
              i = elemIdx - uniforms.inc;
            }

            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }

            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.inc;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.inc));
            }

            var x0 = f32(0.0);
            var x1 = f32(0.0);
            if (i0 < uniforms.inputSize) {
              x0 = getX(batch, i0);
            } else {
              x0 = uniforms.negativeInf;
            }
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = uniforms.negativeInf;
            }

            let reverse = elemIdx % (2 * uniforms.dir) >= uniforms.dir;
            let isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
            if (reverse == isGreater) {
              // Elements in opposite order of direction
              let iTemp = i0;
              i0 = i1;
              i1 = iTemp;
            }
            if (isFirstInPair) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `}},TF=class{constructor(e){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=ce(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms="inputSize : i32, firstPass : i32, k : i32,",this.shaderKey="merge"}getUserCode(){return`
        ${se("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // The output size is half of the previous size.
            // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _
            // (k=4), we only need to output the indices at positions |, the
            // indices at positions _ can be thrown away, see Figure5(b) After
            // Phase 2 (Merge phase) in the Bitonic Top K paper referenced
            // above.
            // For example, the paper shows we only need to output the orange
            // bars. The output sequence should look like this | | | | | | | |.
            // Because the sequence is halved, to map the output index back to
            // the previous sequence to find the corresponding value, we need
            // to double the index. When we double the index, we basically
            // interpolate a position, so 2i looks like
            // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k
            // position of each 2k positions by - elemIdx % k. E.g. for output
            // at index 4,5,6,7, we want to get the corresponding element at
            // original index 8,9,10,11, for output at index 8,9,10,11,
            // we want to get the corresponding element at original index
            // 16,17,18,19, so on and so forth.

            var i = 0;
            if (elemIdx < uniforms.k) {
              i = elemIdx;
            } else {
              i = elemIdx * 2 - elemIdx % uniforms.k;
            }
            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }
            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.k;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.k));
            }

            let x0 = getX(batch, i0);
            var x1 = f32(0.0);
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = x0;
            }

            if (x0 >= x1) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ii(t,e){e!==null&&t.disposeData(e.dataId)}function Py(t){let e=1;for(;e<t;)e*=2;return e}function AF(t){const{inputs:e,backend:n,attrs:r}=t,{x:o}=e,{k:i,sorted:a}=r,u=o.shape,l=u[u.length-1];if(n.shouldExecuteOnCPU([o])){const R=n.readSync(o.dataId),[T,k]=qk(R,u,o.dtype,i,a);return[n.makeTensorInfo(T.shape,T.dtype,T.values),n.makeTensorInfo(k.shape,k.dtype,k.values)]}if(i===0)return u[u.length-1]=0,[n.makeTensorInfo(u,o.dtype,[]),n.makeTensorInfo(u,"int32",[])];if(l===1)return[o,$t({attrs:{shape:u,dtype:"int32",value:0},backend:n})];const f=Y(u)/l,p=pe({inputs:{x:o},attrs:{shape:[f,l]},backend:n}),h=Py(i),g=Py(l);let y=null;const x=()=>y===null?[p,p]:[p,y],v=(R,T,k)=>{const D=x(),N=new kF(k),_=[{type:"int32",data:[l]},{type:"int32",data:[y===null?1:0]},{type:"float32",data:[Number.NEGATIVE_INFINITY]},{type:"int32",data:[R]},{type:"int32",data:[T]}],F=y;y=n.runWebGPUProgram(N,D,"int32",_),Ii(n,F)};for(let R=1;R<h;R*=2){const T=R*2;for(let k=R;k>=1;k/=2)v(T,k,[f,g])}for(let R=g;R>h;R/=2){const T=x(),k=new TF([f,R/2]),N=[{type:"int32",data:[l]},{type:"int32",data:[y===null?1:0]},{type:"int32",data:[h]}],O=y;y=n.runWebGPUProgram(k,T,"int32",N),Ii(n,O);const _=h/2,F=_*2;for(let U=_;U>=1;U/=2)v(F,U,y.shape)}let w=y;y=Xi({inputs:{x:y},backend:n,attrs:{begin:0,size:[f,i]}}),Ii(n,w);let S=zw({inputs:{x:p,indices:y},backend:n,attrs:{axis:1,batchDims:1}});Ii(n,p);const I=u.slice(0,-1);I.push(i),w=y,y=pe({inputs:{x:y},attrs:{shape:I},backend:n}),Ii(n,w);const E=S;return S=pe({inputs:{x:S},attrs:{shape:I},backend:n}),Ii(n,E),[S,y]}const NF={kernelName:s0,backendName:"webgpu",kernelFunc:AF};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let OF=class{constructor(e){this.variableNames=["Image","Transforms"],this.uniforms="interpolationModeId : i32, fillModeId : i32, fillValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=ce(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="transform"}getUserCode(){return`
          fn mapCoord(outCoord : f32, len : f32) -> f32{
            var inCoord = outCoord;
            if(uniforms.fillModeId == 2) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  if (inCoord < sz2) {
                    inCoord = sz2 * f32(i32(f32(-inCoord / sz2))) +
                    inCoord;
                  }
                  if (inCoord < -len) {
                    inCoord = inCoord + sz2;
                  } else {
                    inCoord = -inCoord - 1.0;
                  }
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  inCoord = inCoord - sz2 * f32(i32(f32(inCoord / sz2)));
                  if (inCoord >= len) {
                    inCoord = sz2 - inCoord - 1.0;
                  }
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 3) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord + len * (f32(i32(f32(-inCoord / sz))) + 1.0);
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord - len * f32(i32(f32(inCoord / sz)));
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 4) {
              return clamp(outCoord, 0.0, len - 1.0);
            }
            return outCoord;
          }
          fn readWithFillValue(batch : i32, coordY : i32, coordX : i32,
            channel : i32) -> f32 {
            var outputValue : f32;
            if (0 <= coordY && coordY < uniforms.imageShape[1] && 0 <= coordX && coordX < uniforms.imageShape[2]) {
                outputValue = getImage(batch, coordY, coordX, channel);
            } else {
              outputValue = uniforms.fillValue;
            }
            return outputValue;
          }

          ${se("index")} {
            if (index < uniforms.size) {
              let coords = getCoordsFromIndex(index);
              var outputValue : f32;
              let batch = coords[0];
              let x = coords[2];
              let y = coords[1];
              let channel = coords[3];
              let xf = f32(x);
              let yf = f32(y);
              let a1 = getTransforms(batch, 0);
              let a2 = getTransforms(batch, 1);
              let a3 = getTransforms(batch, 2);
              let b1 = getTransforms(batch, 3);
              let b2 = getTransforms(batch, 4);
              let b3 = getTransforms(batch, 5);
              let c1 = getTransforms(batch, 6);
              let c2 = getTransforms(batch, 7);
              let projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = uniforms.fillValue;
              } else {
                let inX = (a1 * xf + a2 * yf + a3) / projection;
                let inY = (b1 * xf + b2 * yf + b3) / projection;
                let mapX = mapCoord(inX, f32(uniforms.imageShape[2]));
                let mapY = mapCoord(inY, f32(uniforms.imageShape[1]));

                if (uniforms.interpolationModeId == 1) {
                  let coordY = i32(round(mapY));
                  let coordX = i32(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  let yFloor = floor(mapY);
                  let xFloor = floor(mapX);
                  let yCeil = yFloor + 1.0;
                  let xCeil = xFloor + 1.0;
                  let valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yFloor), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yFloor), i32(xCeil), channel);
                  let valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yCeil), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yCeil), i32(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutputAtIndex(index, outputValue);
            }
          }
        `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DF(t){const{inputs:e,backend:n,attrs:r}=t,{image:o,transforms:i}=e,{interpolation:a,fillMode:u,fillValue:l,outputShape:d}=r,[f,p,h,g]=o.shape,[y,x]=d??[p,h],v=[f,y,x,g],w=new OF(v),S=a==="nearest"?1:2;let I;switch(u){case"constant":I=1;break;case"reflect":I=2;break;case"wrap":I=3;break;case"nearest":I=4;break;default:I=1;break}const E=[{type:"int32",data:[S]},{type:"int32",data:[I]},{type:"float32",data:[l]}];return n.runWebGPUProgram(w,[o,i],"float32",E)}const FF={kernelName:a0,backendName:"webgpu",kernelFunc:DF};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LF(t){const{inputs:e,backend:n,attrs:r}=t,{value:o}=e;let{axis:i}=r;i<0&&(i+=o.shape.length);const a=o,u=a.shape.length,l=o.shape[i],d=new Array(u-1);let f=0;for(let x=0;x<u;x++)x!==i&&(d[f++]=a.shape[x]);const p=[],h=new Array(u).fill(0),g=a.shape.slice();g[i]=1;const y=new Array(l);for(let x=0;x<y.length;x++){h[i]=x;const v=Xi({inputs:{x:a},backend:n,attrs:{begin:h,size:g}}),w=pe({inputs:{x:v},backend:n,attrs:{shape:d}});y[x]=w,p.push(v)}return p.forEach(x=>n.disposeData(x.dataId)),y}const MF={kernelName:l0,backendName:"webgpu",kernelFunc:LF};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class BF{constructor(e,n,r){if(this.outputShape=[],this.variableNames=["x","segmentIds"],this.uniforms="numSegments : i32, xSize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=n,this.dispatchLayout=ce(e),this.dispatch=ae(this.dispatchLayout,e,this.workgroupSize),r!=="float32"&&r!=="int32")throw new Error(`UnsortedSegmentSum only supports float32 and int32
              types, does not support ${r} type.`);this.type=r,this.shaderKey="unsortedSegmentSum"}getUserCode(){return`
    ${se("index")} {
      if (index < uniforms.xSize) {
        let coords = getXCoordsFromIndex(index);
        let b = coords[0];
        let inCol = coords[1];

        let segmentId = i32(getSegmentIds(inCol));
        if (segmentId >= 0) {
          let flatIndex = b * uniforms.numSegments + segmentId % uniforms.numSegments;
          let value = getX(b, inCol);

          ${Lr("&result[flatIndex]","value",this.type)}
        }
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UF(t){const{inputs:e,backend:n,attrs:r}=t,{x:o,segmentIds:i}=e,{numSegments:a}=r,u=o.shape.length,l=[];let d=0;const f=dt([d],u);let p=o;f!=null&&(p=Dn({inputs:{x:o},backend:n,attrs:{perm:f}}),l.push(p),d=ft(1,u)[0]);const h=Op(p.shape,d,a),g=Y([p.shape[d]]),y=pe({inputs:{x:p},backend:n,attrs:{shape:[-1,g]}});l.push(y);const x=o.dtype,v=[y.shape[0],a],w=$t({backend:n,attrs:{shape:v,value:0,dtype:x}}),S=new BF(y.shape,v,x),I=[{type:"int32",data:[a]},{type:"int32",data:[Y(y.shape)]}],E=n.runWebGPUProgram(S,[y,i],x,I,w),R=pe({inputs:{x:E},backend:n,attrs:{shape:h}});l.push(E);let T=R;if(f!=null){l.push(R);const k=$a(f);T=Dn({inputs:{x:T},backend:n,attrs:{perm:k}})}return l.forEach(k=>n.disposeData(k.dataId)),T}const WF={kernelName:c0,backendName:"webgpu",kernelFunc:UF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VF=[lP,Qk,Jk,tT,rT,sT,pT,mT,yT,vT,wT,bT,$T,ET,PT,OT,FT,UT,VT,GT,KT,JT,nA,sA,uA,fA,dP,mA,vA,EA,NA,LA,UA,VA,GA,jA,qA,QA,JA,tN,rN,sN,pN,mN,lN,xN,wN,$N,EN,kN,ON,FN,MN,UN,VN,GN,HN,XN,KN,sP,QN,rO,JN,tO,sO,uO,cO,pO,gO,xO,CO,cP,SO,yA,IO,RO,_O,kO,AO,OO,LO,WO,BO,zO,HO,XO,QO,eD,TT,nD,oD,fD,sD,cD,hD,AT,gD,xD,CD,SD,ED,TN,PD,TD,ND,rA,FD,MD,UD,zD,HD,XD,KD,QD,oA,JD,t3,r3,i3,aP,u3,d3,h3,y3,C3,S3,I3,R3,_3,T3,O3,F3,M3,U3,V3,G3,XT,gF,vF,wF,$D,j3,K3,eF,nF,aF,lF,dF,fF,hF,bF,AN,$F,EF,PF,iF,NF,FF,lT,MF,WF,LD];for(const t of VF)g0(t);/**
    * @license
    * Copyright 2023 Google LLC. All Rights Reserved.
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    * http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    * =============================================================================
    */var Kw=function(t,e){return(Kw=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,r){n.__proto__=r}||function(n,r){for(var o in r)Object.prototype.hasOwnProperty.call(r,o)&&(n[o]=r[o])})(t,e)};function Yw(t,e){if(typeof e!="function"&&e!==null)throw new TypeError("Class extends value "+String(e)+" is not a constructor or null");function n(){this.constructor=t}Kw(t,e),t.prototype=e===null?Object.create(e):(n.prototype=e.prototype,new n)}var wf=function(){return(wf=Object.assign||function(t){for(var e,n=1,r=arguments.length;n<r;n++)for(var o in e=arguments[n])Object.prototype.hasOwnProperty.call(e,o)&&(t[o]=e[o]);return t}).apply(this,arguments)};function la(t,e,n){if(n||arguments.length===2)for(var r,o=0,i=e.length;o<i;o++)!r&&o in e||(r||(r=Array.prototype.slice.call(e,0,o)),r[o]=e[o]);return t.concat(r||Array.prototype.slice.call(e))}var zF=["nose","left_eye","right_eye","left_ear","right_ear","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle"],ky,Ty,Qw=function(){function t(e){(function(n){if(n.maxTracks<1)throw new Error("Must specify 'maxTracks' to be at least 1, but "+"encountered ".concat(n.maxTracks));if(n.maxAge<=0)throw new Error("Must specify 'maxAge' to be positive, but "+"encountered ".concat(n.maxAge));if(n.keypointTrackerParams!==void 0){if(n.keypointTrackerParams.keypointConfidenceThreshold<0||n.keypointTrackerParams.keypointConfidenceThreshold>1)throw new Error("Must specify 'keypointConfidenceThreshold' to be in the range [0, 1], but encountered "+"".concat(n.keypointTrackerParams.keypointConfidenceThreshold));if(n.keypointTrackerParams.minNumberOfKeypoints<1)throw new Error("Must specify 'minNumberOfKeypoints' to be at least 1, but "+"encountered ".concat(n.keypointTrackerParams.minNumberOfKeypoints));for(var r=0,o=n.keypointTrackerParams.keypointFalloff;r<o.length;r++){var i=o[r];if(i<=0)throw new Error("Must specify each keypoint falloff parameterto be positive "+"but encountered ".concat(i))}}})(e),this.tracks=[],this.maxTracks=e.maxTracks,this.maxAge=1e3*e.maxAge,this.minSimilarity=e.minSimilarity,this.nextID=1}return t.prototype.apply=function(e,n){this.filterOldTracks(n);var r=this.computeSimilarity(e);return this.assignTracks(e,r,n),this.updateTracks(n),e},t.prototype.getTracks=function(){return this.tracks.slice()},t.prototype.getTrackIDs=function(){return new Set(this.tracks.map(function(e){return e.id}))},t.prototype.filterOldTracks=function(e){var n=this;this.tracks=this.tracks.filter(function(r){return e-r.lastTimestamp<=n.maxAge})},t.prototype.assignTracks=function(e,n,r){for(var o=Array.from(Array(n[0].length).keys()),i=[],a=0,u=Array.from(Array(e.length).keys());a<u.length;a++){var l=u[a];if(o.length!==0){for(var d=-1,f=-1,p=0,h=o;p<h.length;p++){var g=h[p],y=n[l][g];y>=this.minSimilarity&&y>f&&(d=g,f=y)}if(d>=0){var x=this.tracks[d];x=Object.assign(x,this.createTrack(e[l],r,x.id)),e[l].id=x.id;var v=o.indexOf(d);o.splice(v,1)}else i.push(l)}else i.push(l)}for(var w=0,S=i;w<S.length;w++){l=S[w];var I=this.createTrack(e[l],r);this.tracks.push(I),e[l].id=I.id}},t.prototype.updateTracks=function(e){this.tracks.sort(function(n,r){return r.lastTimestamp-n.lastTimestamp}),this.tracks=this.tracks.slice(0,this.maxTracks)},t.prototype.createTrack=function(e,n,r){var o={id:r||this.nextTrackID(),lastTimestamp:n,keypoints:la([],e.keypoints,!0).map(function(i){return wf({},i)})};return e.box!==void 0&&(o.box=wf({},e.box)),o},t.prototype.nextTrackID=function(){var e=this.nextID;return this.nextID+=1,e},t.prototype.remove=function(){for(var e=[],n=0;n<arguments.length;n++)e[n]=arguments[n];this.tracks=this.tracks.filter(function(r){return!e.includes(r.id)})},t.prototype.reset=function(){this.tracks=[]},t}();(function(t){function e(n){return t.call(this,n)||this}return Yw(e,t),e.prototype.computeSimilarity=function(n){var r=this;return n.length===0||this.tracks.length===0?[[]]:n.map(function(o){return r.tracks.map(function(i){return r.iou(o,i)})})},e.prototype.iou=function(n,r){var o=Math.max(n.box.xMin,r.box.xMin),i=Math.max(n.box.yMin,r.box.yMin),a=Math.min(n.box.xMax,r.box.xMax),u=Math.min(n.box.yMax,r.box.yMax);if(o>=a||i>=u)return 0;var l=(a-o)*(u-i);return l/(n.box.width*n.box.height+r.box.width*r.box.height-l)},e})(Qw);(function(t){function e(n){var r=t.call(this,n)||this;return r.keypointThreshold=n.keypointTrackerParams.keypointConfidenceThreshold,r.keypointFalloff=n.keypointTrackerParams.keypointFalloff,r.minNumKeyoints=n.keypointTrackerParams.minNumberOfKeypoints,r}return Yw(e,t),e.prototype.computeSimilarity=function(n){if(n.length===0||this.tracks.length===0)return[[]];for(var r=[],o=0,i=n;o<i.length;o++){for(var a=i[o],u=[],l=0,d=this.tracks;l<d.length;l++){var f=d[l];u.push(this.oks(a,f))}r.push(u)}return r},e.prototype.oks=function(n,r){for(var o=this.area(r.keypoints)+1e-6,i=0,a=0,u=0;u<n.keypoints.length;++u){var l=n.keypoints[u],d=r.keypoints[u];if(!(l.score<this.keypointThreshold||d.score<this.keypointThreshold)){a+=1;var f=Math.pow(l.x-d.x,2)+Math.pow(l.y-d.y,2),p=2*this.keypointFalloff[u];i+=Math.exp(-1*f/(2*o*Math.pow(p,2)))}}return a<this.minNumKeyoints?0:i/a},e.prototype.area=function(n){var r=this,o=n.filter(function(l){return l.score>r.keypointThreshold}),i=Math.min.apply(Math,la([1],o.map(function(l){return l.x}),!1)),a=Math.max.apply(Math,la([0],o.map(function(l){return l.x}),!1)),u=Math.min.apply(Math,la([1],o.map(function(l){return l.y}),!1));return(a-i)*(Math.max.apply(Math,la([0],o.map(function(l){return l.y}),!1))-u)},e})(Qw);(function(t){t.Keypoint="keypoint",t.BoundingBox="boundingBox"})(ky||(ky={})),function(t){t.MoveNet="MoveNet",t.BlazePose="BlazePose",t.PoseNet="PoseNet"}(Ty||(Ty={}));var Ay=zF.reduce(function(t,e,n){return t[e]=n,t},{}),Zw=[["nose","left_eye"],["left_eye","left_ear"],["nose","right_eye"],["right_eye","right_ear"],["nose","left_shoulder"],["left_shoulder","left_elbow"],["left_elbow","left_wrist"],["left_shoulder","left_hip"],["left_hip","left_knee"],["left_knee","left_ankle"],["nose","right_shoulder"],["right_shoulder","right_elbow"],["right_elbow","right_wrist"],["right_shoulder","right_hip"],["right_hip","right_knee"],["right_knee","right_ankle"]].map(function(t){var e=t[0],n=t[1];return[Ay[e],Ay[n]]});Zw.map(function(t){return t[1]});Zw.map(function(t){return t[0]});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const To={},Mu={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function GF(t,e){To[t]=e}function xn(t,e){if(!(t in To)||e!=null){const r=jF(t,e);if(r!==null)To[t]=r;else return console.log("Could not get context for WebGL version",t),null}const n=To[t];return n==null||n.isContextLost()?(delete To[t],xn(t)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),To[t])}function HF(t){if(!V().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&t===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function jF(t,e){if(t!==1&&t!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const n=e??HF(t);return n.addEventListener("webglcontextlost",r=>{r.preventDefault(),delete To[t]},!1),V().getBool("SOFTWARE_WEBGL_ENABLED")&&(Mu.failIfMajorPerformanceCaveat=!1),t===1?n.getContext("webgl",Mu)||n.getContext("experimental-webgl",Mu):n.getContext("webgl2",Mu)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var ya;(function(t){t[t.DENSE=0]="DENSE",t[t.SHARED_BATCH=1]="SHARED_BATCH"})(ya||(ya={}));var zt;(function(t){t[t.RENDER=0]="RENDER",t[t.UPLOAD=1]="UPLOAD",t[t.PIXELS=2]="PIXELS",t[t.DOWNLOAD=3]="DOWNLOAD"})(zt||(zt={}));var at;(function(t){t[t.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",t[t.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",t[t.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",t[t.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",t[t.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(at||(at={}));function ka(t,e){return[e,t]}function XF(t,e){return t*e}function Bu(t){const e=Y(t),n=Math.ceil(e/4);return tf(n)}function qi(t,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(t/2))]}function qF(t,e){const[n,r]=qi(t,e);return n*r*4}function Up(t,e){const n=t;let r,o,i,a,u,l,d,f,p,h;return V().getNumber("WEBGL_VERSION")===2?(r=n.R32F,o=n.R16F,i=n.RGBA16F,a=n.RGBA32F,u=n.RED,d=4,f=1,p=n.HALF_FLOAT,h=n.FLOAT,l=n.RGBA8):(r=t.RGBA,o=t.RGBA,i=t.RGBA,a=n.RGBA,u=t.RGBA,d=4,f=4,p=e!=null?e.HALF_FLOAT_OES:null,h=t.FLOAT,l=t.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:o,internalFormatPackedHalfFloat:i,internalFormatPackedFloat:a,textureFormatFloat:u,downloadTextureFormat:l,downloadUnpackNumChannels:d,defaultNumChannels:f,textureTypeHalfFloat:p,textureTypeFloat:h}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function le(t,e){const n=e();return V().getBool("DEBUG")&&KF(t),n}function KF(t){const e=t.getError();if(e!==t.NO_ERROR)throw new Error("WebGL Error: "+JF(t,e))}const YF=596e-10,QF=65504;function ZF(t){return!!(V().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||t===0||YF<Math.abs(t)&&Math.abs(t)<QF)}function JF(t,e){switch(e){case t.NO_ERROR:return"NO_ERROR";case t.INVALID_ENUM:return"INVALID_ENUM";case t.INVALID_VALUE:return"INVALID_VALUE";case t.INVALID_OPERATION:return"INVALID_OPERATION";case t.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case t.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case t.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}function Uu(t,e){return tr(t,()=>t.getExtension(e),'Extension "'+e+'" not supported on this browser.')}function eL(t,e){const n=tr(t,()=>t.createShader(t.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(le(t,()=>t.shaderSource(n,e)),le(t,()=>t.compileShader(n)),t.getShaderParameter(n,t.COMPILE_STATUS)===!1)throw console.log(t.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}function tL(t,e){const n=tr(t,()=>t.createShader(t.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(le(t,()=>t.shaderSource(n,e)),le(t,()=>t.compileShader(n)),V().get("ENGINE_COMPILE_ONLY"))return n;if(t.getShaderParameter(n,t.COMPILE_STATUS)===!1)throw Jw(e,t.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}const nL=/ERROR: [0-9]+:([0-9]+):/g;function Jw(t,e){const n=nL.exec(e);if(n==null){console.log(`Couldn't parse line number in error: ${e}`),console.log(t);return}const r=+n[1],o=t.split(`
`),i=o.length.toString().length+2,a=o.map((p,h)=>Di((h+1).toString(),i)+p);let u=0;for(let p=0;p<a.length;p++)u=Math.max(a[p].length,u);const l=a.slice(0,r-1),d=a.slice(r-1,r),f=a.slice(r);console.log(l.join(`
`)),console.log(e.split(`
`)[0]),console.log(`%c ${Di(d[0],u)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(f.join(`
`))}function rL(t){return tr(t,()=>t.createProgram(),"Unable to create WebGLProgram.")}function oL(t,e){if(le(t,()=>t.linkProgram(e)),!V().get("ENGINE_COMPILE_ONLY")&&t.getProgramParameter(e,t.LINK_STATUS)===!1)throw console.log(t.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}function Dd(t,e){if(le(t,()=>t.validateProgram(e)),t.getProgramParameter(e,t.VALIDATE_STATUS)===!1)throw console.log(t.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function iL(t,e){const n=tr(t,()=>t.createBuffer(),"Unable to create WebGLBuffer");return le(t,()=>t.bindBuffer(t.ARRAY_BUFFER,n)),le(t,()=>t.bufferData(t.ARRAY_BUFFER,e,t.STATIC_DRAW)),n}function sL(t,e){const n=tr(t,()=>t.createBuffer(),"Unable to create WebGLBuffer");return le(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,n)),le(t,()=>t.bufferData(t.ELEMENT_ARRAY_BUFFER,e,t.STATIC_DRAW)),n}function aL(t){return tr(t,()=>t.createTexture(),"Unable to create WebGLTexture.")}function uL(t,e){const n=V().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(t<=0||e<=0){const r=`[${t}x${e}]`;throw new Error("Requested texture size "+r+" is invalid.")}if(t>n||e>n){const r=`[${t}x${e}]`,o=`[${n}x${n}]`;throw new Error("Requested texture size "+r+" greater than WebGL maximum on this browser / GPU "+o+".")}}function lL(t){return tr(t,()=>t.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function Ny(t,e,n,r,o,i,a){const u=t.getAttribLocation(e,n);return u===-1?!1:(le(t,()=>t.bindBuffer(t.ARRAY_BUFFER,r)),le(t,()=>t.vertexAttribPointer(u,o,t.FLOAT,!1,i,a)),le(t,()=>t.enableVertexAttribArray(u)),!0)}function cL(t,e,n){mL(t,n),le(t,()=>t.activeTexture(t.TEXTURE0+n)),le(t,()=>t.bindTexture(t.TEXTURE_2D,e))}function dL(t,e,n){return tr(t,()=>t.getUniformLocation(e,n),'uniform "'+n+'" not present in program.')}function fL(t,e,n){return t.getUniformLocation(e,n)}function pL(t,e,n,r){le(t,()=>cL(t,e,r)),le(t,()=>t.uniform1i(n,r))}function Fd(t,e,n){le(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,n)),le(t,()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e,0))}function Oy(t,e){le(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,e)),le(t,()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,null,0))}function Wu(t){const e=t.checkFramebufferStatus(t.FRAMEBUFFER);if(e!==t.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+hL(t,e))}function hL(t,e){switch(e){case t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case t.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}function tr(t,e,n){const r=le(t,()=>e());if(r==null)throw new Error(n);return r}function mL(t,e){const n=t.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=e+t.TEXTURE0;if(r<t.TEXTURE0||r>n){const o=`[gl.TEXTURE0, gl.TEXTURE${n}]`;throw new Error(`textureUnit must be in ${o}.`)}}function Vi(t,e=2){return Y(t.slice(0,t.length-e))}function zi(t){if(t.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[t.length>1?t[t.length-2]:1,t[t.length-1]]}function Vu(t){let e=[1,1,1];return t.length===0||t.length===1&&t[0]===1||(e=[Vi(t),...zi(t)]),e}function gL(t,e=!1){let n=V().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=V().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");r===1/0&&V().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=n/2),e&&(n=n*2,r=r*2,t=t.map((u,l)=>l>=t.length-2?kf(t[l]):t[l]),t.length===1&&(t=[2,t[0]])),t.length!==2&&(t=Mo(t).newShape);let o=Y(t),i=null;t.length<=1&&o<=n?i=[1,o]:t.length===2&&t[0]<=n&&t[1]<=n?i=t:t.length===3&&t[0]*t[1]<=n&&t[2]<=n?i=[t[0]*t[1],t[2]]:t.length===3&&t[0]<=n&&t[1]*t[2]<=n?i=[t[0],t[1]*t[2]]:t.length===4&&t[0]*t[1]*t[2]<=n&&t[3]<=n?i=[t[0]*t[1]*t[2],t[3]]:t.length===4&&t[0]<=n&&t[1]*t[2]*t[3]<=n&&(i=[t[0],t[1]*t[2]*t[3]]);const a=i!=null&&Math.max(...i)>r&&Math.min(...i)<=(e?2:1)&&Math.min(...i)>0;if(i==null||a)if(e){const u=Vi(t);let l=2,d=2;t.length&&([l,d]=zi(t)),o=u*(l/2)*(d/2),i=tf(o).map(f=>f*2)}else i=tf(o);return i}function zu(t){return t%2===0}function fl(t,e){if(t=t.slice(-2),e=e.slice(-2),je(t,e)||!t.length||!e.length||t[0]===0||t[1]===0||e[0]===0||e[1]===0)return!0;if(t.length!==e.length){const n=t[t.length-1],r=e[e.length-1];if(n===r||zu(n)&&zu(r)&&(t[0]===1||e[0]===1))return!0}return t[1]===e[1]&&zu(t[0])&&zu(e[0])}let Ld,Md;function yL(t){if(Ld==null){const e=xn(t);Ld=e.getParameter(e.MAX_TEXTURE_SIZE)}return Ld}function xL(t){if(Md==null){const e=xn(t);Md=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,Md)}function vL(t){if(t===0)return 0;let e;const n=xn(t);return Jt(n,"EXT_disjoint_timer_query_webgl2")&&t===2?e=2:Jt(n,"EXT_disjoint_timer_query")?e=1:e=0,e}function Jt(t,e){return t.getExtension(e)!=null}function Dy(t){try{if(xn(t)!=null)return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function CL(t){if(t===0)return!1;const e=xn(t);if(t===1){if(!Jt(e,"OES_texture_float"))return!1}else if(!Jt(e,"EXT_color_buffer_float"))return!1;return Sf(e)}function wL(t){if(t===0)return!1;const e=xn(t);if(t===1){if(!Jt(e,"OES_texture_float")||!Jt(e,"WEBGL_color_buffer_float"))return!1}else{if(Jt(e,"EXT_color_buffer_float"))return Sf(e);const r="EXT_color_buffer_half_float";if(Jt(e,r)){const o=e.getExtension(r);return SL(e,o)}return!1}return Sf(e)}function Sf(t){const e=Up(t),n=t.createTexture();t.bindTexture(t.TEXTURE_2D,n),t.texImage2D(t.TEXTURE_2D,0,e.internalFormatFloat,1,1,0,e.textureFormatFloat,e.textureTypeFloat,null);const i=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,i),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,n,0);const a=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(n),t.deleteFramebuffer(i),a}function SL(t,e){const n=Up(t,e),r=t.createTexture();t.bindTexture(t.TEXTURE_2D,r),t.texImage2D(t.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const a=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,a),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,r,0);const u=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(r),t.deleteFramebuffer(a),u}function bL(t){return t!==2?!1:xn(t).fenceSync!=null}function Ta(t,e){Array.isArray(t)||(t=[t]),t.forEach(n=>{n!=null&&re(n.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGL backend.`)})}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const he=V();he.registerFlag("HAS_WEBGL",()=>he.getNumber("WEBGL_VERSION")>0);he.registerFlag("WEBGL_VERSION",()=>Dy(2)?2:Dy(1)?1:0);he.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);he.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>he.get("WEBGL_VERSION")===2);he.registerFlag("WEBGL_CPU_FORWARD",()=>!0);he.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);he.registerFlag("WEBGL_PACK",()=>he.getBool("HAS_WEBGL"));he.registerFlag("WEBGL_PACK_NORMALIZATION",()=>he.getBool("WEBGL_PACK"));he.registerFlag("WEBGL_PACK_CLIP",()=>he.getBool("WEBGL_PACK"));he.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>he.getBool("WEBGL_PACK"));he.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>he.getBool("WEBGL_PACK"));he.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>he.getBool("WEBGL_PACK"));he.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>he.getBool("WEBGL_PACK"));he.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>he.getBool("WEBGL_PACK"));he.registerFlag("WEBGL_PACK_REDUCE",()=>he.getBool("WEBGL_PACK"));he.registerFlag("WEBGL_LAZILY_UNPACK",()=>he.getBool("WEBGL_PACK"));he.registerFlag("WEBGL_CONV_IM2COL",()=>he.getBool("WEBGL_PACK"));he.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>he.getBool("WEBGL_PACK"));he.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>yL(he.getNumber("WEBGL_VERSION")));he.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>xL(he.getNumber("WEBGL_VERSION")));he.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const t=he.getNumber("WEBGL_VERSION");return t===0?0:vL(t)});he.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>he.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!k0());he.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>CL(he.getNumber("WEBGL_VERSION")));he.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>he.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:he.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));he.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>wL(he.getNumber("WEBGL_VERSION")));he.registerFlag("WEBGL_FENCE_API_ENABLED",()=>bL(he.getNumber("WEBGL_VERSION")));he.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>he.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);he.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,t=>{if(typeof t!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${t}.`);if(t<0&&t!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${t}.`)});he.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>k0()?1:-1,t=>{if(typeof t!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${t}.`);if(t<0&&t!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${t}.`)});he.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);he.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);he.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);he.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);he.registerFlag("WEBGL_EXP_CONV",()=>!1);he.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>he.getBool("IS_TEST"));he.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);he.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);he.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);he.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function St(){let t,e,n,r,o,i,a,u,l,d;return V().getNumber("WEBGL_VERSION")===2?(t="#version 300 es",e="in",n="out",r="in",o="texture",i="outputColor",a="out vec4 outputColor;",u=V().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",l="",d=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(t="",e="attribute",n="varying",r="varying",o="texture2D",i="gl_FragColor",a="",u=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,l=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,d=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:t,attribute:e,varyingVs:n,varyingFs:r,texture2D:o,output:i,defineOutput:a,defineSpecialNaN:u,defineSpecialInf:l,defineRound:d}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ho(t,e,n="index"){const r=Ke(e);return r.map((o,i)=>{const a=`int ${t[i]} = ${n} / ${o}`,u=i===r.length-1?`int ${t[i+1]} = ${n} - ${t[i]} * ${o}`:`index -= ${t[i]} * ${o}`;return`${a}; ${u};`}).join("")}function _l(t,e,n="index"){const r=Ke(e);return r.map((o,i)=>{const a=`int ${t[i]} = ${n} / outShapeStrides[${i}]`,u=i===r.length-1?`int ${t[i+1]} = ${n} - ${t[i]} * outShapeStrides[${i}]`:`index -= ${t[i]} * outShapeStrides[${i}]`;return`${a}; ${u};`}).join("")}function IL(t,e){const n=t.length,r=t.map(i=>`${e}[${i}]`),o=new Array(n-1);o[n-2]=r[n-1];for(let i=n-3;i>=0;--i)o[i]=`(${o[i+1]} * ${r[i+1]})`;return o}function $L(t,e,n="index"){const r=t.map((i,a)=>a),o=IL(r,e);return o.map((i,a)=>{const u=`int ${t[a]} = ${n} / ${o[a]}`,l=a===o.length-1?`int ${t[a+1]} = ${n} - ${t[a]} * ${o[a]}`:`index -= ${t[a]} * ${o[a]}`;return`${u}; ${l};`}).join("")}function Wp(t){const e=Ke(t).map(n=>n.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;
  }
`}function Vp(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const eS=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{getBroadcastDims:tS}=sE;function RL(t,e,n){const r=[];if(t.forEach(g=>{const y=Y(g.shapeInfo.logicalShape);if(g.shapeInfo.isUniform?r.push(`uniform float ${g.name}${y>1?`[${y}]`:""};`):(r.push(`uniform sampler2D ${g.name};`),r.push(`uniform int offset${g.name};`)),n.enableShapeUniforms){const{uniformShape:x}=zp(n.packedInputs,g.shapeInfo.logicalShape,g.shapeInfo.texShape);switch(x.length){case 1:r.push(`uniform int ${g.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${g.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${g.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${g.name}Shape;`);break}r.push(`uniform ivec2 ${g.name}TexShape;`)}}),n.enableShapeUniforms){switch(e.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;");break}r.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach(g=>{r.push(`uniform ${g.type} ${g.name}${g.arrayIndex?`[${g.arrayIndex}]`:""};`)});const o=r.join(`
`),i=t.map(g=>EL(g,e,n.packedInputs,n.enableShapeUniforms)).join(`
`),a=e.texShape,u=St(),l=kL(u);let d,f,p=NL(u);return e.isPacked?(d=_L(e.logicalShape,a,n.enableShapeUniforms),f=AL(u)):(d=PL(e.logicalShape,a,n.enableShapeUniforms),f=TL(u)),n.packedInputs&&(p+=LL),[p,l,f,o,d,i,n.userCode].join(`
`)}function Ki(t,e=!1){const n=t.shapeInfo.logicalShape;switch(n.length){case 0:return KL(t,e);case 1:return QL(t,e);case 2:return JL(t,e);case 3:return tM(t,e);case 4:return rM(t,e);case 5:return oM(t);case 6:return iM(t);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function nS(t,e){switch(t.shapeInfo.logicalShape.length){case 0:return qL(t);case 1:return YL(t,e);case 2:return ZL(t,e);case 3:return eM(t,e);default:return nM(t,e)}}function EL(t,e,n=!1,r){let o="";n?o+=nS(t,r):o+=Ki(t,r);const i=t.shapeInfo.logicalShape,a=e.logicalShape;return i.length<=a.length&&(n?o+=sM(t,e):o+=aM(t,e)),o}function _L(t,e,n){switch(t.length){case 0:return rS();case 1:return ML(t,e,n);case 2:return jL(t,e,n);case 3:return UL(t,e,n);default:return VL(t,e,n)}}function PL(t,e,n){switch(t.length){case 0:return rS();case 1:return BL(t,e,n);case 2:return XL(t,e,n);case 3:return WL(t,e,n);case 4:return zL(t,e,n);case 5:return GL(t,e);case 6:return HL(t,e);default:throw new Error(`${t.length}-D output sampling is not yet supported`)}}function kL(t){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${t.texture2D}(textureSampler, uv).r;
    }
  `}function TL(t){return`
    void setOutput(float val) {
      ${t.output} = vec4(val, 0, 0, 0);
    }
  `}function AL(t){return`
    void setOutput(vec4 val) {
      ${t.output} = val;
    }
  `}function NL(t){return`${t.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${t.varyingFs} vec2 resultUV;
    ${t.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${t.defineSpecialNaN}
    ${t.defineSpecialInf}
    ${t.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${OL}
    ${DL}
    ${FL}
  `}const OL=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,DL=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,FL=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,LL=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function rS(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function ML(t,e,n){const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return r[0]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${r[1]}.0);
      }
    `:r[1]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${r[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);
    }
  `}function BL(t,e,n){return e[0]===1?n?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${e[1]}.0);
      }
    `:e[1]===1?n?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${e[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      return resTexRC.x * ${e[1]} + resTexRC.y;
    }
  `}function UL(t,e,n){if(n)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],o=Math.ceil(t[2]/2),i=o*Math.ceil(t[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      int b = index / ${i};
      index -= b * ${i};

      int r = 2 * (index / ${o});
      int c = imod(index, ${o}) * 2;

      return ivec3(b, r, c);
    }
  `}function WL(t,e,n){if(n)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${_l(["r","c","d"],t)}
    return ivec3(r, c, d);
  }
`;const r=Ho(["r","c","d"],t);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${r}
      return ivec3(r, c, d);
    }
  `}function VL(t,e,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],o=Math.ceil(t[t.length-1]/2),i=o*Math.ceil(t[t.length-2]/2);let a=i,u="",l="b, r, c";for(let d=2;d<t.length-1;d++)a*=t[t.length-d-1],u=`
      int b${d} = index / ${a};
      index -= b${d} * ${a};
    `+u,l=`b${d}, `+l;return`
    ivec${t.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      ${u}

      int b = index / ${i};
      index -= b * ${i};

      int r = 2 * (index / ${o});
      int c = imod(index, ${o}) * 2;

      return ivec${t.length}(${l});
    }
  `}function zL(t,e,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${_l(["r","c","d","d2"],t)}
      return ivec4(r, c, d, d2);
    }
  `;const r=Ho(["r","c","d","d2"],t);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${r}
      return ivec4(r, c, d, d2);
    }
  `}function GL(t,e){const n=Ho(["r","c","d","d2","d3"],t);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},
                             ${e[1]}));

      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${n}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function HL(t,e){const n=Ho(["r","c","d","d2","d3","d4"],t);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${n}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function jL(t,e,n){const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(je(t,e))return n?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));
      }
    `;const o=Math.ceil(t[1]/2);return n?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));

      int index = resTexRC.x * ${r[1]} + resTexRC.y;
      int r = 2 * (index / ${o});
      int c = imod(index, ${o}) * 2;

      return ivec2(r, c);
    }
  `}function XL(t,e,n){return je(t,e)?n?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));
      }
    `:t[1]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:t[0]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:n?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      int r = index / ${t[1]};
      int c = index - r * ${t[1]};
      return ivec2(r, c);
    }
  `}function jo(t){return`offset${t}`}function qL(t){const e=t.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),r=St();return`
    vec4 ${n}() {
      return ${r.texture2D}(${e}, halfCR);
    }
  `}function KL(t,e){const n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(t.shapeInfo.isUniform)return`float ${r}() {return ${n};}`;const[o,i]=t.shapeInfo.texShape;if(o===1&&i===1)return`
      float ${r}() {
        return sampleTexture(${n}, halfCR);
      }
    `;const a=jo(n);if(e)return`
    float ${r}() {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${a});
      return sampleTexture(${n}, uv);
    }
  `;const[u,l]=t.shapeInfo.texShape;return`
    float ${r}() {
      vec2 uv = uvFromFlat(${u}, ${l}, ${a});
      return sampleTexture(${n}, uv);
    }
  `}function YL(t,e){const n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),o=t.shapeInfo.texShape,i=St();if(e)return`
    vec4 ${r}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${i.texture2D}(${n}, uv);
    }
  `;const a=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];return`
    vec4 ${r}(int index) {
      vec2 uv = packedUVfrom1D(
        ${a[0]}, ${a[1]}, index);
      return ${i.texture2D}(${n}, uv);
    }
  `}function QL(t,e){const n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(t.shapeInfo.isUniform)return`
      float ${r}(int index) {
        ${Yi(t)}
      }
    `;const o=t.shapeInfo.texShape,i=o[0],a=o[1];if(a===1&&i===1)return`
      float ${r}(int index) {
        return sampleTexture(${n}, halfCR);
      }
    `;const u=jo(n);return a===1?e?`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${u}) + 0.5) / float(${n}TexShape[0]));
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${u}) + 0.5) / ${i}.0);
        return sampleTexture(${n}, uv);
      }
    `:i===1?e?`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${u}) + 0.5) / float(${n}TexShape[1]), 0.5);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${u}) + 0.5) / ${a}.0, 0.5);
        return sampleTexture(${n}, uv);
      }
    `:e?`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${u});
      return sampleTexture(${n}, uv);
    }
  `:`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${i}, ${a}, index + ${u});
      return sampleTexture(${n}, uv);
    }
  `}function ZL(t,e){const n=t.shapeInfo.logicalShape,r=t.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),i=t.shapeInfo.texShape,a=i[0],u=i[1],l=St();if(i!=null&&je(n,i))return e?`
      vec4 ${o}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);

        return ${l.texture2D}(${r}, uv);
      }
    `:`
      vec4 ${o}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${u}.0, ${a}.0);

        return ${l.texture2D}(${r}, uv);
      }
    `;if(e)return`
    vec4 ${o}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${l.texture2D}(${r}, uv);
    }
  `;const d=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],f=Math.ceil(n[1]/2);return`
    vec4 ${o}(int row, int col) {
      vec2 uv = packedUVfrom2D(${f}, ${d[0]}, ${d[1]}, row, col);
      return ${l.texture2D}(${r}, uv);
    }
  `}function JL(t,e){const n=t.shapeInfo.logicalShape,r=t.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),i=t.shapeInfo.texShape;if(i!=null&&je(n,i)){if(e)return`
      float ${o}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `;const h=i[0],g=i[1];return`
    float ${o}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${g}.0, ${h}.0);
      return sampleTexture(${r}, uv);
    }
  `}const{newShape:a,keptDims:u}=Mo(n),l=a;if(l.length<n.length){const h=Qi(t,l),g=["row","col"];return`
      ${Ki(h,e)}
      float ${o}(int row, int col) {
        return ${o}(${Zi(g,u)});
      }
    `}if(t.shapeInfo.isUniform)return`
      float ${o}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));
        ${Yi(t)}
      }
    `;const d=i[0],f=i[1],p=jo(r);return f===1?e?`
      float ${o}(int row, int col) {
        float index = dot(vec3(row, col, ${p}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${o}(int row, int col) {
      float index = dot(vec3(row, col, ${p}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${d}.0);
      return sampleTexture(${r}, uv);
    }
  `:d===1?e?`
      float ${o}(int row, int col) {
        float index = dot(vec3(row, col, ${p}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${o}(int row, int col) {
      float index = dot(vec3(row, col, ${p}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${f}.0, 0.5);
      return sampleTexture(${r}, uv);
    }
  `:e?`
      float ${o}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${r}Shape[1] + col + ${p};
        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
        return sampleTexture(${r}, uv);
      }
    `:`
  float ${o}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${n[1]} + col + ${p};
    vec2 uv = uvFromFlat(${d}, ${f}, index);
    return sampleTexture(${r}, uv);
  }
`}function eM(t,e){const n=t.shapeInfo.logicalShape,r=t.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),i=t.shapeInfo.texShape,a=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];if(n[0]===1){const h=n.slice(1),g=[1,2],y=Qi(t,h),x=["b","row","col"];return`
        ${nS(y,e)}
        vec4 ${o}(int b, int row, int col) {
          return ${o}(${Zi(x,g)});
        }
      `}const u=St();if(e)return`
    vec4 ${o}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${u.texture2D}(${r}, uv);
    }
  `;const l=a[0],d=a[1],f=Math.ceil(n[2]/2),p=f*Math.ceil(n[1]/2);return`
    vec4 ${o}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${l}, ${d}, ${p}, ${f}, b, row, col);
      return ${u.texture2D}(${r}, uv);
    }
  `}function tM(t,e){const n=t.shapeInfo.logicalShape,r=t.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),i=n[1]*n[2],a=n[2],{newShape:u,keptDims:l}=Mo(n),d=u;if(d.length<n.length){const x=Qi(t,d),v=["row","col","depth"];return`
        ${Ki(x,e)}
        float ${o}(int row, int col, int depth) {
          return ${o}(${Zi(v,l)});
        }
      `}if(t.shapeInfo.isUniform)return`
      float ${o}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${i}, ${a}, 1)));
        ${Yi(t)}
      }
    `;const f=t.shapeInfo.texShape,p=f[0],h=f[1],g=t.shapeInfo.flatOffset;if(h===i&&g==null)return e?`
      float ${o}(int row, int col, int depth) {
        int stride1 = ${r}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
        float ${o}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${a}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${h}.0, ${p}.0);
          return sampleTexture(${r}, uv);
        }
      `;if(h===a&&g==null)return e?`
      float ${o}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${o}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${h}.0, ${p}.0);
      return sampleTexture(${r}, uv);
    }
  `;const y=jo(r);return e?`
    float ${o}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${r}Shape[1] * ${r}Shape[2];
      int stride1 = ${r}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${y};
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
      return sampleTexture(${r}, uv);
    }
    `:`
      float ${o}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${i} + col * ${a} + depth + ${y};
        vec2 uv = uvFromFlat(${p}, ${h}, index);
        return sampleTexture(${r}, uv);
      }
  `}function nM(t,e){const n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),o=St();if(e)return`
    vec4 ${r}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${n}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${o.texture2D}(${n}, uv);
    }
  `;const i=t.shapeInfo.logicalShape,a=i.length,u=t.shapeInfo.texShape,l=[Math.ceil(u[0]/2),Math.ceil(u[1]/2)],d=l[0],f=l[1],p=Math.ceil(i[a-1]/2);let h=p*Math.ceil(i[a-2]/2),g="int b, int row, int col",y=`b * ${h} + (row / 2) * ${p} + (col / 2)`;for(let x=2;x<a-1;x++)g=`int b${x}, `+g,h*=i[a-x-1],y=`b${x} * ${h} + `+y;return`
    vec4 ${r}(${g}) {
      int index = ${y};
      int texR = index / ${f};
      int texC = index - texR * ${f};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${f}, ${d});
      return ${o.texture2D}(${n}, uv);
    }
  `}function rM(t,e){const n=t.shapeInfo.logicalShape,r=t.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),i=n[3],a=n[2]*i,u=n[1]*a,{newShape:l,keptDims:d}=Mo(n);if(l.length<n.length){const S=Qi(t,l),I=["row","col","depth","depth2"];return`
      ${Ki(S,e)}
      float ${o}(int row, int col, int depth, int depth2) {
        return ${o}(${Zi(I,d)});
      }
    `}if(t.shapeInfo.isUniform)return`
      float ${o}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${u}, ${a}, ${i}, 1)));
        ${Yi(t)}
      }
    `;const f=t.shapeInfo.flatOffset,p=t.shapeInfo.texShape,h=p[0],g=p[1],y=`int stride2 = ${r}Shape[3];`,x=`int stride1 = ${r}Shape[2] * stride2;`,v=`int stride0 = ${r}Shape[1] * stride1;`;if(g===u&&f==null)return e?`
      float ${o}(int row, int col, int depth, int depth2) {
        ${y}
        ${x}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${o}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${a}, ${i}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${g}.0, ${h}.0);
        return sampleTexture(${r}, uv);
      }
    `;if(g===i&&f==null)return e?`
      float ${o}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${o}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${n[1]*n[2]}, ${n[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${g}.0, ${h}.0);
        return sampleTexture(${r}, uv);
      }
    `;const w=jo(r);return e?`
    float ${o}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${y}
      ${x}
      ${v}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${w});
      return sampleTexture(${r}, uv);
    }
  `:`
    float ${o}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${u} + col * ${a} +
          depth * ${i} + depth2;
      vec2 uv = uvFromFlat(${h}, ${g}, index + ${w});
      return sampleTexture(${r}, uv);
    }
  `}function oM(t){const e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),o=e[4],i=e[3]*o,a=e[2]*i,u=e[1]*a,{newShape:l,keptDims:d}=Mo(e);if(l.length<e.length){const x=Qi(t,l),v=["row","col","depth","depth2","depth3"];return`
      ${Ki(x)}
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        return ${r}(${Zi(v,d)});
      }
    `}if(t.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${u}, ${a}, ${i}, ${o})) +
          depth3;
        ${Yi(t)}
      }
    `;const f=t.shapeInfo.flatOffset,p=t.shapeInfo.texShape,h=p[0],g=p[1];if(g===u&&f==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${a}, ${i}, ${o}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${g}.0, ${h}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(g===o&&f==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]},
               ${e[2]*e[3]}, ${e[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${g}.0, ${h}.0);
        return sampleTexture(${n}, uv);
      }
    `;const y=jo(n);return`
    float ${r}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${u} + col * ${a} + depth * ${i} +
          depth2 * ${o} + depth3 + ${y};
      vec2 uv = uvFromFlat(${h}, ${g}, index);
      return sampleTexture(${n}, uv);
    }
  `}function iM(t){const e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:o,keptDims:i}=Mo(e);if(o.length<e.length){const v=Qi(t,o),w=["row","col","depth","depth2","depth3","depth4"];return`
      ${Ki(v)}
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${r}(${Zi(w,i)});
      }
    `}const a=e[5],u=e[4]*a,l=e[3]*u,d=e[2]*l,f=e[1]*d;if(t.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${f}, ${d}, ${l}, ${u})) +
          dot(
            vec2(depth3, depth4),
            vec2(${a}, 1)));
        ${Yi(t)}
      }
    `;const p=t.shapeInfo.flatOffset,h=t.shapeInfo.texShape,g=h[0],y=h[1];if(y===f&&p==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${d}, ${l}, ${u}, ${a})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${y}.0, ${g}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(y===a&&p==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]*e[4]},
               ${e[2]*e[3]*e[4]},
               ${e[3]*e[4]},
               ${e[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${y}.0, ${g}.0);
        return sampleTexture(${n}, uv);
      }
    `;const x=jo(n);return`
    float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${f} + col * ${d} + depth * ${l} +
          depth2 * ${u} + depth3 * ${a} + depth4 + ${x};
      vec2 uv = uvFromFlat(${g}, ${y}, index);
      return sampleTexture(${n}, uv);
    }
  `}function Yi(t){const e=t.name,n=Y(t.shapeInfo.logicalShape);return n<2?`return ${e};`:`
    for (int i = 0; i < ${n}; i++) {
      if (i == index) {
        return ${e}[i];
      }
    }
  `}function sM(t,e){const n=t.name,r=n.charAt(0).toUpperCase()+n.slice(1),o="get"+r+"AtOutCoords",i=t.shapeInfo.logicalShape.length,a=e.logicalShape.length,u=tS(t.shapeInfo.logicalShape,e.logicalShape),l=Me(a),d=a-i;let f;const p=["x","y","z","w","u","v"];i===0?f="":a<2&&u.length>=1?f="coords = 0;":f=u.map(S=>`coords.${p[S+d]} = 0;`).join(`
`);let h="";a<2&&i>0?h="coords":h=t.shapeInfo.logicalShape.map((S,I)=>`coords.${p[I+d]}`).join(", ");let g="return outputValue;";const x=Y(t.shapeInfo.logicalShape)===1,w=Y(e.logicalShape)===1;if(i===1&&!x&&!w)g=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(x&&!w)a===1?g=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:g=`
        return vec4(outputValue.x);
      `;else if(u.length){const S=i-2,I=i-1;u.indexOf(S)>-1&&u.indexOf(I)>-1?g="return vec4(outputValue.x);":u.indexOf(S)>-1?g="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":u.indexOf(I)>-1&&(g="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${o}() {
      ${l} coords = getOutputCoords();
      ${f}
      vec4 outputValue = get${r}(${h});
      ${g}
    }
  `}function aM(t,e){const n=t.name,r=n.charAt(0).toUpperCase()+n.slice(1),o="get"+r+"AtOutCoords",i=e.texShape,a=t.shapeInfo.texShape,u=t.shapeInfo.logicalShape.length,l=e.logicalShape.length;if(!t.shapeInfo.isUniform&&u===l&&t.shapeInfo.flatOffset==null&&je(a,i))return`
      float ${o}() {
        return sampleTexture(${n}, resultUV);
      }
    `;const d=Me(l),f=tS(t.shapeInfo.logicalShape,e.logicalShape),p=l-u;let h;const g=["x","y","z","w","u","v"];u===0?h="":l<2&&f.length>=1?h="coords = 0;":h=f.map(x=>`coords.${g[x+p]} = 0;`).join(`
`);let y="";return l<2&&u>0?y="coords":y=t.shapeInfo.logicalShape.map((x,v)=>`coords.${g[v+p]}`).join(", "),`
    float ${o}() {
      ${d} coords = getOutputCoords();
      ${h}
      return get${r}(${y});
    }
  `}function Me(t){if(t<=1)return"int";if(t===2)return"ivec2";if(t===3)return"ivec3";if(t===4)return"ivec4";if(t===5)return"ivec5";if(t===6)return"ivec6";throw Error(`GPU for rank ${t} is not yet supported`)}function zp(t,e,n){const{newShape:r,keptDims:o}=Mo(e),i=e.length,a=t&&i===3&&e[0]===1,u=a?e.slice(1):r,l=!t&&i>1&&!je(e,n)&&r.length<i||a;return{useSqueezeShape:l,uniformShape:l?u:e,keptDims:o}}function Qi(t,e){const n=JSON.parse(JSON.stringify(t));return n.shapeInfo.logicalShape=e,n}function Zi(t,e){return e.map(n=>t[n]).join(", ")}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uM(t,e,n,r){const o=n.map((f,p)=>{const h={logicalShape:f.shape,texShape:f.isUniform?null:f.texData.texShape,isUniform:f.isUniform,isPacked:f.isUniform?!1:f.texData.isPacked,flatOffset:null};return f.texData!=null&&f.texData.slice!=null&&f.texData.slice.flatOffset>0&&(h.flatOffset=f.texData.slice.flatOffset),{name:e.variableNames[p],shapeInfo:h}}),i=o.map(f=>f.shapeInfo),a={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},u=RL(o,a,e),l=tL(t.gl,u),d=t.createProgram(l);return V().get("ENGINE_COMPILE_ONLY")?{program:e,fragmentShader:l,source:u,webGLProgram:d,inShapeInfos:i,outShapeInfo:a,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(t.buildVao(d),Object.assign({program:e,fragmentShader:l,source:u,webGLProgram:d,inShapeInfos:i,outShapeInfo:a},oS(t,e,d)))}function oS(t,e,n){const r=[],o=[];let i,a,u,l=null,d=null;d=t.getUniformLocation(n,"NAN",!1),V().getNumber("WEBGL_VERSION")===1&&(l=t.getUniformLocation(n,"INFINITY",!1));const f=!1;for(const p of e.variableNames){const h={name:p,uniform:t.getUniformLocation(n,p,f),offset:t.getUniformLocation(n,`offset${p}`,f)};e.enableShapeUniforms&&(h.shape=t.getUniformLocation(n,`${p}Shape`,f),h.texShape=t.getUniformLocation(n,`${p}TexShape`,f)),r.push(h)}if(e.enableShapeUniforms&&(i=t.getUniformLocation(n,"outShape",f),u=t.getUniformLocation(n,"outShapeStrides",f),a=t.getUniformLocation(n,"outTexShape",f)),e.customUniforms)for(const p of e.customUniforms)o.push(t.getUniformLocation(n,p.name,f));return{variablesLocations:r,customUniformLocations:o,infLoc:l,nanLoc:d,outShapeLocation:i,outShapeStridesLocation:u,outTexShapeLocation:a}}function Fy(t,e){if(t.length!==e.length)throw Error(`Binary was compiled with ${t.length} inputs, but was executed with ${e.length} inputs`);t.forEach((n,r)=>{const o=n.logicalShape,i=e[r],a=i.shape;if(!je(o,a))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${o} and ${a} must match`);if(n.isUniform&&i.isUniform)return;const u=n.texShape,l=i.isUniform?null:i.texData.texShape;if(!je(u,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${u} and ${l} must match`)})}function lM(t,e,n,r,o){e.program.enableShapeUniforms||(Fy(e.inShapeInfos,n),Fy([e.outShapeInfo],[r]));const i=r.texData.texture,a=r.texData.texShape;r.texData.isPacked?t.setOutputPackedMatrixTexture(i.texture,a[0],a[1]):t.setOutputMatrixTexture(i.texture,a[0],a[1]),t.setProgram(e.webGLProgram),t.bindVertexArray(e.webGLProgram.vao),V().getNumber("WEBGL_VERSION")===1&&e.infLoc!==null&&t.gl.uniform1f(e.infLoc,1/0),e.nanLoc!==null&&t.gl.uniform1f(e.nanLoc,NaN);for(let l=0;l<n.length;++l){const d=n[l],{uniform:f,offset:p,shape:h,texShape:g}=e.variablesLocations[l];if(h){const{uniformShape:y}=zp(e.program.packedInputs,d.shape,d.texData.texShape);switch(y.length){case 1:t.gl.uniform1iv(h,new Int32Array(y));break;case 2:t.gl.uniform2iv(h,new Int32Array(y));break;case 3:t.gl.uniform3iv(h,new Int32Array(y));break;case 4:t.gl.uniform4iv(h,new Int32Array(y));break}}if(g&&t.gl.uniform2i(g,d.texData.texShape[0],d.texData.texShape[1]),f!=null){if(d.isUniform){if(Y(d.shape)<2)t.gl.uniform1f(f,d.uniformValues[0]);else{let y=d.uniformValues;y instanceof Float32Array||(y=new Float32Array(y)),t.gl.uniform1fv(f,y)}continue}d.texData.slice!=null&&p!=null&&t.gl.uniform1i(p,d.texData.slice.flatOffset),t.setInputMatrixTexture(d.texData.texture.texture,f,l)}}const u=e.outShapeLocation;if(u)switch(r.shape.length){case 1:t.gl.uniform1iv(u,new Int32Array(r.shape));break;case 2:t.gl.uniform2iv(u,new Int32Array(r.shape));break;case 3:t.gl.uniform3iv(u,new Int32Array(r.shape));break;case 4:t.gl.uniform4iv(u,new Int32Array(r.shape));break}if(e.outShapeStridesLocation){const l=Ke(r.shape);switch(r.shape.length){case 2:t.gl.uniform1iv(e.outShapeStridesLocation,new Int32Array(l));break;case 3:t.gl.uniform2iv(e.outShapeStridesLocation,new Int32Array(l));break;case 4:t.gl.uniform3iv(e.outShapeStridesLocation,new Int32Array(l));break}}if(e.outTexShapeLocation&&t.gl.uniform2i(e.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),e.program.customUniforms&&o)for(let l=0;l<e.program.customUniforms.length;++l){const d=e.program.customUniforms[l],f=e.customUniformLocations[l],p=o[l];if(d.type==="float")t.gl.uniform1fv(f,p);else if(d.type==="vec2")t.gl.uniform2fv(f,p);else if(d.type==="vec3")t.gl.uniform3fv(f,p);else if(d.type==="vec4")t.gl.uniform4fv(f,p);else if(d.type==="int")t.gl.uniform1iv(f,p);else if(d.type==="ivec2")t.gl.uniform2iv(f,p);else if(d.type==="ivec3")t.gl.uniform3iv(f,p);else if(d.type==="ivec4")t.gl.uniform4iv(f,p);else throw Error(`uniform type ${d.type} is not supported yet.`)}t.executeProgram()}function cM(t,e,n){let r="";e.concat(n).forEach(a=>{const u=a.texData!=null&&a.texData.slice!=null&&a.texData.slice.flatOffset>0;if(t.enableShapeUniforms&&!a.isUniform){const l=a.texData.texShape,{useSqueezeShape:d,uniformShape:f,keptDims:p}=zp(t.packedInputs,a.shape,l);let h="",g="",y="";if(f.length===1&&t.packedInputs){const R=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];h=`${R[0]>1}_${R[1]>1}`}else if(f.length===2&&!t.packedInputs)g=`${f[0]>1}_${f[1]>1}`;else if(f.length>2&&!t.packedInputs){const R=Ke(f);y=`${R[0]===l[1]}_${R[R.length-1]===l[1]}`}const x=a.shape.length,v=f.length===2&&je(a.shape,l),w=Y(a.shape)===1,S=Bi(a.shape,n.shape),I=!t.packedInputs&&x===n.shape.length&&je(l,n.texData.texShape),E=t.packedInputs||f.length>2?"":`${l[0]>1}_${l[1]>1}`;r+=`${x}_${I}_${d?p:""}_${f.length}_${w}_${S}_${v}_${h}_${g}_${y}_${E}_${u}`}else{const l=a.isUniform?"uniform":a.texData.texShape;r+=`${a.shape}_${l}_${u}`}});const o=t.userCode;let i=t.constructor.name;return i+="_"+r+"_"+o+`${V().getNumber("WEBGL_VERSION")}`,i}function pt(t){return V().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&t<=4}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dM{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=ya.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=St();this.outputShape=e,this.enableShapeUniforms=pt(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?_l(["r","c","d"],e):Ho(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${n.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fM{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=ya.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=St();this.outputShape=e,this.enableShapeUniforms=pt(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?_l(["r","c","d"],e):Ho(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${n.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pM{constructor(e){this.variableNames=["A"],this.outTexUsage=zt.DOWNLOAD;const n=St();this.outputShape=e,this.userCode=`
      ${eS}

      void main() {
        float x = getAAtOutCoords();
        ${n.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hM{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=zt.DOWNLOAD;const n=St();this.outputShape=e,this.userCode=`
      ${eS}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${n.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mM={R:0,G:1,B:2,A:3};class Ly{constructor(e,n=!1,r="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const o=St();this.outputShape=e,this.enableShapeUniforms=pt(this.outputShape.length);let i="result";n&&(i="floor(result * 255. + 0.5)");let a="";for(let u=0;u<r.length;u++){const l=r[u];a+=`
          if(offset == ${u}) {
            result = values[${mM[l]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?Vp():Wp(e)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${r.length});

        flatIndex = idiv(flatIndex, ${r.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${o.texture2D}(A, uv);
          ${a}
        }
        ${o.output} = vec4(${i}, 0., 0., 0.);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gM{constructor(e,n=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=St();this.outputShape=e,this.enableShapeUniforms=pt(this.outputShape.length);let o="",i="result";n&&(i="floor(result * 255. + 0.5)");for(let a=0;a<=1;a++)for(let u=0;u<=1;u++){const l=a*2+u;o+=`
          localCoords = coords;
          if(localCoords[2] + ${u} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${u};
          if (localCoords[1] + ${a} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${a};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${r.texture2D}(A, uv);

            if (offset == 0) {
              result[${l}] = values[0];
            } else if (offset == 1) {
              result[${l}] = values[1];
            } else if (offset == 2) {
              result[${l}] = values[2];
            } else {
              result[${l}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?Vp():Wp(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${o}

          ${r.output} = ${i};
        }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yM(t){const e=St(),n=`${e.version}
    precision highp float;
    ${e.attribute} vec3 clipSpacePos;
    ${e.attribute} vec2 uv;
    ${e.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return eL(t,n)}function xM(t){const e=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return iL(t,e)}function vM(t){const e=new Uint16Array([0,1,2,2,1,3]);return sL(t,e)}function Aa(t,e,n,r,o,i){uL(e,n);const a=aL(t),u=t.TEXTURE_2D;return le(t,()=>t.bindTexture(u,a)),le(t,()=>t.texParameteri(u,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE)),le(t,()=>t.texParameteri(u,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE)),le(t,()=>t.texParameteri(u,t.TEXTURE_MIN_FILTER,t.NEAREST)),le(t,()=>t.texParameteri(u,t.TEXTURE_MAG_FILTER,t.NEAREST)),V().getNumber("WEBGL_VERSION")===1?le(t,()=>t.texImage2D(u,0,r,e,n,0,o,i,null)):le(t,()=>t.texStorage2D(u,1,r,e,n)),le(t,()=>t.bindTexture(t.TEXTURE_2D,null)),{texture:a,texShape:[n,e]}}function iS(t){return t.internalFormatFloat}function CM(t,e,n,r){const[o,i]=ka(e,n);return Aa(t,o,i,iS(r),r.textureFormatFloat,t.FLOAT)}function sS(t){return t.internalFormatHalfFloat}function wM(t,e,n,r){const[o,i]=ka(e,n);return Aa(t,o,i,sS(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function aS(t){return t.downloadTextureFormat}function SM(t,e,n,r){const[o,i]=ka(e,n);return Aa(t,o,i,aS(r),t.RGBA,t.UNSIGNED_BYTE)}function uS(t){return t.internalFormatPackedFloat}function bM(t,e,n,r){const[o,i]=qi(e,n);return Aa(t,o,i,uS(r),t.RGBA,t.FLOAT)}function lS(t){return t.internalFormatPackedHalfFloat}function IM(t,e,n,r){const[o,i]=qi(e,n);return Aa(t,o,i,lS(r),t.RGBA,r.textureTypeHalfFloat)}function $M(t,e,n){return le(t,()=>t.bindBuffer(t.ARRAY_BUFFER,n)),Ny(t,e,"clipSpacePos",n,3,20,0)&&Ny(t,e,"uv",n,2,20,12)}function RM(t,e,n,r,o,i){le(t,()=>t.bindTexture(t.TEXTURE_2D,e));let a,u,l;o instanceof Uint8Array?(a=new Uint8Array(n*r*4),u=t.UNSIGNED_BYTE,l=t.RGBA):(a=new Float32Array(n*r*4),u=t.FLOAT,l=i.internalFormatPackedFloat),a.set(o),V().getNumber("WEBGL_VERSION")===2?le(t,()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,n,r,t.RGBA,u,a)):le(t,()=>t.texImage2D(t.TEXTURE_2D,0,l,n,r,0,t.RGBA,u,a)),le(t,()=>t.bindTexture(t.TEXTURE_2D,null))}function EM(t,e,n){le(t,()=>t.bindTexture(t.TEXTURE_2D,e)),n.data instanceof Uint8Array?V().getNumber("WEBGL_VERSION")===2?le(t,()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,n.width,n.height,t.RGBA,t.UNSIGNED_BYTE,n.data)):le(t,()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,n.width,n.height,0,t.RGBA,t.UNSIGNED_BYTE,n.data)):V().getNumber("WEBGL_VERSION")===2?le(t,()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,t.RGBA,t.UNSIGNED_BYTE,n)):le(t,()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,n)),le(t,()=>t.bindTexture(t.TEXTURE_2D,null))}function _M(t,e,n,r){const o=t.createBuffer();le(t,()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,o));const u=4*4*e*n;return le(t,()=>t.bufferData(t.PIXEL_PACK_BUFFER,u,t.STREAM_READ)),le(t,()=>t.readPixels(0,0,n,e,t.RGBA,t.FLOAT,0)),le(t,()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,null)),o}function PM(t,e,n){const r=t,o=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,e),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,o),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),o}function kM(t,e,n,r){const[o,i]=ka(e,n),a=4,u=new Uint8Array(XF(e*n,a));return le(t,()=>t.readPixels(0,0,o,i,r.downloadTextureFormat,t.UNSIGNED_BYTE,u)),new Float32Array(u.buffer)}function TM(t,e,n,r,o,i,a,u){const l=t,d=new Float32Array(qF(i,a));return l.bindBuffer(l.PIXEL_PACK_BUFFER,e),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,d),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),d}function AM(t,e,n){const r=new Float32Array(e*n*4);return le(t,()=>t.readPixels(0,0,n,e,t.RGBA,t.FLOAT,r)),r}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Bd{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const n=V().getNumber("WEBGL_VERSION");if(e!=null?(this.gl=e,GF(n,e)):this.gl=xn(n),e=this.gl,V().getNumber("WEBGL_VERSION")===2){const i=e;this.createVertexArray=()=>le(i,()=>i.createVertexArray()),this.bindVertexArray=a=>le(i,()=>i.bindVertexArray(a)),this.deleteVertexArray=a=>le(i,()=>i.deleteVertexArray(a)),this.getVertexArray=()=>le(i,()=>i.getParameter(i.VERTEX_ARRAY_BINDING))}else if(e!=null){const i=e.getExtension("OES_vertex_array_object");if(i==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>le(e,()=>i.createVertexArrayOES()),this.bindVertexArray=a=>le(e,()=>i.bindVertexArrayOES(a)),this.deleteVertexArray=a=>le(e,()=>i.deleteVertexArrayOES(a)),this.getVertexArray=()=>le(e,()=>e.getParameter(i.VERTEX_ARRAY_BINDING_OES))}let r="WEBGL_color_buffer_float";const o="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),V().getNumber("WEBGL_VERSION")===1){const i="OES_texture_float",a="OES_texture_half_float";if(this.textureFloatExtension=Uu(this.gl,i),Jt(this.gl,a))this.textureHalfFloatExtension=Uu(this.gl,a);else if(V().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(r),Jt(this.gl,o))this.colorBufferHalfFloatExtension=Uu(this.gl,o);else if(V().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(r="EXT_color_buffer_float",Jt(this.gl,r))this.colorBufferFloatExtension=this.gl.getExtension(r);else if(Jt(this.gl,o))this.colorBufferHalfFloatExtension=this.gl.getExtension(o);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=xM(this.gl),this.indexBuffer=vM(this.gl),this.framebuffer=lL(this.gl),this.textureConfig=Up(this.gl,this.textureHalfFloatExtension)}get debug(){return V().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;le(e,()=>e.finish()),le(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),le(e,()=>e.deleteFramebuffer(this.framebuffer)),le(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),le(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),le(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,n){return this.throwIfDisposed(),CM(this.gl,e,n,this.textureConfig)}createFloat16MatrixTexture(e,n){return this.throwIfDisposed(),wM(this.gl,e,n,this.textureConfig)}createUnsignedBytesMatrixTexture(e,n){return this.throwIfDisposed(),SM(this.gl,e,n,this.textureConfig)}uploadPixelDataToTexture(e,n){this.throwIfDisposed(),EM(this.gl,e,n)}uploadDenseMatrixToTexture(e,n,r,o){this.throwIfDisposed(),RM(this.gl,e,n,r,o,this.textureConfig)}createFloat16PackedMatrixTexture(e,n){return this.throwIfDisposed(),IM(this.gl,e,n,this.textureConfig)}createPackedMatrixTexture(e,n){return this.throwIfDisposed(),bM(this.gl,e,n,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(Oy(this.gl,this.framebuffer),this.outputTexture=null),le(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,n,r){return this.downloadMatrixDriver(e,()=>kM(this.gl,n,r,this.textureConfig))}downloadPackedMatrixFromBuffer(e,n,r,o,i,a){return TM(this.gl,e,n,r,o,i,a,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,n){return PM(this.gl,e,n)}createBufferFromTexture(e,n,r){this.bindTextureToFrameBuffer(e);const o=_M(this.gl,n,r,this.textureConfig);return this.unbindTextureToFrameBuffer(),o}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let n,r;if(V().getBool("WEBGL_FENCE_API_ENABLED")){const o=e,i=o.fenceSync(o.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),r=()=>{const a=o.clientWaitSync(i,0,0);return a===o.ALREADY_SIGNALED||a===o.CONDITION_SATISFIED},n=i}else V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(n=this.beginQuery(),this.endQuery(),r=()=>this.isQueryAvailable(n,V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):r=()=>!0;return{query:n,isFencePassed:r}}downloadMatrixFromPackedTexture(e,n,r){return this.downloadMatrixDriver(e,()=>AM(this.gl,n,r))}createProgram(e){this.throwIfDisposed();const n=this.gl;this.vertexShader==null&&(this.vertexShader=yM(n));const r=rL(n);le(n,()=>n.attachShader(r,this.vertexShader)),le(n,()=>n.attachShader(r,e)),oL(n,r);const o=Object.assign(r,{vao:this.createVertexArray()});return this.debug&&Dd(n,o),o}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);const n=this.gl;le(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),$M(n,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&(le(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&Dd(this.gl,this.program),le(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,n,r=!0){return this.throwIfDisposed(),r?dL(this.gl,e,n):fL(this.gl,e,n)}getAttributeLocation(e,n){return this.throwIfDisposed(),le(this.gl,()=>this.gl.getAttribLocation(e,n))}getUniformLocationNoThrow(e,n){return this.throwIfDisposed(),this.gl.getUniformLocation(e,n)}setInputMatrixTexture(e,n,r){this.throwIfDisposed(),this.throwIfNoProgram(),pL(this.gl,e,n,r)}setOutputMatrixTexture(e,n,r){this.setOutputMatrixTextureDriver(e,r,n)}setOutputPackedMatrixTexture(e,n,r){this.throwIfDisposed();const[o,i]=qi(n,r);this.setOutputMatrixTextureDriver(e,o,i)}setOutputMatrixWriteRegion(e,n,r,o){this.setOutputMatrixWriteRegionDriver(r,e,o,n)}setOutputPackedMatrixWriteRegion(e,n,r,o){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&Dd(this.gl,this.program),Wu(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const n=this.getVertexArray();console.assert(n===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}le(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),le(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=Uu(this.gl,V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const r=this.gl,o=this.getQueryTimerExtensionWebGL2(),i=r.createQuery();return r.beginQuery(o.TIME_ELAPSED_EXT,i),i}const e=this.getQueryTimerExtensionWebGL1(),n=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,n),n}endQuery(){if(V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const n=this.gl,r=this.getQueryTimerExtensionWebGL2();n.endQuery(r.TIME_ELAPSED_EXT);return}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await Gg(()=>this.disposed||this.isQueryAvailable(e,V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,n){if(n===0)return null;if(n===2){const r=this.gl;return r.getQueryParameter(e,r.QUERY_RESULT)/1e6}else{const r=this.getQueryTimerExtensionWebGL1();return r.getQueryObjectEXT(e,r.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,n){if(n===0)return!0;if(n===2){const r=this.gl,o=this.getQueryTimerExtensionWebGL2(),i=r.getQueryParameter(e,r.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(o.GPU_DISJOINT_EXT)),i&&!this.disjoint}else{const r=this.getQueryTimerExtensionWebGL1(),o=r.getQueryObjectEXT(e,r.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),o&&!this.disjoint}}pollFence(e){return new Promise(n=>{this.addItemToPoll(()=>e.isFencePassed(),()=>n())})}pollItems(){const e=NM(this.itemsToPoll.map(n=>n.isDoneFn));for(let n=0;n<=e;++n){const{resolveFn:r}=this.itemsToPoll[n];r()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,n){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:n}),this.itemsToPoll.length>1)return;let r;"setTimeoutCustom"in V().platform&&(r=V().platform.setTimeoutCustom.bind(V().platform)),Gg(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,r)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),Fd(this.gl,e,this.framebuffer),this.debug&&Wu(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(Fd(this.gl,this.outputTexture,this.framebuffer),this.debug&&Wu(this.gl)):Oy(this.gl,this.framebuffer)}downloadMatrixDriver(e,n){this.bindTextureToFrameBuffer(e);const r=n();return this.unbindTextureToFrameBuffer(),r}setOutputMatrixTextureDriver(e,n,r){this.throwIfDisposed();const o=this.gl;Fd(o,e,this.framebuffer),this.debug&&Wu(o),this.outputTexture=e,le(o,()=>o.viewport(0,0,n,r)),le(o,()=>o.scissor(0,0,n,r))}setOutputMatrixWriteRegionDriver(e,n,r,o){this.throwIfDisposed(),le(this.gl,()=>this.gl.scissor(e,n,r,o))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function NM(t){let e=0;for(;e<t.length&&t[e]();++e);return e-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:OM,bincountImpl:cS,bincountReduceImpl:DM,bitwiseAndImpl:FM,castImpl:LM,ceilImpl:MM,concatImpl:BM,equalImpl:UM,expImpl:WM,expm1Impl:VM,floorImpl:zM,gatherNdImpl:GM,gatherV2Impl:HM,greaterImpl:jM,greaterEqualImpl:XM,lessImpl:qM,lessEqualImpl:KM,linSpaceImpl:YM,logImpl:QM,maxImpl:ZM,maximumImpl:JM,minimumImpl:eB,multiplyImpl:tB,negImpl:nB,notEqualImpl:rB,prodImpl:oB,raggedGatherImpl:iB,raggedRangeImpl:sB,raggedTensorToTensorImpl:aB,rangeImpl:uB,rsqrtImpl:lB,scatterImpl:cB,sigmoidImpl:dB,simpleAbsImpl:dS,sliceImpl:fB,sparseFillEmptyRowsImpl:pB,sparseReshapeImpl:hB,sparseSegmentReductionImpl:fS,sqrtImpl:mB,staticRegexReplaceImpl:gB,stridedSliceImpl:yB,stringNGramsImpl:xB,stringSplitImpl:vB,stringToHashBucketFastImpl:CB,subImpl:wB,tileImpl:SB,topKImpl:bB,transposeImpl:Gp,uniqueImpl:IB}=Ew;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pS(t,e){return["x","y","z","w","u","v"].slice(0,e).map(n=>`${t}.${n}`)}function vt(t,e){return e===1?[t]:pS(t,e)}function $B(t,e){if(t===1)return"rc";let n="";for(let r=0;r<t;r++)n+=e[r],r<t-1&&(n+=",");return n}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class RB{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=pt(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const n=vt("rc",this.rank),r=Me(this.rank),o=this.getOutOfBoundsCondition(n),i=this.getSetup(n),a=this.getOutput(n);this.userCode=`
        void main() {
          ${r} rc = getOutputCoords();

          if(${o}) {
            setOutput(vec4(0));
          } else {
            ${i}

            setOutput(vec4(${a}));
          }
        }
      `}}getSourceCoordsArr(e){const n=[];for(let r=0;r<=1;r++)for(let o=0;o<=1;o++){let i=`${r===0?"r":"rp1"}, ${o===0?"c":"cp1"}`;for(let a=2;a<this.rank;a++)i=`${e[e.length-1-a]},`+i;n.push(i)}return n}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let n="";for(let r=this.rank-2;r<this.rank;r++)n+=`${e[r]} >= ${this.enableShapeUniforms?`outShape[${r}]`:this.outputShape[r]}`,r<this.rank-1&&(n+="||");return n}getSetup(e){if(this.rank===1)return"";const n=e.slice(-2),r=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],o=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${n[0]};
      int c = ${n[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${r};
      bool rEdge = rp1 >= ${o};
    `}getOutput(e){const n=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${n[0]}),
            cEdge ? 0. : getA(${n[1]}),
            rEdge ? 0. : getA(${n[2]}),
            rEdge || cEdge ? 0. : getA(${n[3]})`}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hS{constructor(e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=pt(this.outputShape.length);let r="";for(let o=0;o<4;o++){let i="thisRC = rc;";o%2===1&&(i+="thisRC.z += 1;"),o>1&&(i+="thisRC.y += 1;"),r+=`
        ${i}
        ${o>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${o}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${o>0?"}":""}
      `}this.userCode=`
      ${EB(n,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?Vp():Wp(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${r}

        setOutput(result);
      }
    `}}function EB(t,e){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e?$L(["r","c","d"],"inputShape"):Ho(["r","c","d"],t)}
      return ivec3(r, c, d);
    }
  `}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _B{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,n,r){const o=By(n,r),i=Uy(e,o,r);i in this.freeTextures||(this.freeTextures[i]=[]),i in this.usedTextures||(this.usedTextures[i]=[]);const a=My(e,o,this.gpgpu.gl,this.gpgpu.textureConfig,r);if(this.freeTextures[i].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=a,this.log();const l=this.freeTextures[i].pop();return this.usedTextures[i].push(l),l}let u;return o===at.PACKED_2X2_FLOAT32?u=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):o===at.PACKED_2X2_FLOAT16?u=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):o===at.UNPACKED_FLOAT32?u=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):o===at.UNPACKED_FLOAT16?u=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):o===at.PACKED_4X1_UNSIGNED_BYTE&&(u=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[i].push(u),this.numUsedTextures++,this._numBytesAllocated+=a,this.log(),u}releaseTexture(e,n,r,o){if(this.freeTextures==null)return;const i=By(r,o),a=Uy(n,i,o);a in this.freeTextures||(this.freeTextures[a]=[]);const u=My(n,i,this.gpgpu.gl,this.gpgpu.textureConfig,o),l=V().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");l!==-1&&this._numBytesAllocated>l?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=u):(this.freeTextures[a].push(e),this.numFreeTextures++,this._numBytesFree+=u),this.numUsedTextures--;const d=this.usedTextures[a],f=d&&d.indexOf(e);if(f==null||f<0)throw new Error("Cannot release a texture that was never provided by this texture manager");d[f]=d[d.length-1],d.pop(),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const n=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*n)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const e in this.freeTextures)this.freeTextures[e].forEach(n=>{this.gpgpu.deleteMatrixTexture(n.texture)});for(const e in this.usedTextures)this.usedTextures[e].forEach(n=>{this.gpgpu.deleteMatrixTexture(n.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function PB(t,e){const n=t;if(e===n.R32F)return 4;if(e===n.R16F)return 2;if(e===n.RGBA32F)return 16;if(e===t.RGBA)return 16;if(e===n.RGBA16F)return 8;if(e===n.RGBA8)return 4;throw new Error(`Unknown internal format ${e}`)}function My(t,e,n,r,o){const i=kB(e,r);let a;if(o){const[l,d]=qi(t[0],t[1]);a=l*d}else{const[l,d]=ka(t[0],t[1]);a=l*d}const u=PB(n,i);return a*u}function kB(t,e){switch(t){case at.PACKED_2X2_FLOAT32:return uS(e);case at.PACKED_2X2_FLOAT16:return lS(e);case at.UNPACKED_FLOAT32:return iS(e);case at.UNPACKED_FLOAT16:return sS(e);case at.PACKED_4X1_UNSIGNED_BYTE:return aS(e);default:throw new Error(`Unknown physical texture type ${t}`)}}function TB(t){return V().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?t?at.PACKED_2X2_FLOAT32:at.UNPACKED_FLOAT32:t?at.PACKED_2X2_FLOAT16:at.UNPACKED_FLOAT16}function By(t,e){if(t===zt.UPLOAD)return at.PACKED_2X2_FLOAT32;if(t===zt.RENDER||t==null)return TB(e);if(t===zt.DOWNLOAD||t===zt.PIXELS)return at.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${t}`)}function Uy(t,e,n){return`${t[0]}_${t[1]}_${e}_${n}`}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class An{constructor(e,n){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=pt(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${n}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}const nn="if (isnan(x)) return x;",AB="return x;",Wy="return abs(x);",NB="return (x >= 0.0) ? x : (exp(x) - 1.0);",OB=nn+`
  return (x < 0.0) ? 0.0 : x;
`,DB=nn+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,_r="return x;",FB="return 1.0 / (1.0 + exp(-1.0 * x));";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LB="return x;",MB=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,BB=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,UB=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,WB="return 1.0 / (1.0 + exp(-1.0 * x));";class kr{constructor(e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=pt(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${n}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class VB{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=pt(this.outputShape.length);const n=e.length,r=vt("rc",n),o=Me(n),i=$B(n,r),a=r.slice(-2),u=n<=1?"rc":`vec2(${a.join(",")})`;this.userCode=`
      void main() {
        ${o} rc = getOutputCoords();
        vec4 packedInput = getA(${i});

        setOutput(getChannel(packedInput, ${u}));
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zB=vR,GB=1e-7,HB=1e-4,Gu={};function jB(t){return t in Gu||(Gu[t]={}),Gu[t]}const XB=V().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),qB=600;function KB(){return V().global.screen==null?1024:V().global.screen.height*V().global.screen.width*window.devicePixelRatio*qB/1024/1024}class Pl extends Pf{nextDataId(){return Pl.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!V().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let n;if(e!=null){if(e instanceof Bd)n=e;else{const r=xn(V().getNumber("WEBGL_VERSION"),e);n=new Bd(r)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const r=xn(V().getNumber("WEBGL_VERSION"));n=new Bd(r),this.binaryCache=jB(V().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=n,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new _B(this.gpgpu),this.numMBBeforeWarning=KB(),this.texData=new Lv(this,fn())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,n,r,o,i,a){const u=this.makeTensorInfo(n,r),l=this.texData.get(u.dataId);l.isPacked=!1,l.texture={texture:e,texShape:[o,i]},l.texShape=[o,i];const d=Vu(n),f=new Ly(d,!1,a),p=this.runWebGLProgram(f,[u],r,[[o,i]]);return p.shape=n,l.texture=null,this.disposeIntermediateTensorInfo(u),p.dataId}write(e,n,r){if((V().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||V().getBool("DEBUG"))&&this.checkNumericalProblems(e),r==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const o={id:this.nextDataId()};return this.texData.set(o,{shape:n,dtype:r,values:e,usage:zt.UPLOAD,refCount:1}),o}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){const n=this.texData.get(e);n.refCount++}decRef(e){if(this.texData.has(e)){const n=this.texData.get(e);n.refCount--}}move(e,n,r,o,i){if(V().getBool("DEBUG")&&this.checkNumericalProblems(n),o==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:r,dtype:o,values:n,usage:zt.UPLOAD,refCount:i})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const n=this.texData.get(e),{values:r,dtype:o,complexTensorInfos:i,slice:a,shape:u,isPacked:l}=n;if(a!=null){let h;l?h=new kr(u,_r):h=new An(u,_r);const g=this.runWebGLProgram(h,[{dataId:e,shape:u,dtype:o}],o),y=this.readSync(g.dataId);return this.disposeIntermediateTensorInfo(g),y}if(r!=null)return this.convertAndCacheOnCPU(e);if(o==="string")return r;const d=this.activeTimers!=null;let f;d&&(f=pn());let p;if(o==="complex64"){const h=this.readSync(i.real.dataId),g=this.readSync(i.imag.dataId);p=ha(h,g)}else p=this.getValuesFromTexture(e);return d&&(this.downloadWaitMs+=pn()-f),this.convertAndCacheOnCPU(e,p)}async read(e){if(this.pendingRead.has(e)){const y=this.pendingRead.get(e);return new Promise(x=>y.push(x))}const n=this.texData.get(e),{values:r,shape:o,slice:i,dtype:a,complexTensorInfos:u,isPacked:l}=n;if(i!=null){let y;l?y=new kr(o,_r):y=new An(o,_r);const x=this.runWebGLProgram(y,[{dataId:e,shape:o,dtype:a}],a),v=this.read(x.dataId);return this.disposeIntermediateTensorInfo(x),v}if(r!=null)return this.convertAndCacheOnCPU(e);if(V().getBool("DEBUG")&&!V().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&V().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let d=null,f;if(a!=="complex64"&&V().get("WEBGL_BUFFER_SUPPORTED")){f=this.decode(e);const y=this.texData.get(f.dataId);d=this.gpgpu.createBufferFromTexture(y.texture.texture,...Bu(o))}this.pendingRead.set(e,[]),a!=="complex64"&&await this.gpgpu.createAndWaitForFence();let p;if(a==="complex64"){const y=await Promise.all([this.read(u.real.dataId),this.read(u.imag.dataId)]),x=y[0],v=y[1];p=ha(x,v)}else if(d==null)p=this.getValuesFromTexture(e);else{const y=Y(o);p=this.gpgpu.downloadFloat32MatrixFromBuffer(d,y)}if(f!=null&&this.disposeIntermediateTensorInfo(f),d!=null){const y=this.gpgpu.gl;le(y,()=>y.deleteBuffer(d))}const h=this.convertAndCacheOnCPU(e,p),g=this.pendingRead.get(e);return this.pendingRead.delete(e),g.forEach(y=>y(h)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&fn().removeDataId(e,this),this.pendingDeletes--),h}readToGPU(e,n={}){const r=this.texData.get(e),{values:o,shape:i,slice:a,dtype:u,isPacked:l,texture:d}=r;if(u==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(a!=null){let g;l?g=new kr(i,_r):g=new An(i,_r);const y=this.runWebGLProgram(g,[{dataId:e,shape:i,dtype:u}],u),x=this.readToGPU(y,n);return this.disposeIntermediateTensorInfo(y),x}if(d==null)throw o!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const f=this.decode(e,n.customTexShape),p=fn().makeTensorFromTensorInfo(f),h=this.texData.get(f.dataId);return Object.assign({tensorRef:p},h.texture)}bufferSync(e){const n=this.readSync(e.dataId);if(e.dtype==="string")try{const r=n.map(o=>Yn(o));return Xe(e.shape,e.dtype,r)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Xe(e.shape,e.dtype,n)}checkNumericalProblems(e){if(e!=null)for(let n=0;n<e.length;n++){const r=e[n];if(!ZF(r))throw V().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${r} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${r} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:n,dtype:r,isPacked:o}=this.texData.get(e),i=Y(n);if(V().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const h=this.decode(e),g=this.texData.get(h.dataId),y=this.gpgpu.downloadMatrixFromPackedTexture(g.texture.texture,...Bu(n)).subarray(0,i);return this.disposeIntermediateTensorInfo(h),y}const a=V().getBool("WEBGL_PACK")&&o===!0,u=a?Vu(n):n,l=a?new hM(u):new pM(u),d=this.runWebGLProgram(l,[{shape:u,dtype:r,dataId:e}],"float32"),f=this.texData.get(d.dataId),p=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(f.texture.texture,f.texShape[0],f.texShape[1]).subarray(0,i);return this.disposeIntermediateTensorInfo(d),p}timerAvailable(){return V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const n=this.activeTimers,r=[];let o=!1;this.programTimersStack==null?(this.programTimersStack=r,o=!0):this.activeTimers.push(r),this.activeTimers=r,e();const i=Qn(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),a=Qn(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=n,o&&(this.programTimersStack=null);const u={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const l=await Promise.all(i);u.kernelMs=Mv(l),u.getExtraProfileInfo=()=>l.map((d,f)=>({name:a[f],ms:d})).map(d=>`${d.name}: ${d.ms}`).join(", ")}else u.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,u})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:pn(),endMs:null}}endTimer(e){return V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=pn(),e)}async getQueryTime(e){if(V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const n=e;return n.endMs-n.startMs}disposeData(e,n=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(n?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!n&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:r}=this.texData.get(e);return r!=null&&(this.disposeData(r.real.dataId,n),this.disposeData(r.imag.dataId,n)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:n,dtype:r,texShape:o,usage:i,isPacked:a,slice:u}=this.texData.get(e),l=u&&u.origDataId||e,d=this.dataRefCount.get(l);d>1?this.dataRefCount.set(l,d-1):(this.dataRefCount.delete(l),n!=null&&(this.numBytesInGPU-=this.computeBytes(o,r),this.textureManager.releaseTexture(n,o,i,a)));const f=this.texData.get(e);f.texture=null,f.texShape=null,f.isPacked=!1,f.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,n=XB){return V().getBool("WEBGL_CPU_FORWARD")&&e.every(r=>this.texData.get(r.dataId).texture==null&&Y(r.shape)<n)}getGPGPUContext(){return this.gpgpu}where(e){yn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const n=e.dataSync();return zB(e.shape,n)}packedUnaryOp(e,n,r){const o=new kr(e.shape,n),i=this.compileAndRun(o,[e],r);return fn().makeTensorFromTensorInfo(i)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){const o=dS(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,o)}if(V().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,Wy,e.dtype);const n=new An(e.shape,Wy),r=this.compileAndRun(n,[e]);return fn().makeTensorFromTensorInfo(r)}makeTensorInfo(e,n,r){let o;if(n==="string"&&r!=null&&r.length>0&&wa(r[0])){const i=r.map(a=>Ar(a));o=this.write(i,e,n)}else o=this.write(r,e,n);return this.texData.get(o).usage=null,{dataId:o,shape:e,dtype:n}}makeOutput(e,n,r){return fn().makeTensorFromTensorInfo(this.makeTensorInfo(e,n,r),this)}unpackTensor(e){const n=new VB(e.shape);return this.runWebGLProgram(n,[e],e.dtype)}packTensor(e){const n=new RB(e.shape);return this.runWebGLProgram(n,[e],e.dtype,null,!0)}packedReshape(e,n){const r=[Vi(e.shape),...zi(e.shape)],o={dtype:e.dtype,shape:r,dataId:e.dataId},i=[Vi(n),...zi(n)],a=new hS(i,r),u=!0,l=[r],d=this.runWebGLProgram(a,[o],e.dtype,l,u);return{dataId:d.dataId,shape:n,dtype:d.dtype}}decode(e,n){const r=this.texData.get(e),{isPacked:o,shape:i,dtype:a}=r;if(n!=null){const h=Y(i),g=n[0]*n[1]*4;re(h<=g,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const u=Vu(i);let l;o?l=new fM(u):l=new dM(u);const d=!0,f=[n??Bu(u)],p=this.runWebGLProgram(l,[{shape:u,dtype:a,dataId:e}],a,f,d,n);return{dtype:a,shape:i,dataId:p.dataId}}runWebGLProgram(e,n,r,o,i=!1,a){const u=this.makeTensorInfo(e.outputShape,r),l=this.texData.get(u.dataId);if(e.packedOutput&&(l.isPacked=!0),e.outPackingScheme===ya.DENSE){const w=a??Bu(e.outputShape);l.texShape=w.map(S=>S*2)}if(e.outTexUsage!=null&&(l.usage=e.outTexUsage),Y(u.shape)===0)return l.values=qn(u.dtype,0),u;const d=[],f=n.map(w=>{if(w.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let S=this.texData.get(w.dataId);if(S.texture==null){if(!e.packedInputs&&Y(w.shape)<=V().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:w.shape,texData:null,isUniform:!0,uniformValues:S.values};e.packedInputs&&(S.isPacked=!0,S.shape=w.shape)}if(this.uploadToGPU(w.dataId),!!S.isPacked!=!!e.packedInputs)w=S.isPacked?this.unpackTensor(w):this.packTensor(w),d.push(w),S=this.texData.get(w.dataId);else if(S.isPacked&&!fl(S.shape,w.shape)){const I=w,E=w.shape;w.shape=S.shape,w=this.packedReshape(w,E),d.push(w),S=this.texData.get(w.dataId),I.shape=E}return{shape:w.shape,texData:S,isUniform:!1}});this.uploadToGPU(u.dataId);const p={shape:u.shape,texData:l,isUniform:!1},h=cM(e,f,p),g=this.getAndSaveBinary(h,()=>uM(this.gpgpu,e,f,p)),y=this.activeTimers!=null;let x;y&&(x=this.startTimer()),V().get("ENGINE_COMPILE_ONLY")||lM(this.gpgpu,g,f,p,o),d.forEach(w=>this.disposeIntermediateTensorInfo(w)),y&&(x=this.endTimer(x),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(x)}));const v=V().getNumber("WEBGL_FLUSH_THRESHOLD");if(v>0){const w=pn();w-this.lastGlFlushTime>v&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=w)}if(!V().getBool("WEBGL_LAZILY_UNPACK")&&l.isPacked&&i===!1){const w=this.unpackTensor(u);return this.disposeIntermediateTensorInfo(u),w}return u}compileAndRun(e,n,r,o,i=!1){return r=r||n[0].dtype,this.runWebGLProgram(e,n,r,o,i)}getAndSaveBinary(e,n){return e in this.binaryCache||(this.binaryCache[e]=n()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(V().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(n=>{this.gpgpu.deleteProgram(this.binaryCache[n].webGLProgram),delete this.binaryCache[n]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=tt(()=>{if(!V().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=V().getBool("DEBUG");V().set("DEBUG",!1);const n=this.abs(Nr(1e-8)).dataSync()[0];if(V().set("DEBUG",e),n>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?GB:HB}uploadToGPU(e){const n=this.texData.get(e),{shape:r,dtype:o,values:i,texture:a,usage:u,isPacked:l}=n;if(a!=null)return;const d=this.activeTimers!=null;let f;d&&(f=pn());let p=n.texShape;if(p==null&&(p=gL(r,l),n.texShape=p),i!=null){const h=Vu(r);let g,y=p[1],x=p[0];const v=i instanceof Uint8Array||i instanceof Uint8ClampedArray;(l||!v)&&([y,x]=qi(p[0],p[1])),l?g=new gM(h,v):g=new Ly(h,v);const w=v?[x,y]:p,S=this.makeTensorInfo(w,o),I=this.texData.get(S.dataId);v?I.usage=zt.PIXELS:I.usage=zt.UPLOAD,I.texShape=w,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(S.dataId),y,x,i);const E=[[x,y]],T=this.runWebGLProgram(g,[S],o,E,!0),k=this.texData.get(T.dataId);n.texShape=k.texShape,n.isPacked=k.isPacked,n.usage=k.usage,V().get("ENGINE_COMPILE_ONLY")?this.disposeData(T.dataId):(n.texture=k.texture,n.values=null,this.texData.delete(T.dataId)),this.disposeIntermediateTensorInfo(S),d&&(this.uploadWaitMs+=pn()-f)}else{const h=this.acquireTexture(p,u,o,l);n.texture=h}}convertAndCacheOnCPU(e,n){const r=this.texData.get(e),{dtype:o}=r;return n!=null&&(r.values=YB(n,o)),r.values}acquireTexture(e,n,r,o){if(this.numBytesInGPU+=this.computeBytes(e,r),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const i=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${i} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,n,o)}computeBytes(e,n){return e[0]*e[1]*nl(n)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,n]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(n));return Promise.all(e)}else{for(const[,n]of Object.entries(this.binaryCache)){const r=new Promise(o=>{try{this.checkCompletion_(n),o(!0)}catch(i){throw i}});e.push(r)}return Promise.all(e)}}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await KR(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(Jw(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:n,customUniformLocations:r,infLoc:o,nanLoc:i,outShapeLocation:a,outShapeStridesLocation:u,outTexShapeLocation:l}=oS(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=n,e.customUniformLocations=r,e.infLoc=o,e.nanLoc=i,e.outShapeLocation=a,e.outShapeStridesLocation=u,e.outTexShapeLocation=l}}createTensorFromGPUData(e,n,r){e.channels=e.channels||"RGBA";const{texture:o,height:i,width:a,channels:u}=e,l=fn().backend;if(!l.gpgpu.gl.isTexture(o))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const d=l.writeTexture(o,n,r,i,a,u);return fn().makeTensorFromDataId(d,n,r,l)}}Pl.nextDataId=0;function YB(t,e){if(e==="float32"||e==="complex64")return t;if(e==="int32"||e==="bool"){const n=e==="int32"?new Int32Array(t.length):new Uint8Array(t.length);for(let r=0;r<n.length;++r)n[r]=Math.round(t[r]);return n}else throw new Error(`Unknown dtype ${e}`)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */T0()&&N0("webgl",()=>new Pl,2);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hp=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;class Lo{constructor(e,n,r){this.variableNames=["A","B"],this.outputShape=He(n,r),this.enableShapeUniforms=pt(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xo=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class Ji{constructor(e,n,r,o=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=He(n,r);const i=this.outputShape.length;this.enableShapeUniforms=pt(i);let a="";if(o)if(i===0||Y(this.outputShape)===1)a=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(a=`
          ${Me(i)} coords = getOutputCoords();
        `,i===1)this.enableShapeUniforms?a+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:a+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const l=vt("coords",i);this.enableShapeUniforms?a+=`
            bool nextRowOutOfBounds =
              (${l[i-2]} + 1) >= outShape[${i} - 2];
            bool nextColOutOfBounds =
              (${l[i-1]} + 1) >= outShape[${i} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:a+=`
            bool nextRowOutOfBounds =
              (${l[i-2]} + 1) >= ${this.outputShape[i-2]};
            bool nextColOutOfBounds =
              (${l[i-1]} + 1) >= ${this.outputShape[i-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${a}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dt(t){const{inputs:e,backend:n}=t,{x:r}=e;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const QB={kernelName:xl,backendName:"webgl",kernelFunc:Dt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mr(t){const{inputs:e,backend:n}=t,{real:r,imag:o}=e,i=n.makeTensorInfo(r.shape,"complex64"),a=n.texData.get(i.dataId),u=Dt({inputs:{x:r},backend:n}),l=Dt({inputs:{x:o},backend:n});return a.complexTensorInfos={real:u,imag:l},i}const ZB={kernelName:Ff,backendName:"webgl",kernelFunc:Mr};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mS="return (a < 0.) ? b * a : a;",gS=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function JB(t){const{inputs:e,backend:n,attrs:r}=t,{x:o}=e,{alpha:i}=r,a=n.makeTensorInfo([],"float32",Hi(i,"float32")),u=V().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Ji(gS,o.shape,a.shape):new Lo(mS,o.shape,a.shape),l=n.runWebGLProgram(u,[o,a],"float32");return n.disposeIntermediateTensorInfo(a),l}const eU={kernelName:Vf,backendName:"webgl",kernelFunc:JB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yS="return (a < 0.) ? b * a : a;",xS=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function tU(t){const{inputs:e,backend:n}=t,{x:r,alpha:o}=e,i=V().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Ji(xS,r.shape,o.shape):new Lo(yS,r.shape,o.shape);return n.runWebGLProgram(i,[r,o],"float32")}const nU={kernelName:jf,backendName:"webgl",kernelFunc:tU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const es="if (isnan(x)) return x;";function Ae({opSnippet:t,packedOpSnippet:e,cpuKernelImpl:n,dtype:r}){return({inputs:o,backend:i})=>{const{x:a}=o,u=i,l=r||a.dtype;if(u.shouldExecuteOnCPU([a])&&n!=null){const p=u.texData.get(a.dataId),h=n(p.values,l);return u.makeTensorInfo(a.shape,l,h)}const d=V().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&e!=null;let f;return d?f=new kr(a.shape,e):f=new An(a.shape,t),u.runWebGLProgram(f,[a],l)}}function ut({opSnippet:t,packedOpSnippet:e,checkOutOfBounds:n=!1,supportsComplex:r=!1,cpuKernelImpl:o,dtype:i}){return({inputs:a,backend:u})=>{const{a:l,b:d}=a,f=u;if(r&&l.dtype==="complex64"){const y=f.texData.get(l.dataId),x=f.texData.get(d.dataId),[v,w]=[[y.complexTensorInfos.real,x.complexTensorInfos.real],[y.complexTensorInfos.imag,x.complexTensorInfos.imag]].map(I=>{const[E,R]=I,T={dataId:E.dataId,dtype:E.dtype,shape:l.shape},k={dataId:R.dataId,dtype:R.dtype,shape:d.shape},D=new Lo(t,l.shape,d.shape);return f.runWebGLProgram(D,[T,k],Rt(E.dtype,R.dtype))}),S=Mr({inputs:{real:v,imag:w},backend:f});return f.disposeIntermediateTensorInfo(v),f.disposeIntermediateTensorInfo(w),S}const p=i||Rt(l.dtype,d.dtype);if((l.dtype==="string"||d.dtype==="string"||f.shouldExecuteOnCPU([l,d]))&&o!=null){const y=f.texData.get(l.dataId).values,x=f.texData.get(d.dataId).values,v=l.dtype==="string"?Or(y):y,w=l.dtype==="string"?Or(x):x,[S,I]=o(l.shape,d.shape,v,w,p),E=f.makeTensorInfo(I,p),R=f.texData.get(E.dataId);return R.values=S,E}const h=V().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&e!=null;let g;return h?g=new Ji(e,l.shape,d.shape,n):g=new Lo(t,l.shape,d.shape),f.runWebGLProgram(g,[l,d],p)}}function xa(t,e=!1){if(t==="linear")return e?LB:AB;if(t==="relu")return e?BB:OB;if(t==="elu")return e?MB:NB;if(t==="relu6")return e?UB:DB;if(t==="prelu")return e?xS:yS;if(t==="leakyrelu")return e?gS:mS;if(t==="sigmoid")return e?WB:FB;throw new Error(`Activation ${t} has not been implemented for the WebGL backend.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vS{constructor(e,n,r,o=!1,i=!1,a=!1,u=null,l=!1,d=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=r,this.enableShapeUniforms=pt(this.outputShape.length);const f=o?e[1]:e[2],p=Math.ceil(f/2),h=o?"i * 2, rc.y":"rc.y, i * 2",g=i?"rc.z, i * 2":"i * 2, rc.z",y=o?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],x=i?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let v="",w="";u&&(l?v=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${u}
        }`:d?v=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${u}
        }`:v=`vec4 activation(vec4 x) {
          ${u}
        }`,w="result = activation(result);");const S=a?"result += getBiasAtOutCoords();":"";a&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),d&&this.variableNames.push("leakyreluAlpha");let I="rc.x",E="rc.x";e[0]<n[0]?I=`imod(rc.x, ${e[0]})`:n[0]<e[0]&&(E=`imod(rc.x, ${n[0]})`),this.userCode=`
      ${v}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${p}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${I};
        int batchB = ${E};
        for (int i = 0; i < ${p}; i++) {
          vec4 a = getMatrixA(batchA, ${h});
          vec4 b = getMatrixB(batchB, ${g});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${y[0]} * ${x[0]});
          result += (${y[1]} * ${x[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${S}

        ${w}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vy={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class zy{constructor(e,n,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=He(n,r),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gy="return a * b;";function jp(t){const{inputs:e,backend:n}=t,{a:r,b:o}=e,i=Rt(r.dtype,o.dtype);if(r.dtype==="complex64"){const u=n.texData.get(r.dataId),l=n.texData.get(o.dataId),d=new zy(Vy.REAL,r.shape,o.shape),f=new zy(Vy.IMAG,r.shape,o.shape),p=[{dataId:u.complexTensorInfos.real.dataId,dtype:u.complexTensorInfos.real.dtype,shape:r.shape},{dataId:u.complexTensorInfos.imag.dataId,dtype:u.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:o.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:o.shape}],h=n.runWebGLProgram(d,p,"float32"),g=n.runWebGLProgram(f,p,"float32"),y=Mr({inputs:{real:h,imag:g},backend:n});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(g),y}if(n.shouldExecuteOnCPU([r,o])){const u=n.texData.get(r.dataId),l=n.texData.get(o.dataId),[d,f]=tB(r.shape,o.shape,u.values,l.values,i),p=n.makeTensorInfo(f,i),h=n.texData.get(p.dataId);return h.values=d,p}let a;return V().getBool("WEBGL_PACK_BINARY_OPERATIONS")?a=new Ji(Gy,r.shape,o.shape):a=new Lo(Gy,r.shape,o.shape),n.runWebGLProgram(a,[r,o],i)}const rU={kernelName:Gf,backendName:"webgl",kernelFunc:jp};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oU(t,e,n){const r=[Vi(t.shape),...zi(t.shape)],o={dtype:t.dtype,shape:r,dataId:t.dataId},i=[Vi(e),...zi(e)],a=new hS(i,r),u=!0,l=[r],d=n.runWebGLProgram(a,[o],t.dtype,l,u);return{dataId:d.dataId,shape:e,dtype:d.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ue(t){const{inputs:e,backend:n,attrs:r}=t,{x:o}=e,{shape:i}=r,a=n,u=Y(o.shape),l=Bv(i,u),d=Y(l);re(u===d,()=>`The new shape (${l}) has ${d} elements and the old shape (${o.shape}) has ${u} elements. The new shape and old shape must have the same number of elements.`);const f=a.texData.get(o.dataId);return f.isPacked&&!fl(o.shape,l)&&!(f.texture!==null&&fl(f.shape,l))?oU(o,l,a):(a.incRef(o.dataId),{dataId:o.dataId,shape:l,dtype:o.dtype})}const iU={kernelName:qf,backendName:"webgl",kernelFunc:ue};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Hy{constructor(e,n){this.variableNames=["x"];const{windowSize:r,batchSize:o,inSize:i,outSize:a}=e;this.outputShape=[o,a];const u=Math.floor(r/4)*4,l=r%4;let d="sumValue += dot(values, ones);";if(n!=null){const p=1/n;d=`sumValue += dot(values * ${tl(p)?p.toPrecision(2):p}, ones);`}let f="";i%r>0&&(f=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${f}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        float sumValue = 0.0;

        for (int i = 0; i < ${u}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${d}
        }

        int inIdx = inOffset + ${u};
        if (${l===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${d}
        } else if (${l===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${d}
        } else if (${l===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${d}
        }
        setOutput(sumValue);
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sU{constructor(e,n){this.variableNames=["x"];const{windowSize:r,batchSize:o,inSize:i,outSize:a}=e;this.outputShape=[o,a];let u="0.0",l="";n==="prod"?u="1.0":n==="min"?(u="1.0 / 1e-20",l="min"):n==="max"&&(u="-1.0 / 1e-20",l="max");let d=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;n==="sum"?d="sumValue":n==="prod"?d="prodValue":n==="all"?d="allValue":n==="any"&&(d="anyValue");const f=Math.floor(r/4)*4,p=r%4;let h=`
      if (${n==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${n==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${l}(values, minMaxValue);
        if (${n==="min"} || ${n==="max"}) {
          minMaxValue = ${l}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,g="vec4";n==="all"?(u="1.0",h=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,g="bvec4"):n==="any"&&(u="0.0",h=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,g="bvec4");let y="";i%r>0&&(y=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${u};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${y}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        vec4 minMaxValue = vec4(${u});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${f}; i += 4) {
          int inIdx = inOffset + i;
          ${g} values = ${g}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${h}
        }

        int inIdx = inOffset + ${f};
        if (${p===1}) {
          ${g} values = ${g}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${h}
        } else if (${p===2}) {
          ${g} values = ${g}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${h}
        } else if (${p===3}) {
          ${g} values = ${g}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${h}
        }
        setOutput(${d});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aU(t){const e=[];for(;e.length===0||e[e.length-1].outSize!==1;){const n=e.length?e[e.length-1].outSize:t[1],r=Sl(n);e.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return e}function qo(t,e,n,r){const o=aU(t.shape);let i=t;for(let a=0;a<o.length;a++){const{inSize:u,windowSize:l,outSize:d}=o[a];let f,p;n==="mean"?f=a===0?new Hy({windowSize:l,inSize:u,batchSize:t.shape[0],outSize:d},u):new Hy({windowSize:l,inSize:u,batchSize:t.shape[0],outSize:d}):f=new sU({windowSize:l,inSize:u,batchSize:t.shape[0],outSize:d},n),p=i,i=r.runWebGLProgram(f,[i],e),p.dataId!==t.dataId&&r.disposeIntermediateTensorInfo(p)}return i}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class uU{constructor(e,n){this.variableNames=["A"];const r=new Array(e.length);for(let a=0;a<r.length;a++)r[a]=e[n[a]];this.outputShape=r,this.rank=r.length;const o=Me(this.rank),i=lU(n);this.userCode=`
    void main() {
      ${o} resRC = getOutputCoords();
      setOutput(getA(${i}));
    }
    `}}function lU(t){const e=t.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(e);for(let o=0;o<t.length;o++)r[t[o]]=n[o];return r.join()}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cU{constructor(e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const r=new Array(e.length);for(let f=0;f<r.length;f++)r[f]=e[n[f]];if(this.outputShape=r,this.rank=r.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const o=Me(this.rank),i=pS("rc",this.rank),a=new Array(this.rank);for(let f=0;f<n.length;f++)a[n[f]]=i[f];const u=`vec2(${a.slice(-2).join()})`,l=`++${i[this.rank-1]} < ${r[this.rank-1]}`,d=`getChannel(getA(${a.join()}), ${u})`;this.userCode=`
    void main() {
      ${o} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${d};
      if(${l}) {
        result[1] = ${d};
      }
      --${i[this.rank-1]};
      if(++${i[this.rank-2]} < ${r[this.rank-2]}) {
        result[2] = ${d};
        if(${l}) {
          result[3] = ${d};
        }
      }
      setOutput(result);
    }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kl(t,e,n){const r=V().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new cU(t.shape,e):new uU(t.shape,e);return n.runWebGLProgram(r,[t],t.dtype)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dU(t,e,n,r){const o=e,i=t.shape.length,a=Je(o,t.shape);let u=a;const l=dt(u,i),d=l!=null;let f=t;d&&(f=kl(t,l,r),u=ft(u.length,i)),Ft("sum",u,i);const[p,h]=Ht(f.shape,u);let g=p;n&&(g=Fn(p,a));const y=Y(h),v=Y(t.shape)/y,w=ue({inputs:{x:f},attrs:{shape:[v,y]},backend:r}),S=wl(t.dtype),I=qo(w,S,"sum",r),E=ue({inputs:{x:I},attrs:{shape:g},backend:r});return r.disposeIntermediateTensorInfo(w),r.disposeIntermediateTensorInfo(I),d&&r.disposeIntermediateTensorInfo(f),E}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tl(t){const{inputs:e,backend:n,attrs:r}=t,{x:o}=e,{axis:i,keepDims:a}=r;return dU(o,i,a,n)}const fU={kernelName:Zf,backendName:"webgl",kernelFunc:Tl};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ct(t){const{inputs:e,backend:n,attrs:r}=t,{x:o}=e,{perm:i}=r,a=n,u=o.shape.length,l=new Array(u);for(let f=0;f<l.length;f++)l[f]=o.shape[i[f]];let d;if(a.shouldExecuteOnCPU([o])){const p=a.texData.get(o.dataId).values,h=Gp(p,o.shape,o.dtype,i,l);d=a.makeTensorInfo(l,o.dtype);const g=a.texData.get(d.dataId);g.values=h}else d=kl(o,i,a);return d}const pU={kernelName:u0,backendName:"webgl",kernelFunc:Ct};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CS=1e3;function pl({a:t,b:e,transposeA:n,transposeB:r,backend:o,bias:i=null,preluActivationWeights:a=null,leakyreluAlpha:u=0,activation:l=null}){const d=t.shape.length,f=e.shape.length,p=n?t.shape[d-2]:t.shape[d-1],h=r?e.shape[f-1]:e.shape[f-2],g=n?t.shape[d-1]:t.shape[d-2],y=r?e.shape[f-2]:e.shape[f-1],x=t.shape.slice(0,-2),v=e.shape.slice(0,-2),w=Y(x),S=Y(v),E=He(t.shape.slice(0,-2),e.shape.slice(0,-2)).concat([g,y]);re(p===h,()=>`Error in matMul: inner shapes (${p}) and (${h}) of Tensors with shapes ${t.shape} and ${e.shape} and transposeA=${n} and transposeB=${r} must match.`);const R=n?[w,p,g]:[w,g,p],T=r?[S,y,h]:[S,h,y],k=ue({inputs:{x:t},backend:o,attrs:{shape:R}}),D=ue({inputs:{x:e},backend:o,attrs:{shape:T}}),N=[k,D],O=Math.max(w,S),_=n?k.shape[1]:k.shape[2],F=i!=null,U=a!=null,G=l==="leakyrelu",j=l!=null?xa(l,!0):null,Z=F||U||G||j!=null;let L;if((g===1||y===1)&&_>CS&&Z===!1){let ne=k,Q=D;n&&(ne=Ct({inputs:{x:k},backend:o,attrs:{perm:[0,2,1]}}),N.push(ne)),r&&(Q=Ct({inputs:{x:D},backend:o,attrs:{perm:[0,2,1]}}),N.push(Q));const H=y!==1,K=y===1;let J=ne;H&&(J=ue({inputs:{x:ne},backend:o,attrs:{shape:[O,_,1]}}),N.push(J));const ge=y===1?2:1;let ve=Q;K&&(ve=ue({inputs:{x:Q},backend:o,attrs:{shape:[O,1,_]}}),N.push(ve));const We=jp({inputs:{a:J,b:ve},backend:o});L=Tl({inputs:{x:We},backend:o,attrs:{axis:ge,keepDims:!0}}),N.push(We)}else{const ne=Rt(t.dtype,e.dtype),Q=new vS(R,T,[O,g,y],n,r,F,j,U,G),H=[k,D];if(i!=null&&H.push(i),U&&H.push(a),G){const K=o.makeTensorInfo([],"float32",Hi(u,"float32"));H.push(K),N.push(K)}L=o.runWebGLProgram(Q,H,ne)}const X=ue({inputs:{x:L},backend:o,attrs:{shape:E}});N.push(L);for(const ne of N)o.disposeIntermediateTensorInfo(ne);return X}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hU(t){const{inputs:e,backend:n,attrs:r}=t,{a:o,b:i,bias:a,preluActivationWeights:u}=e,{transposeA:l,transposeB:d,activation:f,leakyreluAlpha:p}=r;return pl({a:o,b:i,transposeA:l,transposeB:d,backend:n,bias:a,preluActivationWeights:u,leakyreluAlpha:p,activation:f})}const mU={kernelName:p0,backendName:"webgl",kernelFunc:hU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jy="return abs(x);";function gU(t){const{inputs:e,backend:n}=t,{x:r}=e;if(n.shouldExecuteOnCPU([r])&&r.dtype!=="complex64"){const i=n.texData.get(r.dataId),a=dS(i.values);return n.makeTensorInfo(r.shape,r.dtype,a)}let o;return V().getBool("WEBGL_PACK_UNARY_OPERATIONS")?o=new kr(r.shape,jy):o=new An(r.shape,jy),n.runWebGLProgram(o,[r],r.dtype)}const yU={kernelName:Df,backendName:"webgl",kernelFunc:gU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xU=nn+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,vU=Ae({opSnippet:xU}),CU={kernelName:Gv,backendName:"webgl",kernelFunc:vU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wU=nn+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,SU=Ae({opSnippet:wU}),bU={kernelName:Hv,backendName:"webgl",kernelFunc:SU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xy="return a + b;",IU=ut({opSnippet:Xy,packedOpSnippet:Xy,supportsComplex:!0,cpuKernelImpl:OM}),$U={kernelName:gl,backendName:"webgl",kernelFunc:IU};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class RU{constructor(e,n){this.outputShape=[],this.outputShape=e,this.variableNames=n.map((i,a)=>`T${a}`);const r=[];this.variableNames.forEach(i=>{r.push(`float v${i} = get${i}AtOutCoords();`)});const o=this.variableNames.map(i=>`v${i}`).join(" + ");this.userCode=`
      void main() {
        ${r.join(`
        `)}

        float result = ${o};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class EU{constructor(e,n){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=n.map((i,a)=>`T${a}`);const r=[];this.variableNames.forEach(i=>{r.push(`vec4 v${i} = get${i}AtOutCoords();`)});const o=this.variableNames.map(i=>`v${i}`).join(" + ");this.userCode=`
      void main() {
        ${r.join(`
        `)}

        vec4 result = ${o};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ju(t){const{inputs:e,backend:n}=t,r=e;if(r.length===1)return Dt({inputs:{x:r[0]},backend:n});if(r.length>V().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const l=Math.floor(r.length/2),d=Ju({inputs:r.slice(0,l),backend:n}),f=Ju({inputs:r.slice(l),backend:n});return Ju({inputs:[d,f],backend:n})}const o=r.map(l=>l.dtype).reduce((l,d)=>Rt(l,d)),i=r.map(l=>l.shape),u=V().getBool("WEBGL_PACK")?new EU(r[0].shape,i):new RU(r[0].shape,i);return n.runWebGLProgram(u,r,o)}const _U={kernelName:jv,backendName:"webgl",kernelFunc:Ju};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PU(t){const{inputs:e,backend:n,attrs:r}=t,{x:o}=e,{axis:i,keepDims:a}=r,u=o.shape.length,l=Je(i,o.shape);let d=l;const f=dt(d,u);let p=o;f!=null&&(p=Ct({inputs:{x:o},backend:n,attrs:{perm:f}}),d=ft(d.length,u)),Ft("all",d,u);const[h,g]=Ht(p.shape,d),y=Y(g),x=ue({inputs:{x:p},backend:n,attrs:{shape:[-1,y]}}),v=qo(x,x.dtype,"all",n);let w;if(a){const S=Fn(h,l);w=ue({inputs:{x:v},backend:n,attrs:{shape:S}})}else w=ue({inputs:{x:v},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(v),f!=null&&n.disposeIntermediateTensorInfo(p),w}const kU={kernelName:Xv,backendName:"webgl",kernelFunc:PU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TU(t){const{inputs:e,backend:n,attrs:r}=t,{x:o}=e,{axis:i,keepDims:a}=r,u=o.shape.length,l=Je(i,o.shape);let d=l;const f=dt(d,u);let p=o;f!=null&&(p=Ct({inputs:{x:o},backend:n,attrs:{perm:f}}),d=ft(d.length,u)),Ft("any",d,u);const[h,g]=Ht(p.shape,d),y=Y(g),x=ue({inputs:{x:p},backend:n,attrs:{shape:[-1,y]}}),v=qo(x,x.dtype,"any",n);let w;if(a){const S=Fn(h,l);w=ue({inputs:{x:v},backend:n,attrs:{shape:S}})}else w=ue({inputs:{x:v},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(v),f!=null&&n.disposeIntermediateTensorInfo(p),w}const AU={kernelName:qv,backendName:"webgl",kernelFunc:TU};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class NU{constructor(e,n,r){this.variableNames=["A"];const{windowSize:o,batchSize:i,outSize:a}=e;r||this.variableNames.push("bestIndicesA"),this.outputShape=[i,a];const u=n==="max"?">":"<",l=r?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${o};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${o}; i++) {
          int inIdx = ${l};
          float candidate = getA(batch, inIdx);
          if (candidate ${u} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class OU{constructor(e,n,r,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,re(e.length>2,()=>`Packed arg${r.charAt(0).toUpperCase()+r.slice(1)} supports only inputs with rank above 2.`);const i=e[e.length-1],a=Math.ceil(i/n);this.outputShape=e.slice(0,-1),a>1&&this.outputShape.push(a),o||this.variableNames.push("bestIndicesA");const u=this.outputShape,l=u.length,d=Me(l),f=vt("coords",l);let p,h;if(a===1){h=l+1;const D=Me(h);p=`
        ${D} sourceLocR = ${D}(${f.join()}, 0);
        ++${f[l-1]};
        ${D} sourceLocG = ${D}(${f.join()}, 0);
        ++${f[l-2]};
        ${D} sourceLocA = ${D}(${f.join()}, 0);
        --${f[l-1]};
        ${D} sourceLocB = ${D}(${f.join()}, 0);
        --${f[l-2]};`}else h=l,p=`
        ${d} sourceLocR = coords;
        ++${f[l-1]};
        ${d} sourceLocG = coords;
        ++${f[l-2]};
        ${d} sourceLocA = coords;
        --${f[l-1]};
        ${d} sourceLocB = coords;
        --${f[l-2]};`;const g=["x","y","z","w","u","v"].slice(0,h),y="."+g[h-1],x=g.map(D=>"int "+D),v=vt("sourceLocR",h-1).concat("inIdx.r"),w=vt("sourceLocG",h-1).concat("inIdx.g"),S=vt("sourceLocB",h-1).concat("inIdx.b"),I=vt("sourceLocA",h-1).concat("inIdx.a"),E=r==="max"?"greaterThan":"lessThan",R=o?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${v.join()}),
                             getBestIndicesAChannel(${w.join()}),
                             getBestIndicesAChannel(${S.join()}),
                             getBestIndicesAChannel(${I.join()})));`,T=`vec4(
            getAChannel(${v.join()}),
            hasNextCol ? getAChannel(${w.join()}) : 0.,
            hasNextRow ? getAChannel(${S.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${I.join()}) : 0.)`,k=o?"":`
      float getBestIndicesAChannel(${x.join()}) {
        return getChannel(getBestIndicesA(${g.join()}),
                                          vec2(${g.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${x.join()}) {
        return getChannel(getA(${g.join()}),
                               vec2(${g.slice(-2).join()}));
      }
      ${k}
      void main() {
        ${d} coords = getOutputCoords();
        bool hasNextCol = ${f[l-1]} < ${u[l-1]-1};
        bool hasNextRow = ${f[l-2]} < ${u[l-2]-1};
        ${p}
        ivec4 srcIdx = ivec4(sourceLocR${y}, sourceLocG${y},
          sourceLocB${y}, sourceLocA${y}) * ${n};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${T};

        for (int i = 0; i < ${n}; i++) {
          inIdx = srcIdx;
          ${R}
          vec4 candidate = ${T};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${E}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wS(t,e,n,r=null){let o=e.shape[0],i=e.shape[1];r!=null&&(o=r.shape[0],i=r.shape[1]);const a=Sl(i),u={windowSize:a,inSize:i,batchSize:o,outSize:Math.ceil(i/a)},l=new NU(u,n,r==null),d=[e];r!=null&&d.push(r);const f=t.runWebGLProgram(l,d,"int32");if(f.shape[1]===1)return f;const p=wS(t,e,n,f);return t.disposeIntermediateTensorInfo(f),p}function SS(t,e,n,r=null){const o=r!=null?r.shape:e.shape,i=o[o.length-1],a=Sl(i),u=new OU(o,a,n,r==null),l=r==null?[e]:[e,r],d=t.runWebGLProgram(u,l,"int32");if(d.shape.length===e.shape.length){const f=SS(t,e,n,d);return t.disposeIntermediateTensorInfo(d),f}return d}function bS(t,e,n,r){const o=[n];if(Ft("arg"+r.charAt(0).toUpperCase()+r.slice(1),o,e.shape.length),!V().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){const i=[],a=t.texData.get(e.dataId),u=a!==null&&a.isPacked;let l=e;u&&(l=t.unpackTensor(e),i.push(l));const[d,f]=Ht(l.shape,o),p=Y(f),h=ue({inputs:{x:l},backend:t,attrs:{shape:[-1,p]}});i.push(h);const g=wS(t,h,r);i.push(g);const y=ue({inputs:{x:g},backend:t,attrs:{shape:d}});return i.forEach(x=>t.disposeIntermediateTensorInfo(x)),y}return SS(t,e,r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DU(t){const{inputs:e,backend:n,attrs:r}=t,{x:o}=e,{axis:i}=r;let a=Je(i,o.shape);const u=dt(a,o.shape.length);let l=o;const d=[];u!=null&&(l=Ct({inputs:{x:o},backend:n,attrs:{perm:u}}),d.push(l),a=ft(a.length,l.shape.length)),Ft("argMax",[a[0]],l.shape.length);const f=bS(n,l,a[0],"max");return d.forEach(p=>n.disposeIntermediateTensorInfo(p)),f}const FU={kernelName:Kv,backendName:"webgl",kernelFunc:DU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LU(t){const{inputs:e,backend:n,attrs:r}=t,{x:o}=e,{axis:i}=r;let a=Je(i,o.shape);const u=dt(a,o.shape.length);let l=o;const d=[];u!=null&&(l=Ct({inputs:{x:o},backend:n,attrs:{perm:u}}),d.push(l),a=ft(a.length,l.shape.length)),Ft("argMin",[a[0]],l.shape.length);const f=bS(n,l,a[0],"min");return d.forEach(p=>n.disposeIntermediateTensorInfo(p)),f}const MU={kernelName:Yv,backendName:"webgl",kernelFunc:LU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BU=nn+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,UU=Ae({opSnippet:BU}),WU={kernelName:Qv,backendName:"webgl",kernelFunc:UU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VU=nn+"return log(x + sqrt(x * x + 1.0));",zU=Ae({opSnippet:VU}),GU={kernelName:Zv,backendName:"webgl",kernelFunc:zU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HU=nn+`
  return atan(x);
`,jU=Ae({opSnippet:HU}),XU={kernelName:Jv,backendName:"webgl",kernelFunc:jU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qU=Hp+`
  return atan(a, b);
`,KU=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Xo+`
  return result;
`,YU=ut({opSnippet:qU,packedOpSnippet:KU}),QU={kernelName:tC,backendName:"webgl",kernelFunc:YU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZU=nn+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,JU=Ae({opSnippet:ZU}),eW={kernelName:eC,backendName:"webgl",kernelFunc:JU};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class va{constructor(e,n,r,o=!1,i=!1){if(this.variableNames=["x"],n==="avg"&&r)throw new Error("Cannot compute positions for average pool.");const a=e.filterWidth,u=e.strideHeight,l=e.strideWidth,d=e.dilationHeight,f=e.dilationWidth,p=e.effectiveFilterHeight,h=e.effectiveFilterWidth,g=e.padInfo.top,y=e.padInfo.left;this.outputShape=e.outShape;const x=n==="avg",v=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,w=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let S="0.0";if(x||(S="-1.0 / 1e-20"),r){const D=">=";this.userCode=`
        const ivec2 strides = ivec2(${u}, ${l});
        const ivec2 pads = ivec2(${g}, ${y});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${p};
              wR += ${d}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${h};
                wC += ${f}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${D} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${o?i?v:w:`wR * ${h} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const I="max";let E=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;n==="avg"&&(E="avgValue / max(count, 1.0)");const R=Math.floor(a/4)*4,T=a%4,k=`
      if (${x}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${I}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${u}, ${l});
      const ivec2 pads = ivec2(${g}, ${y});
      const float initializationValue = ${S};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${S});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${p};
            wR += ${d}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${R}; wC += 4) {
            int xC = xCCorner + wC * ${f};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${f}, d),
              getValue(batch, xR, xC + 2 * ${f}, d),
              getValue(batch, xR, xC + 3 * ${f}, d)
            );

            ${k}
          }

          int xC = xCCorner + ${R};
          if (${T===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${k}
          } else if (${T===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${f}, d),
              initializationValue,
              initializationValue
            );

            ${k}
          } else if (${T===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${f}, d),
              getValue(batch, xR, xC + 2 * ${f}, d),
              initializationValue
            );

            ${k}
          }
        }
        setOutput(${E});
      }
    `}}class Xp{constructor(e,n,r,o=!1,i=!1){if(this.variableNames=["x"],n==="avg"&&r)throw new Error("Cannot compute positions for average pool.");const a=e.filterWidth,u=e.strideDepth,l=e.strideHeight,d=e.strideWidth,f=e.dilationDepth,p=e.dilationHeight,h=e.dilationWidth,g=e.effectiveFilterDepth,y=e.effectiveFilterHeight,x=e.effectiveFilterWidth,v=e.padInfo.front,w=e.padInfo.top,S=e.padInfo.left;this.outputShape=e.outShape;const I=n==="avg";let E="0.0";if(I||(E="-1.0 / 1e-20"),r){const O=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${u}, ${l}, ${d});
        const ivec3 pads = ivec3(${v}, ${w}, ${S});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${g};
              wD += ${f}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${y};
                wR += ${p}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${x};
                  wC += ${h}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${O} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${o?i?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${y} * ${x} +
                      wR * ${x} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const R="max";let T=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;n==="avg"&&(T="avgValue / max(count, 1.0)");const k=Math.floor(a/4)*4,D=a%4,N=`
      if (${I}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${R}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${u}, ${l}, ${d});
      const ivec3 pads = ivec3(${v}, ${w}, ${S});
      const float initializationValue = ${E};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${E});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${g};
            wD += ${f}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${y};
            wR += ${p}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${k}; wC += 4) {
              int xC = xCCorner + wC * ${h};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${h}, ch),
                getValue(batch, xD, xR, xC + 2 * ${h}, ch),
                getValue(batch, xD, xR, xC + 3 * ${h}, ch)
              );

              ${N}
            }

            int xC = xCCorner + ${k};
            if (${D===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${N}
            } else if (${D===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${h}, ch),
                initializationValue,
                initializationValue
              );

              ${N}
            } else if (${D===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${h}, ch),
                getValue(batch, xD, xR, xC + 2 * ${h}, ch),
                initializationValue
              );

              ${N}
            }
          }
        }
        setOutput(${T});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tW(t){const{inputs:e,backend:n,attrs:r}=t,{x:o}=e;Ta(o,"avgPool");const{filterSize:i,strides:a,pad:u,dimRoundingMode:l}=r,d=1;re(Fr(a,d),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${d}'`);const f=vn(o.shape,i,a,d,u,l);if(f.filterWidth===1&&f.filterHeight===1&&je(f.inShape,f.outShape))return Dt({inputs:{x:o},backend:n});const p=new va(f,"avg",!1);return n.runWebGLProgram(p,[o],"float32")}const nW={kernelName:nC,backendName:"webgl",kernelFunc:tW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rW(t){const{inputs:e,backend:n,attrs:r}=t,{x:o}=e,{filterSize:i,strides:a,pad:u,dimRoundingMode:l,dataFormat:d}=r,f=[1,1,1],p=Zn(o.shape,i,a,f,u,l,d),h=new Xp(p,"avg",!1);return n.runWebGLProgram(h,[o],"float32")}const oW={kernelName:oC,backendName:"webgl",kernelFunc:rW};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class iW{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const n=e.filterHeight,r=e.filterWidth,o=e.strideHeight,i=e.strideWidth,a=e.dilationHeight,u=e.dilationWidth,l=e.effectiveFilterHeight,d=e.effectiveFilterWidth,f=l-1-e.padInfo.top,p=d-1-e.padInfo.left,h=1/(n*r);this.userCode=`
      const ivec2 pads = ivec2(${f}, ${p});
      const float avgMultiplier = float(${h});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${l};
            wR += ${a}) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${d};
            wC+= ${u}) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}}class sW{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const n=e.filterDepth,r=e.filterHeight,o=e.filterWidth,i=e.strideDepth,a=e.strideHeight,u=e.strideWidth,l=e.dilationDepth,d=e.dilationHeight,f=e.dilationWidth,p=e.effectiveFilterDepth,h=e.effectiveFilterHeight,g=e.effectiveFilterWidth,y=p-1-e.padInfo.front,x=h-1-e.padInfo.top,v=g-1-e.padInfo.left,w=1/(n*r*o);this.userCode=`
      const ivec3 pads = ivec3(${y}, ${x}, ${v});
      const float avgMultiplier = float(${w});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${p};
            wD += ${l}) {
          float dyD = float(dyDCorner + wD) / ${i}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${h};
              wR += ${d}) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${g};
                wC += ${f}) {
              float dyC = float(dyCCorner + wC) / ${u}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aW(t){const{inputs:e,backend:n,attrs:r}=t,{dy:o,input:i}=e,a=i,{filterSize:u,strides:l,pad:d,dimRoundingMode:f}=r,p=[1,1,1],h=Zn(a.shape,u,l,p,d,f),g=new sW(h);return n.runWebGLProgram(g,[o],a.dtype)}const uW={kernelName:iC,backendName:"webgl",kernelFunc:aW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lW(t){const{inputs:e,backend:n,attrs:r}=t,{dy:o,input:i}=e,a=i;Ta([o,i],"avgPoolGrad");const{filterSize:u,strides:l,pad:d}=r,f=vn(a.shape,u,l,1,d),p=new iW(f);return n.runWebGLProgram(p,[o],a.dtype)}const cW={kernelName:rC,backendName:"webgl",kernelFunc:lW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dW(t){const{inputs:e,backend:n,attrs:r}=t,{a:o,b:i}=e,{transposeA:a,transposeB:u}=r;return pl({a:o,b:i,transposeA:a,transposeB:u,backend:n})}const fW={kernelName:sC,backendName:"webgl",kernelFunc:dW};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pW{constructor(e,n,r,o,i,a){this.outputShape=[],this.variableNames=["x","mean","variance"],He(e,n),He(e,r);let u="0.0";o!=null&&(He(e,o),this.variableNames.push("offset"),u="getOffsetAtOutCoords()");let l="1.0";i!=null&&(He(e,i),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${u};
        float scale = ${l};
        float inv = scale * inversesqrt(variance + float(${a}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hW{constructor(e,n,r,o,i,a){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],He(e,n),He(e,r);let u="vec4(0.0)";o!=null&&(He(e,o),this.variableNames.push("offset"),u="getOffsetAtOutCoords()");let l="vec4(1.0)";i!=null&&(He(e,i),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${u};
        vec4 scale = ${l};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${a}));

        setOutput((x - mean) * inv + offset);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mW=({inputs:t,backend:e,attrs:n})=>{const{x:r,mean:o,variance:i,offset:a,scale:u}=t;re(o.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),re(a==null||o.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),re(u==null||o.shape.length===u.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=n;l==null&&(l=.001);const d=[r,o,i];let f=null;a!=null&&(f=a.shape,d.push(a));let p=null;u!=null&&(p=u.shape,d.push(u));const h=V().getBool("WEBGL_PACK_NORMALIZATION")?new hW(r.shape,o.shape,i.shape,f,p,l):new pW(r.shape,o.shape,i.shape,f,p,l);return e.runWebGLProgram(h,d,d[0].dtype)},gW={kernelName:WC,backendName:"webgl",kernelFunc:mW};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yW{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const n=Me(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const r=xW(this.rank);let o;const i=e.map((a,u)=>`sourceLoc.${bf[u]} = start[${u}] + coords.${bf[u]};`);o=`
        ${n} sourceLoc;
        ${n} coords = getOutputCoords();
        ${i.join(`
`)}
      `,this.userCode=`
      void main() {
        ${o}
        setOutput(getSource(${r}));
      }
    `}}const bf=["x","y","z","w","u","v"];function xW(t){if(t===1)return"sourceLoc";if(t<=6)return bf.slice(0,t).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${t} is not yet supported`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vW{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=Me(this.rank),r=vt("coords",this.rank),o=vt("sourceLoc",this.rank),i=this.rank===1?"sourceLoc":`vec2(${o.slice(-2).join()})`,a=`getChannel(getSource(${o.join()}), ${i})`,u=`
      result.x = ${a};
      if (++${r[this.rank-1]} < ${e[this.rank-1]}) {
        ++${o[this.rank-1]};
        result.y = ${a};
        --${o[this.rank-1]};
      }
    `,l=this.rank===1?"":`
      --${r[this.rank-1]};
      if (++${r[this.rank-2]} < ${e[this.rank-2]}) {
        ++${o[this.rank-2]};
        result.z = ${a};
        if (++${r[this.rank-1]} < ${e[this.rank-1]}) {
          ++${o[this.rank-1]};
          result.w = ${a};
        }
      }
    `,d=this.rank<=4?`sourceLoc = coords +
            ${n}(${e.map((f,p)=>`start[${p}]`).join()});`:e.map((f,p)=>`${o[p]} = ${r[p]} + start[${p}];`).join(`
`);this.userCode=`
      void main() {
        ${n} coords = getOutputCoords();
        ${n} sourceLoc;
        ${d}
        vec4 result = vec4(0.);
        ${u}
        ${l}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CW(t,e,n,r){const o=r.texData.get(t.dataId),i=r.makeTensorInfo(n,t.dtype),a=r.texData.get(i.dataId);Object.assign(a,o),a.refCount=1,a.shape=n,a.dtype=t.dtype;let u=fp(e,Ke(t.shape));o.slice&&(u+=o.slice.flatOffset),a.slice={flatOffset:u,origDataId:o.slice&&o.slice.origDataId||t.dataId};const l=r.dataRefCount.get(a.slice.origDataId)||1;return r.dataRefCount.set(a.slice.origDataId,l+1),i}function ts(t){const{inputs:e,backend:n,attrs:r}=t,{x:o}=e,{begin:i,size:a}=r,[u,l]=pp(o,i,a);if(lp(o,u,l),Y(l)===0)return n.makeTensorInfo(l,o.dtype,[]);if(n.shouldExecuteOnCPU([o])||o.dtype==="string"){const p=n.texData.get(o.dataId),h=fB(p.values,u,l,o.shape,o.dtype);return n.makeTensorInfo(l,o.dtype,h)}const{isPacked:d}=n.texData.get(o.dataId),f=dp(o.shape,u,l);if(d||!f){const p=V().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new vW(l):new yW(l),h=[u];return n.runWebGLProgram(p,[o],o.dtype,h)}return n.uploadToGPU(o.dataId),CW(o,u,l,n)}const wW={kernelName:z1,backendName:"webgl",kernelFunc:ts};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SW=t=>{const{inputs:e,backend:n,attrs:r}=t,{x:o}=e,{blockShape:i,crops:a}=r;re(o.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const u=i.reduce((S,I)=>S*I),l=Ra(o.shape,i,u),d=Ea(l.length,i.length),f=_a(o.shape,i,u),p=xp(a,i.length),h=vp(f,a,i.length),g=[],y=ue({inputs:{x:o},backend:n,attrs:{shape:l}}),x=Ct({inputs:{x:y},backend:n,attrs:{perm:d}}),v=ue({inputs:{x},backend:n,attrs:{shape:f}}),w=ts({inputs:{x:v},backend:n,attrs:{begin:p,size:h}});return g.push(y),g.push(x),g.push(v),g.forEach(S=>n.disposeIntermediateTensorInfo(S)),w},bW={kernelName:aC,backendName:"webgl",kernelFunc:SW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IW(t){const{inputs:e,backend:n,attrs:r}=t,{x:o,weights:i}=e,{size:a}=r,u=n.readSync(o.dataId),l=n.readSync(i.dataId),d=cS(u,l,i.dtype,i.shape,a);return n.makeTensorInfo([a],i.dtype,d)}const $W={kernelName:uC,backendName:"webgl",kernelFunc:IW};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RW=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,EW=`
  return float(int(a.r) & int(b.r));
`;function _W(t){const{inputs:e,backend:n}=t,{a:r,b:o}=e,i=V().getBool("WEBGL_PACK_BINARY_OPERATIONS"),a=V().getNumber("WEBGL_VERSION");if(n.shouldExecuteOnCPU([r,o])||a===1){const l=n.texData.get(r.dataId).values,d=n.texData.get(o.dataId).values,[f,p]=FM(r.shape,o.shape,l,d,r.dtype),h=n.makeTensorInfo(p,r.dtype),g=n.texData.get(h.dataId);return g.values=f,h}let u;return i?u=new Ji(RW,r.shape,o.shape,!1):u=new Lo(EW,r.shape,o.shape),n.runWebGLProgram(u,[r,o],r.dtype)}const PW={kernelName:CI,backendName:"webgl",kernelFunc:_W};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kW(t){const{inputs:e,backend:n}=t,{s0:r,s1:o}=e,i=n.readSync(r.dataId),a=n.readSync(o.dataId),u=He(Array.from(i),Array.from(a));return n.makeTensorInfo([u.length],"int32",Int32Array.from(u))}const TW={kernelName:lC,backendName:"webgl",kernelFunc:kW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AW="return float(a != b);",IS=ut({opSnippet:AW,cpuKernelImpl:rB,dtype:"bool"}),NW={kernelName:C1,backendName:"webgl",kernelFunc:IS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Na(t){const{inputs:e,backend:n}=t,{input:r}=e,o=n.texData.get(r.dataId);return Dt({inputs:{x:o.complexTensorInfos.real},backend:n})}const OW={kernelName:P1,backendName:"webgl",kernelFunc:Na};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DW="return float(int(x));";function FW(t,e){const n=new An(t.shape,DW),r=e.runWebGLProgram(n,[t],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function If(t){const{inputs:e,backend:n,attrs:r}=t,{x:o}=e,{dtype:i}=r;if(i==="complex64"){if(o.dtype==="complex64")return Dt({inputs:{x:o},backend:n});const a=al(o.shape),u=If({inputs:{x:o},backend:n,attrs:{dtype:"float32"}}),l=Mr({inputs:{real:u,imag:a},backend:n});return a.dispose(),n.disposeIntermediateTensorInfo(u),l}if(o.dtype==="complex64"){const a=Na({inputs:{input:o},backend:n}),u=If({inputs:{x:a},backend:n,attrs:{dtype:i}});return n.disposeIntermediateTensorInfo(a),u}if(!Uv(o.dtype,i)){const a=Dt({inputs:{x:o},backend:n});return{dataId:a.dataId,shape:a.shape,dtype:i}}if(n.shouldExecuteOnCPU([o])){const a=n.texData.get(o.dataId).values,[u,l,d]=LM(a,o.shape,o.dtype,i);return n.makeTensorInfo(u,l,d)}if(i==="int32")return FW(o,n);if(i==="bool"){const a=n.makeTensorInfo([],"bool",qn("bool",1)),l=IS({inputs:{a:o,b:a},backend:n});return n.disposeIntermediateTensorInfo(a),l}throw new Error(`Error in Cast: failed to cast ${o.dtype} to ${i}`)}const LW={kernelName:yl,backendName:"webgl",kernelFunc:If};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qy="return ceil(x);",MW=Ae({opSnippet:qy,packedOpSnippet:qy,cpuKernelImpl:MM}),BW={kernelName:cC,backendName:"webgl",kernelFunc:MW};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class UW{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class WW{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VW(t){const{inputs:e,backend:n,attrs:r}=t,{x:o}=e,{clipValueMin:i,clipValueMax:a}=r;let u;V().getBool("WEBGL_PACK_CLIP")?u=new WW(o.shape):u=new UW(o.shape);const l=[[i],[a]];return n.runWebGLProgram(u,[o],o.dtype,l)}const zW={kernelName:dC,backendName:"webgl",kernelFunc:VW};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class GW{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ky(t,e){return{dataId:e.dataId,dtype:e.dtype,shape:t.shape}}function HW(t){const{inputs:e,backend:n}=t,{x:r}=e,o=n.texData.get(r.dataId),i=new GW(r.shape),a=[Ky(r,o.complexTensorInfos.real),Ky(r,o.complexTensorInfos.imag)];return n.runWebGLProgram(i,a,a[0].dtype)}const jW={kernelName:Lf,backendName:"webgl",kernelFunc:HW};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class XW{constructor(e){this.outputShape=[],this.outputShape=tn(e,1),this.variableNames=e.map((a,u)=>`T${u}`);const n=new Array(e.length-1);n[0]=e[0][1];for(let a=1;a<n.length;a++)n[a]=n[a-1]+e[a][1];const r=[`if (yC < ${n[0]}) setOutput(getT0(yR, yC));`];for(let a=1;a<n.length;a++){const u=n[a-1];r.push(`else if (yC < ${n[a]}) setOutput(getT${a}(yR, yC-${u}));`)}const o=n.length,i=n[n.length-1];r.push(`else setOutput(getT${o}(yR, yC-${i}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${r.join(`
        `)}
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qW{constructor(e,n){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=tn(e,n);const r=this.outputShape,o=r.length,i=Me(o),a=vt("coords",o),u=["x","y","z","w","u","v"].slice(0,o);this.variableNames=e.map((x,v)=>`T${v}`);const l=new Array(e.length-1);l[0]=e[0][n];for(let x=1;x<l.length;x++)l[x]=l[x-1]+e[x][n];const d=u[n],f=u.slice(-2),p=u.join();let h=`if (${d} < ${l[0]}) {
        return getChannel(
            getT0(${p}), vec2(${f.join()}));
        }`;for(let x=1;x<l.length;x++){const v=l[x-1];h+=`
        if (${d} < ${l[x]}  && ${d} >= ${l[x-1]}) {
          return getChannel(
            getT${x}(${Hu(u,d,v)}),
            vec2(${Hu(f,d,v)}));
        }`}const g=l.length,y=l[l.length-1];h+=`
        return getChannel(
          getT${g}(${Hu(u,d,y)}),
          vec2(${Hu(f,d,y)}));`,this.userCode=`
      float getValue(${u.map(x=>"int "+x)}) {
        ${h}
      }

      void main() {
        ${i} coords = getOutputCoords();
        vec4 result = vec4(getValue(${a}), 0., 0., 0.);

        ${a[o-1]} = ${a[o-1]} + 1;
        if (${a[o-1]} < ${r[o-1]}) {
          result.g = getValue(${a});
        }

        ${a[o-2]} = ${a[o-2]} + 1;
        if (${a[o-2]} < ${r[o-2]}) {
          result.a = getValue(${a});
        }

        ${a[o-1]} = ${a[o-1]} - 1;
        if (${a[o-2]} < ${r[o-2]} &&
            ${a[o-1]} < ${r[o-1]}) {
          result.b = getValue(${a});
        }
        setOutput(result);
      }
    `}}function Hu(t,e,n){const r=t.indexOf(e);return t.map((i,a)=>a===r?`${i} - ${n}`:i).join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Al(t){const{inputs:e,backend:n}=t,{input:r}=e,o=n.texData.get(r.dataId);return Dt({inputs:{x:o.complexTensorInfos.imag},backend:n})}const KW={kernelName:XC,backendName:"webgl",kernelFunc:Al};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ca(t,e,n){const r=t[0].dtype;if(r==="complex64"){const g=t.map(S=>Na({inputs:{input:S},backend:n})),y=t.map(S=>Al({inputs:{input:S},backend:n})),x=ca(g,e,n),v=ca(y,e,n),w=Mr({inputs:{real:x,imag:v},backend:n});return g.forEach(S=>n.disposeIntermediateTensorInfo(S)),y.forEach(S=>n.disposeIntermediateTensorInfo(S)),n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(v),w}let o=n.shouldExecuteOnCPU(t);if(r==="string"&&(o=!0),o){const g=t.map(E=>{const T=[-1,Y(E.shape.slice(e))];return ue({inputs:{x:E},backend:n,attrs:{shape:T}})}),y=g.map(E=>({vals:n.readSync(E.dataId),shape:E.shape})),x=tn(g.map(E=>E.shape),1),v=g[0].shape[0]===1,w=BM(y,x,r,v),S=tn(t.map(E=>E.shape),e),I=n.makeTensorInfo(S,r,w);return g.forEach(E=>n.disposeIntermediateTensorInfo(E)),I}const i=t.filter(g=>Y(g.shape)>0),a=V().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&i[0].shape.length>1;if(i.length===1){const g=a?new An(t[0].shape,_r):new kr(t[0].shape,_r);return n.runWebGLProgram(g,t,r)}const u=V().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(i.length>u){const g=[];for(let x=0;x<i.length;x+=u){const v=i.slice(x,x+u);g.push(ca(v,e,n))}const y=ca(g,e,n);for(const x of g)n.disposeIntermediateTensorInfo(x);return y}if(a){const g=new qW(i.map(y=>y.shape),e);return n.runWebGLProgram(g,i,r)}const{tensors2D:l,outShape:d}=YW(i,e,n),f=new XW(l.map(g=>g.shape)),p=n.runWebGLProgram(f,l,r);l.forEach(g=>n.disposeIntermediateTensorInfo(g));const h=ue({inputs:{x:p},attrs:{shape:d},backend:n});return n.disposeIntermediateTensorInfo(p),h}function YW(t,e,n){const r=tn(t.map(i=>i.shape),e);return{tensors2D:t.map(i=>ue({inputs:{x:i},attrs:{shape:[-1,Y(i.shape.slice(e))]},backend:n})),outShape:r}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $S(t){const{inputs:e,backend:n,attrs:r}=t,{axis:o}=r,i=Je(o,e[0].shape)[0],a=e.map(d=>d.shape);mp(a,i);const u=tn(e.map(d=>d.shape),i);if(Y(u)===0)return n.makeTensorInfo(u,e[0].dtype,[]);const l=e.filter(d=>Y(d.shape)>0);return l.length===1?Dt({inputs:{x:l[0]},backend:n}):ca(l,i,n)}const QW={kernelName:fC,backendName:"webgl",kernelFunc:$S};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class RS{constructor(e,n=!1,r=null,o=!1,i=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const a=e.padInfo.top,u=e.padInfo.left,l=e.strideHeight,d=e.strideWidth,f=e.dilationHeight,p=e.dilationWidth,h=e.filterHeight,g=e.filterWidth,y=Math.floor(e.inChannels/4)*4,x=e.inChannels%4,v=e.dataFormat==="channelsLast",w=v?1:2,S=v?2:3,I=v?3:1;let E="",R="";r&&(o?E=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:i?E=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:E=`
          float activation(float x) {
            ${r}
          }
        `,R="result = activation(result);");const T=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${E}

      const ivec2 strides = ivec2(${l}, ${d});
      const ivec2 pads = ivec2(${a}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${I}];

        ivec2 xRCCorner =
            ivec2(coords[${w}], coords[${S}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${h}; wR++) {
          int xR = xRCorner + wR * ${f};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${g}; wC++) {
            int xC = xCCorner + wC * ${p};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${y}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${v}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${x===1}) {

              if (${v}) {
                dotProd +=
                    getX(batch, xR, xC, ${y}) *
                    getW(wR, wC, ${y}, d2);
              } else {
                dotProd +=
                    getX(batch, ${y}, xR, xC) *
                    getW(wR, wC, ${y}, d2);
              }

            } else if (${x===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${y}, d2),
                getW(wR, wC, ${y} + 1, d2)
              );

              if (${v}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${y}),
                  getX(batch, xR, xC, ${y} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${y}, xR, xC),
                  getX(batch, ${y} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${x===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${y}, d2),
                getW(wR, wC, ${y} + 1, d2),
                getW(wR, wC, ${y} + 2, d2)
              );

              if (${v}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${y}),
                  getX(batch, xR, xC, ${y} + 1),
                  getX(batch, xR, xC, ${y} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${y}, xR, xC),
                  getX(batch, ${y} + 1, xR, xC),
                  getX(batch, ${y} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${T}
        ${R}
        setOutput(result);
      }
    `}}class ZW{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const n=e.padInfo.front,r=e.padInfo.top,o=e.padInfo.left,i=e.strideDepth,a=e.strideHeight,u=e.strideWidth,l=e.dilationDepth,d=e.dilationHeight,f=e.dilationWidth,p=e.filterDepth,h=e.filterHeight,g=e.filterWidth,y=Math.floor(e.inChannels/4)*4,x=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${i}, ${a}, ${u});
      const ivec3 pads = ivec3(${n}, ${r}, ${o});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${p}; wF++) {
          int xF = xFCorner + wF * ${l};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${h}; wR++) {
            int xR = xRCorner + wR * ${d};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${g}; wC++) {
              int xC = xCCorner + wC * ${f};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${y}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${x===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${y}) *
                  getW(wF, wR, wC, ${y}, d2);
              } else if (${x===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${y}),
                  getX(batch, xF, xR, xC, ${y} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${y}, d2),
                  getW(wF, wR, wC, ${y} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${x===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${y}),
                  getX(batch, xF, xR, xC, ${y} + 1),
                  getX(batch, xF, xR, xC, ${y} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${y}, d2),
                  getW(wF, wR, wC, ${y} + 1, d2),
                  getW(wF, wR, wC, ${y} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ES{constructor(e,n=!1,r=null,o=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=pt(this.outputShape.length);const a=e.padInfo.left,u=e.strideWidth,l=e.dilationWidth,d=e.filterHeight,f=e.filterWidth,p=f;let h=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let v=0;v<f;v++)h+=`
           vec4 xTexelC${v*2};
           int xTexelC${v*2}Ready;
           vec4 xTexelC${v*2+1};
           int xTexelC${v*2+1}Ready;
           vec4 xC${v};`;h+=`
     for (int r = 0; r < ${d}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;for(let v=0;v<f;v++)h+=`
           xTexelC${v*2} = vec4(0.0);
           xTexelC${v*2}Ready = 0;
           xTexelC${v*2+1} = vec4(0.0);
           xTexelC${v*2+1}Ready = 0;
           xC${v} = vec4(0.0);`;h+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let v=0;v<(p+1)/2;v++){const w=v*2;if(h+=`
           xC = xCCorner + ${w*l};
           `,u===1){if(w<f&&(a%2===1?(h+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${w}Ready == 0) {
                   xTexelC${w} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${w}.zw = vec2(0.0);
                   }
                   xTexelC${w}Ready = 1;
                 }
               `,l===1&&w>0?h+=`
                 xC${w} = vec4(xTexelC${w-2}.zw, xTexelC${w}.xy);
                 `:h+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${w} = vec4(previous.zw, xTexelC${w}.xy);
                   } else {
                     xC${w} = vec4(0.0, 0.0, xTexelC${w}.xy);
                   }
                   `):h+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${w}Ready == 0) {
                   xTexelC${w} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${w}.zw = vec2(0.0);
                   }
                   xTexelC${w}Ready = 1;
                 }

                 xC${w} = xTexelC${w};
                 `,w+1<f)){const S=a%2===0?kf(l):l;l%2===0&&a%2===1||l%2!==0&&a%2!==1?(h+=`
                   xCOffset = xC + imod(pads[1], 2) + ${S};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${w+1}Ready == 0) {
                     xTexelC${w+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${w+1}.zw = vec2(0.0);
                     }
                     xTexelC${w+1}Ready = 1;
                   }
                   `,l>1?h+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${w+1} = vec4(previous.zw, xTexelC${w+1}.xy);
                     } else {
                      xC${w+1} = vec4(0.0, 0.0, xTexelC${w+1}.xy);
                     }
                     `:h+=`
                     xC${w+1} = vec4(xTexelC${w}.zw, xTexelC${w+1}.xy);
                     `):S===1?h+=`
                     xC${w+1} = xTexelC${w};
                     `:h+=`
                     xCOffset = xC + ${S};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${w+1}Ready == 0) {
                       xTexelC${w+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${w+1}.zw = vec2(0.0);
                       }
                       xTexelC${w+1}Ready = 1;
                     }

                     xC${w+1} = xTexelC${w+1};
                     `}}else w<f&&(a%2===1?(h+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${w}Ready == 0) {
                   xTexelC${w} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${w}.zw = vec2(0.0);
                   }
                   xTexelC${w}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${w+1}Ready == 0) {
                   xTexelC${w+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${w+1}.zw = vec2(0.0);
                   }
                   xTexelC${w+1}Ready = 1;
                 }

                 xC${w} = vec4(xTexelC${w}.zw, xTexelC${w+1}.zw);
               `,w+1<f&&(h+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${w+1} = vec4(xTexelC${w+1}.xy, final.xy);
                 `)):(h+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${w}Ready == 0) {
                   xTexelC${w} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${w}.zw = vec2(0.0);
                   }
                   xTexelC${w}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${w+1}Ready == 0) {
                   xTexelC${w+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${w+1}.zw = vec2(0.);
                   }
                   xTexelC${w+1}Ready = 1;
                 }

                 xC${w} = vec4(
                   xTexelC${w}.xy, xTexelC${w+1}.xy);
               `,w+1<f&&(h+=`
                   xC${w+1} = vec4(xTexelC${w}.zw, xTexelC${w+1}.zw);
                 `)));w<f&&(h+=`
             wTexel = getW(r, ${w}, d1, d2);
             dotProd += xC${w}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${w}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,w+1<f&&(h+=`
               wTexel = getW(r, ${w+1}, d1, d2);
               dotProd += xC${w+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${w+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}h+=`
     }
   `,h+=`
     }
   `,h+=`
     }
   `;let g="",y="";r&&(o?g=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${r}
         }`:i?g=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${r}
         }`:g=`vec4 activation(vec4 x) {
           ${r}
         }`,y="result = activation(result);");const x=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${g}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${h}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${x}
         ${y}
         setOutput(result);
       }
     `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class JW{constructor(e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=pt(this.outputShape.length);const{dataFormat:r}=n,o=St(),i=r==="channelsLast",a=i?1:2,u=i?2:3,l=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let d="";for(let f=0;f<=1;f++)for(let p=0;p<=1;p++)d+=`
          blockIndex = rc.z + ${p};
          pos = rc.y + ${f};

          ${l}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${a}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${u}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${i}) {
                  innerDims = vec2(d1, ch);
                  result[${f*2+p}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${f*2+p}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${d}

        ${o.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hl(t,e){const n=t.length;return n>=3?e?[...t.slice(0,-3),t[n-3]*t[n-2],t[n-1]]:[...t.slice(0,-3),t[n-3],t[n-2]*t[n-1]]:!e&&n===1&&t[0]>1?[t[0],1]:null}function _S({x:t,filter:e,convInfo:n,backend:r,bias:o=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:u=null}){const l=t.shape,d=r.texData.get(t.dataId),f=n.inChannels,p=l[0]*l[1]*l[2],h=n.outChannels,g=n.dataFormat==="channelsLast",y=!1,x=!1;let v;const w=[];if(i!=null){const E=hl(i.shape,g);E!=null&&(i=ue({inputs:{x:i},backend:r,attrs:{shape:E}}),w.push(i))}if(o!=null){const E=hl(o.shape,g);E!=null&&(o=ue({inputs:{x:o},backend:r,attrs:{shape:E}}),w.push(o))}if(!((p===1||h===1)&&f>CS)&&d.isPacked&&g&&d.texture!=null&&l[2]%2!==0&&je(d.shape.slice(-3),l.slice(-3))){const E=l[0]*l[1]*(l[2]+1),R={dataId:t.dataId,shape:[1,E,n.inChannels],dtype:t.dtype},T=d.shape;d.shape=d.shape.slice(),d.shape[d.shape.length-2]++,re(fl(d.shape,R.shape),()=>`packed reshape ${d.shape} to ${R.shape} isn't free`);const k=ue({inputs:{x:e},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}});w.push(k);const D=pl({a:R,b:k,backend:r,transposeA:y,transposeB:x,bias:o,activation:u,preluActivationWeights:i,leakyreluAlpha:a}),N=r.texData.get(D.dataId);re(N.isPacked,()=>"batchMatMul result is expected to be packed"),d.shape=T,N.shape=n.outShape,v=Dt({inputs:{x:D},backend:r}),v.shape=n.outShape,w.push(D)}else{const E=n.outHeight*n.outWidth,R=ue({inputs:{x:t},backend:r,attrs:{shape:g?[n.batchSize,E,n.inChannels]:[n.batchSize,n.inChannels,E]}}),T=ue({inputs:{x:e},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}}),k=pl({a:g?R:T,b:g?T:R,transposeA:!g,transposeB:x,backend:r,bias:o,activation:u,preluActivationWeights:i,leakyreluAlpha:a});v=ue({inputs:{x:k},backend:r,attrs:{shape:n.outShape}}),w.push(R),w.push(T),w.push(k)}for(const E of w)r.disposeIntermediateTensorInfo(E);return v}function PS({x:t,filter:e,convInfo:n,backend:r,bias:o=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:u=null}){const{filterWidth:l,filterHeight:d,inChannels:f,outWidth:p,outHeight:h,dataFormat:g}=n,y=g==="channelsLast",x=l*d*f,v=h*p,w=[n.batchSize,x,v],S=!0,I=!1,E=[];if(i!=null){const X=hl(i.shape,y);X!=null&&(i=ue({inputs:{x:i},backend:r,attrs:{shape:X}}),E.push(i))}if(o!=null){const X=hl(o.shape,y);X!=null&&(o=ue({inputs:{x:o},backend:r,attrs:{shape:X}}),E.push(o))}const R=ue({inputs:{x:e},backend:r,attrs:{shape:[1,x,Y(e.shape)/x]}});E.push(R);const T=new JW(w,n),k=[t.shape,[n.padInfo.top,n.padInfo.left],[n.strideHeight,n.strideWidth],[n.dilationHeight,n.dilationWidth],[n.inChannels],[n.filterWidth*n.inChannels],[n.outWidth]],D=r.runWebGLProgram(T,[t],"float32",k),N=ue({inputs:{x:D},backend:r,attrs:{shape:w}});E.push(D),E.push(N);const O=o!=null,_=i!=null,F=u==="leakyrelu",U=u?xa(u,!0):null,G=new vS(y?N.shape:R.shape,y?R.shape:N.shape,y?[n.batchSize,v,n.outChannels]:[n.batchSize,n.outChannels,v],S,I,O,U,_,F),j=y?[N,R]:[R,N];if(o&&j.push(o),_&&j.push(i),F){const X=r.makeTensorInfo([],"float32",Hi(a,"float32"));j.push(X),E.push(X)}const Z=r.runWebGLProgram(G,j,"float32"),L=ue({inputs:{x:Z},backend:r,attrs:{shape:n.outShape}});E.push(Z);for(const X of E)r.disposeIntermediateTensorInfo(X);return L}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eV(t){const{inputs:e,backend:n,attrs:r}=t,{x:o,filter:i}=e,{strides:a,pad:u,dataFormat:l,dilations:d,dimRoundingMode:f}=r,p=Cn(l),h=it(o.shape,i.shape,a,d,u,f,!1,p);let g;if(h.filterHeight===1&&h.filterWidth===1&&h.dilationHeight===1&&h.dilationWidth===1&&h.strideHeight===1&&h.strideWidth===1&&(h.padInfo.type==="SAME"||h.padInfo.type==="VALID"))g=_S({x:o,filter:i,convInfo:h,backend:n});else if(h.strideWidth<=2&&p==="channelsLast"&&V().getBool("WEBGL_EXP_CONV")){const x=new ES(h),v=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];g=n.runWebGLProgram(x,[o,i],"float32",v)}else if(V().getBool("WEBGL_CONV_IM2COL"))g=PS({x:o,filter:i,convInfo:h,backend:n});else{const x=new RS(h);g=n.runWebGLProgram(x,[o,i],"float32")}const y=ue({inputs:{x:g},backend:n,attrs:{shape:h.outShape}});return n.disposeIntermediateTensorInfo(g),y}const tV={kernelName:pC,backendName:"webgl",kernelFunc:eV};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nV{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const n=e.strideHeight,r=e.strideWidth,o=e.padInfo.top,i=e.padInfo.left,a=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${n} - ${o};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${i};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              ${a?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class rV{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const n=e.filterHeight,r=e.filterWidth,o=e.strideHeight,i=e.strideWidth,a=e.dataFormat==="channelsLast",u=n-1-e.padInfo.top,l=r-1-e.padInfo.left,d=a?1:2,f=a?2:3,p=a?3:1;this.userCode=`
      const ivec2 pads = ivec2(${u}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${p}];

        ivec2 dyCorner = ivec2(coords[${d}], coords[${f}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${n}; wR++) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${n} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${a}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class oV{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const n=e.strideDepth,r=e.strideHeight,o=e.strideWidth,i=e.padInfo.front,a=e.padInfo.top,u=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${n} - ${i};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${r} - ${a};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${o} - ${u};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class iV{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const n=e.filterDepth,r=e.filterHeight,o=e.filterWidth,i=e.strideDepth,a=e.strideHeight,u=e.strideWidth,l=n-1-e.padInfo.front,d=r-1-e.padInfo.top,f=o-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${l}, ${d}, ${f});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${n}; wF++) {
          float dyF = float(dyFCorner + wF) / ${i}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${n} - 1 - wF;

          for (int wR = 0; wR < ${r}; wR++) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${r} - 1 - wR;

            for (int wC = 0; wC < ${o}; wC++) {
              float dyC = float(dyCCorner + wC) / ${u}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${o} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sV(t){const{inputs:e,backend:n,attrs:r}=t,{x:o,dy:i}=e,{strides:a,pad:u,dataFormat:l,dimRoundingMode:d,filterShape:f}=r,p=Cn(l),h=it(o.shape,f,a,1,u,d,!1,p),g=new nV(h);return n.runWebGLProgram(g,[o,i],"float32")}const aV={kernelName:hC,backendName:"webgl",kernelFunc:sV};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class uV{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=pt(this.outputShape.length);const n=e.filterHeight,r=e.filterWidth,o=n-1-e.padInfo.top,i=r-1-e.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${n}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${n} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            int wCPerm = ${r} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lV(t){const{inputs:e,backend:n,attrs:r}=t,{dy:o,filter:i}=e,{inputShape:a,strides:u,pad:l,dataFormat:d,dimRoundingMode:f}=r,p=Cn(d),h=it(a,i.shape,u,1,l,f,!1,p);if(V().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&p==="channelsLast"){const g=[[h.strideHeight,h.strideWidth]],y=new uV(h);return n.runWebGLProgram(y,[o,i],"float32",g)}else{const g=new rV(h);return n.runWebGLProgram(g,[o,i],"float32")}}const cV={kernelName:mC,backendName:"webgl",kernelFunc:lV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dV(t){const{inputs:e,backend:n,attrs:r}=t,{x:o,filter:i}=e,{strides:a,pad:u,dilations:l}=r,d=Dr(o.shape,i.shape,a,l,u),f=new ZW(d);return n.runWebGLProgram(f,[o,i],"float32")}const fV={kernelName:gC,backendName:"webgl",kernelFunc:dV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pV(t){const{inputs:e,backend:n,attrs:r}=t,{x:o,dy:i}=e,{strides:a,pad:u,filterShape:l}=r,d=Dr(o.shape,l,a,1,u),f=new oV(d);return n.runWebGLProgram(f,[o,i],"float32")}const hV={kernelName:yC,backendName:"webgl",kernelFunc:pV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mV(t){const{inputs:e,backend:n,attrs:r}=t,{dy:o,filter:i}=e,{pad:a,strides:u,inputShape:l}=r,d=Dr(l,i.shape,u,1,a),f=new iV(d);return n.runWebGLProgram(f,[o,i],"float32")}const gV={kernelName:xC,backendName:"webgl",kernelFunc:mV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yV=es+`
  return cos(x);
`,xV=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${Xo}
  return result;
`,vV=Ae({opSnippet:yV,packedOpSnippet:xV}),CV={kernelName:vC,backendName:"webgl",kernelFunc:vV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wV=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,SV=Ae({opSnippet:wV}),bV={kernelName:CC,backendName:"webgl",kernelFunc:SV};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class IV{constructor(e,n,r,o,i){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[a,u,l,d]=e,[f]=n,[p,h]=r;this.outputShape=[f,p,h,d];const g=o==="bilinear"?1:0,[y,x]=[`${u-1}.0`,`${l-1}.0`],[v,w,S]=p>1?[`${(u-1)/(p-1)}`,"(y2-y1) * height_ratio",`y1*${y} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${y}`],[I,E,R]=h>1?[`${(l-1)/(h-1)}`,"(x2-x1) * width_ratio",`x1*${x} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${x}`];this.userCode=`
      const float height_ratio = float(${v});
      const float width_ratio = float(${I});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${a}) {
          return;
        }

        float height_scale = ${w};
        float width_scale = ${E};

        float in_y = ${S};
        if( in_y < 0.0 || in_y > ${y} ) {
          setOutput(float(${i}));
          return;
        }
        float in_x = ${R};
        if( in_x < 0.0 || in_x > ${x} ) {
          setOutput(float(${i}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${g} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $V=t=>{const{inputs:e,backend:n,attrs:r}=t,{image:o,boxes:i,boxInd:a}=e,{cropSize:u,method:l,extrapolationValue:d}=r,f=new IV(o.shape,i.shape,u,l,d);return n.runWebGLProgram(f,[o,i,a],"float32")},RV={kernelName:bC,backendName:"webgl",kernelFunc:$V};var Ca;(function(t){t.Prod="*",t.Sum="+"})(Ca||(Ca={}));class Yy{constructor(e,n,r,o){this.op=e,this.outputShape=n,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const i=this.outputShape.length,a=this.op===Ca.Prod?"1.0":"0.0",u=r?a:`getX(${Qy(i,"coords",this.op)})`,l=this.outputShape[this.outputShape.length-1];let d="",f="";r?(d=o?`end != ${l-1}`:"end != 0",f=o?"end + 1":"end - 1"):(d=o?`end + pow2 < ${l}`:"end >= pow2",f=o?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${Me(i)} coords = getOutputCoords();
        int end = ${Zy(i,"coords",this.op)};
        float val = ${u};
        int pow2 = int(pow(2.0, index));
        if (${d}) {
          int idx = ${f};
          ${Zy(i,"coords",this.op)} = idx;
          val ${this.op}= getX(${Qy(i,"coords",this.op)});
        }
        setOutput(val);
      }
    `}}function Qy(t,e,n){if(t===1)return`${e}`;if(t===2)return`${e}.x, ${e}.y`;if(t===3)return`${e}.x, ${e}.y, ${e}.z`;if(t===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw new Error(`Cumulative ${n} for rank ${t} is not yet supported`)}function Zy(t,e,n){if(t===1)return`${e}`;if(t===2)return`${e}.y`;if(t===3)return`${e}.z`;if(t===4)return`${e}.w`;throw new Error(`Cumulative ${n} for rank ${t} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kS(t,e,n,r,o,i){const a=e.shape.length,u=dt([r],a);let l=e;u!=null&&(l=Ct({inputs:{x:e},backend:n,attrs:{perm:u}}));const d=ft(1,a)[0];if(d!==a-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${r}`);const f=l.shape[d];let p=Dt({inputs:{x:l},backend:n});for(let h=0;h<=Math.ceil(Math.log2(f))-1;h++){const g=new Yy(t,l.shape,!1,i),y=[[h]],x=p;p=n.runWebGLProgram(g,[p],p.dtype,y),n.disposeIntermediateTensorInfo(x)}if(o){const h=new Yy(t,l.shape,o,i),g=p;p=n.runWebGLProgram(h,[p],p.dtype),n.disposeIntermediateTensorInfo(g)}if(u!=null){const h=$a(u),g=Ct({inputs:{x:p},backend:n,attrs:{perm:h}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(l),g}return p}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EV(t){const{inputs:e,backend:n,attrs:r}=t,{x:o}=e,{axis:i,exclusive:a,reverse:u}=r;return kS(Ca.Prod,o,n,i,a,u)}const _V={kernelName:wC,backendName:"webgl",kernelFunc:EV};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PV(t){const{inputs:e,backend:n,attrs:r}=t,{x:o}=e,{axis:i,exclusive:a,reverse:u}=r;return kS(Ca.Sum,o,n,i,a,u)}const kV={kernelName:SC,backendName:"webgl",kernelFunc:PV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TV(t){const{inputs:e,backend:n,attrs:r}=t,{x:o,weights:i}=e,{size:a,binaryOutput:u}=r;if(o.shape.length===1){const l=n.readSync(o.dataId),d=n.readSync(i.dataId),f=cS(l,d,i.dtype,i.shape,a);return n.makeTensorInfo([a],i.dtype,f)}else if(o.shape.length===2){const l=n.bufferSync(o),d=n.bufferSync(i),f=DM(l,d,a,u);return n.makeTensorInfo(f.shape,i.dtype,f.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${o.shape.length}.`)}const AV={kernelName:IC,backendName:"webgl",kernelFunc:TV};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class NV{constructor(e,n,r){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=n,this.dataFormat=r,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${n};
      int offset_h = imod(h, ${n});
      int in_w = w / ${n};
      int offset_w = imod(w, ${n});
      int offset_d = (offset_h * ${n} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OV(t){const{inputs:e,backend:n,attrs:r}=t,{x:o}=e,{blockSize:i,dataFormat:a}=r,u=o.shape[0],l=a==="NHWC"?o.shape[1]:o.shape[2],d=a==="NHWC"?o.shape[2]:o.shape[3],f=a==="NHWC"?o.shape[3]:o.shape[1],p=l*i,h=d*i,g=f/(i*i),y=a==="NHWC"?[u,p,h,g]:[u,g,p,h],x=new NV(y,i,a);return n.runWebGLProgram(x,[o],o.dtype)}const DV={kernelName:$C,backendName:"webgl",kernelFunc:OV};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class TS{constructor(e,n=!1,r=null,o=!1,i=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=pt(this.outputShape.length);const a=e.filterHeight,u=e.filterWidth,l=e.outChannels/e.inChannels;let d="",f="";r&&(o?d=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:i?d=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:d=`
          float activation(float x) {
            ${r}
          }
        `,f="result = activation(result);");const p=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${d}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${l};
        int q = d2 - d1 * ${l};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${a}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${u}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${p}
        ${f}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class AS{constructor(e,n=!1,r=null,o=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=pt(this.outputShape.length);const a=e.outChannels/e.inChannels,u=e.padInfo.left,l=e.strideWidth,d=e.dilationWidth,f=e.filterHeight,p=e.filterWidth,h=p;let g=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let w=0;w<p;w++)g+=`
          vec4 xTexelC${w*2};
          int xTexelC${w*2}Ready;
          vec4 xTexelC${w*2+1};
          int xTexelC${w*2+1}Ready;
          vec4 xC${w};`;g+=`
    for (int r = 0; r < ${f}; r++) {
      `;for(let w=0;w<p;w++)g+=`
          xTexelC${w*2} = vec4(0.0);
          xTexelC${w*2}Ready = 0;
          xTexelC${w*2+1} = vec4(0.0);
          xTexelC${w*2+1}Ready = 0;
          xC${w} = vec4(0.0);`;g+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let w=0;w<(h+1)/2;w++){const S=w*2;if(g+=`
          xC = xCCorner + ${S*d};
          `,l===1){if(S<p&&(u%2===1?(g+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S}Ready == 0) {
                  xTexelC${S} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${S}.zw = vec2(0.0);
                  }
                  xTexelC${S}Ready = 1;
                }
              `,d===1&&S>0?g+=`
                xC${S} = vec4(xTexelC${S-2}.zw, xTexelC${S}.xy);
                `:g+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${S} = vec4(previous.zw, xTexelC${S}.xy);
                  } else {
                    xC${S} = vec4(0.0, 0.0, xTexelC${S}.xy);
                  }
                  `):g+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${S}Ready == 0) {
                  xTexelC${S} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${S}.zw = vec2(0.0);
                  }
                  xTexelC${S}Ready = 1;
                }

                xC${S} = xTexelC${S};
                `,S+1<p)){const I=u%2===0?kf(d):d;d%2===0&&u%2===1||d%2!==0&&u%2!==1?(g+=`
                  xCOffset = xC + imod(pads[1], 2) + ${I};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S+1}Ready == 0) {
                    xTexelC${S+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${S+1}.zw = vec2(0.0);
                    }
                    xTexelC${S+1}Ready = 1;
                  }
                  `,d>1?g+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${S+1} = vec4(previous.zw, xTexelC${S+1}.xy);
                    } else {
                     xC${S+1} = vec4(0.0, 0.0, xTexelC${S+1}.xy);
                    }
                    `:g+=`
                    xC${S+1} = vec4(xTexelC${S}.zw, xTexelC${S+1}.xy);
                    `):I===1?g+=`
                    xC${S+1} = xTexelC${S};
                    `:g+=`
                    xCOffset = xC + ${I};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S+1}Ready == 0) {
                      xTexelC${S+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${S+1}.zw = vec2(0.0);
                      }
                      xTexelC${S+1}Ready = 1;
                    }

                    xC${S+1} = xTexelC${S+1};
                    `}}else S<p&&(u%2===1?(g+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S}Ready == 0) {
                  xTexelC${S} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${S}.zw = vec2(0.0);
                  }
                  xTexelC${S}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${S+1}Ready == 0) {
                  xTexelC${S+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${S+1}.zw = vec2(0.0);
                  }
                  xTexelC${S+1}Ready = 1;
                }

                xC${S} = vec4(xTexelC${S}.zw, xTexelC${S+1}.zw);
              `,S+1<p&&(g+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${S+1} = vec4(xTexelC${S+1}.xy, final.xy);
                `)):(g+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${S}Ready == 0) {
                  xTexelC${S} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${S}.zw = vec2(0.0);
                  }
                  xTexelC${S}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S+1}Ready == 0) {
                  xTexelC${S+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${S+1}.zw = vec2(0.);
                  }
                  xTexelC${S+1}Ready = 1;
                }

                xC${S} = vec4(
                  xTexelC${S}.xy, xTexelC${S+1}.xy);
              `,S+1<p&&(g+=`
                  xC${S+1} = vec4(xTexelC${S}.zw, xTexelC${S+1}.zw);
                `)));S<p&&(g+=`
            wTexel = getW(r, ${S}, d1, q);
            dotProd += xC${S} * vec4(wTexel.xz, wTexel.xz);
          `,S+1<p&&(g+=`
              wTexel = getW(r, ${S+1}, d1, q);
              dotProd += xC${S+1} * vec4(wTexel.xz, wTexel.xz);
            `))}g+=`
    }
  `,g+=`
      }
    `;let y="",x="";r&&(o?y=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:i?y=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:y=`vec4 activation(vec4 x) {
          ${r}
        }`,x="result = activation(result);");const v=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${y}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${a};
        int q = d2 - d1 * ${a};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${g}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${v}
        ${x}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FV(t){const{inputs:e,backend:n,attrs:r}=t,{x:o,filter:i}=e,{strides:a,pad:u,dilations:l,dimRoundingMode:d}=r;let f=l;f==null&&(f=[1,1]),re(Fr(a,f),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${a} and dilations '${f}'`);const p=it(o.shape,i.shape,a,f,u,d,!0);let h;V().getBool("WEBGL_PACK_DEPTHWISECONV")&&p.strideWidth<=2&&p.outChannels/p.inChannels===1?h=new AS(p):h=new TS(p);const g=[[p.padInfo.top,p.padInfo.left],[p.strideHeight,p.strideWidth],[p.dilationHeight,p.dilationWidth],[p.inHeight,p.inWidth]];return n.runWebGLProgram(h,[o,i],"float32",g)}const LV={kernelName:RC,backendName:"webgl",kernelFunc:FV};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class MV{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const n=e.strideHeight,r=e.strideWidth,o=e.padInfo.top,i=e.padInfo.left,a=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${a} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${n} - ${o};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${i};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class BV{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const n=e.filterHeight,r=e.filterWidth,o=e.strideHeight,i=e.strideWidth,a=n-1-e.padInfo.top,u=r-1-e.padInfo.left,l=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${n}; wR++) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${n} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${l}; dm++) {
              int d2 = d1 * ${l} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UV(t){const{inputs:e,backend:n,attrs:r}=t,{x:o,dy:i}=e,{strides:a,dilations:u,pad:l,dimRoundingMode:d,filterShape:f}=r,p=it(o.shape,f,a,u,l,d,!0),h=new MV(p);return n.runWebGLProgram(h,[o,i],"float32")}const WV={kernelName:EC,backendName:"webgl",kernelFunc:UV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VV(t){const{inputs:e,backend:n,attrs:r}=t,{dy:o,filter:i}=e,{strides:a,dilations:u,pad:l,dimRoundingMode:d,inputShape:f}=r,p=it(f,i.shape,a,u,l,d,!0),h=new BV(p);return n.runWebGLProgram(h,[o,i],"float32")}const zV={kernelName:_C,backendName:"webgl",kernelFunc:VV};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class GV{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HV(t){const{inputs:e,backend:n}=t,{x:r}=e,o=[...r.shape,...r.shape],i=Y(r.shape),a=ue({inputs:{x:r},backend:n,attrs:{shape:[i]}}),u=new GV(i),l=n.runWebGLProgram(u,[a],a.dtype),d=ue({inputs:{x:l},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(l),d}const jV={kernelName:PC,backendName:"webgl",kernelFunc:HV};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class XV{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:n,inWidth:r,padInfo:o,strideHeight:i,strideWidth:a,filterHeight:u,filterWidth:l,dilationHeight:d,dilationWidth:f}=e,{top:p,left:h}=o;this.userCode=`
      const ivec2 strides = ivec2(${i}, ${a});
      const ivec2 pads = ivec2(${p}, ${h});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${u}; h++) {
          int hIn = hBeg + h * ${d};

          if (hIn >= 0 && hIn < ${n}) {
            for (int w = 0; w < ${l}; w++) {
              int wIn = wBeg + w * ${f};

              if (wIn >= 0 && wIn < ${r}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qV(t){const{inputs:e,backend:n,attrs:r}=t,{x:o,filter:i}=e,{strides:a,pad:u,dilations:l}=r,d=Ia(o.shape,i.shape,a,u,"NHWC",l);let f;const p=new XV(d);f=n.runWebGLProgram(p,[o,i],"float32");const h=ue({inputs:{x:f},backend:n,attrs:{shape:d.outShape}});return n.disposeIntermediateTensorInfo(f),h}const KV={kernelName:kC,backendName:"webgl",kernelFunc:qV};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YV(t){const{inputs:e,backend:n,attrs:r}=t,{equation:o}=r,i=e,{allDims:a,summedDims:u,idDims:l}=_p(o,i.length);kp(a.length,l,i);const{path:d,steps:f}=Tp(u,l),p=f.length;let h=null,g=a.length;const y=[];for(let x=0;x<p;++x){for(const v of f[x]){const{permutationIndices:w,expandDims:S}=Pp(g,l[v]);let I;Ap(w)?I=i[v]:(I=Ct({inputs:{x:i[v]},backend:n,attrs:{perm:w}}),y.push(I));const E=I.shape.slice();for(let R=0;R<S.length;++R)E.splice(S[R],0,1);je(I.shape,E)||(I=ue({inputs:{x:I},backend:n,attrs:{shape:E}}),y.push(I)),h===null?h=I:(h=jp({inputs:{a:I,b:h},backend:n}),y.push(h))}x<p-1&&(d[x]>=0&&(h=Tl({inputs:{x:h},backend:n,attrs:{axis:d[x]-(a.length-g),keepDims:!1}}),y.push(h)),g--)}for(const x of y)x!==h&&n.disposeIntermediateTensorInfo(x);return h}const QV={kernelName:TC,backendName:"webgl",kernelFunc:YV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZV="return (x >= 0.0) ? x : (exp(x) - 1.0);",JV=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,ez=Ae({opSnippet:ZV,packedOpSnippet:JV}),tz={kernelName:Bf,backendName:"webgl",kernelFunc:ez};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nz="return (b >= 0.0) ? a : a * (b + 1.0);",rz=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,oz=t=>{const{inputs:e,backend:n}=t,{dy:r,y:o}=e,i=V().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Ji(rz,r.shape,o.shape):new Lo(nz,r.shape,o.shape);return n.runWebGLProgram(i,[r,o],r.dtype)},iz={kernelName:AC,backendName:"webgl",kernelFunc:oz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sz=`
  return vec4(equal(a, b));
`,az="return float(a == b);",uz=ut({opSnippet:az,packedOpSnippet:sz,dtype:"bool",cpuKernelImpl:UM}),lz={kernelName:OC,backendName:"webgl",kernelFunc:uz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cz=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${Sp};
  float a1 = ${bp};
  float a2 = ${Ip};
  float a3 = ${$p};
  float a4 = ${Rp};
  float a5 = ${Ep};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,dz=Ae({opSnippet:cz}),fz={kernelName:NC,backendName:"webgl",kernelFunc:dz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pz=es+`
  return exp(x);
`,hz=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,NS=Ae({opSnippet:pz,packedOpSnippet:hz,cpuKernelImpl:WM,dtype:"float32"}),mz={kernelName:DC,backendName:"webgl",kernelFunc:NS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $f(t){const{inputs:e,attrs:n,backend:r}=t,{dim:o}=n,{input:i}=e,a=i.shape.length,u=i.shape.slice();let l=o;return o<0&&(re(-(a+1)<=o,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),l=a+o+1),u.splice(l,0,1),ue({inputs:{x:i},backend:r,attrs:{shape:u}})}const gz={kernelName:FC,backendName:"webgl",kernelFunc:$f};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jy="return exp(x) - 1.0;",yz=Ae({opSnippet:Jy,packedOpSnippet:Jy,cpuKernelImpl:VM}),xz={kernelName:LC,backendName:"webgl",kernelFunc:yz};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ex{constructor(e,n,r){this.variableNames=["real","imag"];const o=n[1];this.outputShape=n;const i=r?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,a=r?`${o}.0`:"1.0";let u;if(e==="real")u="return real * expR - imag * expI;";else if(e==="imag")u="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${i};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${u}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${o});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${o}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${a};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OS(t,e,n){const r=n.texData.get(t.dataId),o=Y(t.shape),i=t.shape[t.shape.length-1],a=o/i,u=ue({inputs:{x:t},backend:n,attrs:{shape:[a,i]}}),l=u.shape,d=new ex("real",l,e),f=new ex("imag",l,e),p=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:l},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:l}],h=n.runWebGLProgram(d,p,"float32"),g=n.runWebGLProgram(f,p,"float32"),y=Mr({inputs:{real:h,imag:g},backend:n});n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(g);const x=ue({inputs:{x:y},backend:n,attrs:{shape:t.shape}});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(y),x}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vz(t){const{inputs:e,backend:n}=t,{input:r}=e;return OS(r,!1,n)}const Cz={kernelName:MC,backendName:"webgl",kernelFunc:vz};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wz{constructor(e,n){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oa(t){const{backend:e,attrs:n}=t,{shape:r,value:o}=n;let{dtype:i}=n;if(i=i||Gi(o),i==="string"){const a=nt(i,Y(r));return a.fill(o),e.makeTensorInfo(r,i,a)}else{const a=new wz(r,o),u=[[o]];return e.runWebGLProgram(a,[],i,u)}}const Sz={kernelName:Uf,backendName:"webgl",kernelFunc:Oa};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bz{constructor(e){this.variableNames=["Image"],this.outputShape=[];const n=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${n} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${n}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Iz={kernelName:BC,backendName:"webgl",kernelFunc:({inputs:t,backend:e})=>{const{image:n}=t,r=e,o=new bz(n.shape);return r.runWebGLProgram(o,[n],n.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tx="return floor(x);",$z=Ae({opSnippet:tx,packedOpSnippet:tx,cpuKernelImpl:zM}),Rz={kernelName:UC,backendName:"webgl",kernelFunc:$z};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ez=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,_z=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,Pz=ut({opSnippet:Ez,packedOpSnippet:_z,dtype:"int32"}),kz={kernelName:Wf,backendName:"webgl",kernelFunc:Pz};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Tz{constructor(e){this.variableNames=["A"];const n=St(),[r,o]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${o}.0, ${r}.0);

        vec4 values = ${n.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Az{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const n=St(),[r,o]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${o}.0, ${r}.0);
            vec4 values = ${n.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${n.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nz={kernelName:d0,backendName:"webgl",kernelFunc:Oz};let $i,Ud=V().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function Oz(t){const{inputs:e,backend:n,attrs:r}=t;let{pixels:o}=e;const{numChannels:i}=r,a=typeof HTMLVideoElement<"u"&&o instanceof HTMLVideoElement,u=typeof HTMLImageElement<"u"&&o instanceof HTMLImageElement,[l,d]=a?[o.videoWidth,o.videoHeight]:[o.width,o.height],f=[d,l],p=[d,l,i];if(u||a){const x=V().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");($i==null||x!==Ud)&&(Ud=x,$i=document.createElement("canvas").getContext("2d",{willReadFrequently:Ud})),$i.canvas.width=l,$i.canvas.height=d,$i.drawImage(o,0,0,l,d),o=$i.canvas}const h=n.makeTensorInfo(f,"int32");n.texData.get(h.dataId).usage=zt.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(h.dataId),o);const g=V().getBool("WEBGL_PACK")?new Az(p):new Tz(p),y=n.runWebGLProgram(g,[h],"int32");return n.disposeData(h.dataId),y}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dz(t){const{inputs:e,backend:n,attrs:r}=t,{x:o,filter:i,bias:a,preluActivationWeights:u}=e,{strides:l,pad:d,dataFormat:f,dilations:p,dimRoundingMode:h,activation:g,leakyreluAlpha:y}=r,x=Cn(f),v=it(o.shape,i.shape,l,p,d,h,!1,x);let w;const S=[],I=a!=null,E=u!=null,R=g==="leakyrelu",T=()=>{const D=[o,i],N=(O,_)=>{if(_==="NCHW"&&O.shape.length===1&&O.shape[0]!==1){const F=ue({inputs:{x:O},backend:n,attrs:{shape:[O.shape[0],1,1]}});return S.push(F),F}return O};if(I&&D.push(N(a,f)),E&&D.push(N(u,f)),R){const O=n.makeTensorInfo([],"float32",Hi(y,"float32"));D.push(O),S.push(O)}return D};if(v.filterHeight===1&&v.filterWidth===1&&v.dilationHeight===1&&v.dilationWidth===1&&v.strideHeight===1&&v.strideWidth===1&&(v.padInfo.type==="SAME"||v.padInfo.type==="VALID"))w=_S({x:o,filter:i,convInfo:v,backend:n,bias:a,activation:g,preluActivationWeights:u,leakyreluAlpha:y});else if(v.strideWidth<=2&&x==="channelsLast"&&V().getBool("WEBGL_EXP_CONV")){const D=g?xa(g,!0):null,N=new ES(v,I,D,E,R),O=[[v.padInfo.top,v.padInfo.left],[v.strideHeight,v.strideWidth],[v.dilationHeight,v.dilationWidth],[v.inHeight,v.inWidth]],_=T();w=n.runWebGLProgram(N,_,"float32",O)}else if(V().getBool("WEBGL_CONV_IM2COL"))w=PS({x:o,filter:i,convInfo:v,backend:n,bias:a,activation:g,preluActivationWeights:u,leakyreluAlpha:y});else{const D=g?xa(g,!1):null,N=new RS(v,I,D,E,R),O=T();w=n.runWebGLProgram(N,O,"float32")}const k=ue({inputs:{x:w},backend:n,attrs:{shape:v.outShape}});return S.push(w),S.forEach(D=>n.disposeIntermediateTensorInfo(D)),k}const Fz={kernelName:h0,backendName:"webgl",kernelFunc:Dz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lz(t){const{inputs:e,backend:n,attrs:r}=t,{x:o,filter:i,bias:a,preluActivationWeights:u}=e,{strides:l,pad:d,dilations:f,dimRoundingMode:p,activation:h,leakyreluAlpha:g}=r,y=[];let x=f;x==null&&(x=[1,1]),re(Fr(l,x),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${x}'`);const v=it(o.shape,i.shape,l,x,d,p,!0),w=V().getBool("WEBGL_PACK_DEPTHWISECONV")&&v.strideWidth<=2&&v.outChannels/v.inChannels===1,S=h?xa(h,w):null,I=[o,i],E=a!=null,R=u!=null,T=h==="leakyrelu";if(E&&I.push(a),R&&I.push(u),T){const O=n.makeTensorInfo([],"float32",Hi(g,"float32"));I.push(O),y.push(O)}let k;w?k=new AS(v,E,S,R,T):k=new TS(v,E,S,R,T);const D=[[v.padInfo.top,v.padInfo.left],[v.strideHeight,v.strideWidth],[v.dilationHeight,v.dilationWidth],[v.inHeight,v.inWidth]],N=n.runWebGLProgram(k,I,"float32",D);return y.forEach(O=>n.disposeIntermediateTensorInfo(O)),N}const Mz={kernelName:m0,backendName:"webgl",kernelFunc:Lz};class Bz{constructor(e,n,r,o){this.sliceDim=e,this.strides=n,this.paramsShape=o,this.variableNames=["x","indices"],this.outputShape=r;const i=Me(r.length);let a=`
    int index;`;for(let u=0;u<this.sliceDim;u++)a+=`
          index = round(getIndices(coords[0], ${u}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[u]};
          flattenIndex += index * ${this.strides[u]};`;this.userCode=`
         void main() {
          ${i} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${a}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uz(t){const{inputs:e,backend:n}=t,{params:r,indices:o}=e,i=o.shape,a=i[i.length-1],u=Y(r.shape),[l,d,f,p]=up(r,o),h=ue({inputs:{x:o},backend:n,attrs:{shape:[d,a]}}),g=ue({inputs:{x:r},backend:n,attrs:{shape:[Y(r.shape)/f,f]}});if(n.shouldExecuteOnCPU([r,o])||r.dtype==="string"){const w=n.readSync(o.dataId),S=n.bufferSync(r),I=GM(w,S,r.dtype,d,a,f,p,r.shape,u);return n.makeTensorInfo(l,r.dtype,I.values)}const y=new Bz(a,p,[d,f],r.shape),x=n.runWebGLProgram(y,[g,h],g.dtype),v=ue({inputs:{x},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(x),v}const Wz={kernelName:zC,backendName:"webgl",kernelFunc:Uz};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Vz{constructor(e,n){this.variableNames=["A","indices"],this.outputShape=n,this.rank=n.length;const r=Me(this.rank),o=zz(e);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${o}));
      }
    `}}function zz(t,e){const n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let o=0;o<t.length;o++)o===2?r.push("index"):r.push(`${n[o]}`);return r.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DS(t){const{inputs:e,backend:n,attrs:r}=t,{x:o,indices:i}=e,{axis:a,batchDims:u}=r,l=Je(a,o.shape)[0];if(V().get("DEBUG")){const S=n.readSync(i.dataId),I=o.shape[l];for(let E=0;E<S.length;++E){const R=S[E];re(R<=I-1&&R>=0,()=>`GatherV2: the index value ${R} is not in [0, ${I-1}]`)}}const d=Dp(o,i,l,u),f=Y(i.shape),p=[],h=ue({inputs:{x:o},backend:n,attrs:{shape:[d.batchSize,d.outerSize,d.dimSize,d.sliceSize]}}),g=ue({inputs:{x:i},backend:n,attrs:{shape:[d.batchSize,f/d.batchSize]}});p.push(h),p.push(g);const y=[d.batchSize,d.outerSize,f/d.batchSize,d.sliceSize];if(n.shouldExecuteOnCPU([o,i])||o.dtype==="string"){const S=n.bufferSync(g),I=n.bufferSync(h),E=HM(I,S,y);return p.forEach(R=>n.disposeIntermediateTensorInfo(R)),n.makeTensorInfo(d.outputShape,E.dtype,E.values)}const x=new Vz(h.shape,y),v=n.runWebGLProgram(x,[h,g],h.dtype);p.push(v);const w=ue({inputs:{x:v},backend:n,attrs:{shape:d.outputShape}});return p.forEach(S=>n.disposeIntermediateTensorInfo(S)),w}const Gz={kernelName:VC,backendName:"webgl",kernelFunc:DS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hz="return float(a > b);",jz=`
  return vec4(greaterThan(a, b));
`,Xz=ut({opSnippet:Hz,packedOpSnippet:jz,cpuKernelImpl:jM,dtype:"bool"}),qz={kernelName:GC,backendName:"webgl",kernelFunc:Xz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kz="return float(a >= b);",Yz=`
  return vec4(greaterThanEqual(a, b));
`,Qz=ut({opSnippet:Kz,packedOpSnippet:Yz,dtype:"bool",cpuKernelImpl:XM}),Zz={kernelName:HC,backendName:"webgl",kernelFunc:Qz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jz(t){const{inputs:e,backend:n}=t,{input:r}=e;return OS(r,!0,n)}const e4={kernelName:jC,backendName:"webgl",kernelFunc:Jz};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const t4="return float(!isnan(x) && !isinf(x));",n4=Ae({opSnippet:t4,dtype:"bool"}),r4={kernelName:qC,backendName:"webgl",kernelFunc:n4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const o4="return float(isinf(x));",i4=Ae({opSnippet:o4,dtype:"bool"}),s4={kernelName:KC,backendName:"webgl",kernelFunc:i4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const a4="return float(isnan(x));",u4=Ae({opSnippet:a4,dtype:"bool"}),l4={kernelName:YC,backendName:"webgl",kernelFunc:u4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const c4="return float(a < b);",d4=`
  return vec4(lessThan(a, b));
`,f4=ut({opSnippet:c4,packedOpSnippet:d4,cpuKernelImpl:qM,dtype:"bool"}),p4={kernelName:QC,backendName:"webgl",kernelFunc:f4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const h4="return float(a <= b);",m4=`
  return vec4(lessThanEqual(a, b));
`,g4=ut({opSnippet:h4,packedOpSnippet:m4,cpuKernelImpl:KM,dtype:"bool"}),y4={kernelName:ZC,backendName:"webgl",kernelFunc:g4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x4(t){const{backend:e,attrs:n}=t,{start:r,stop:o,num:i}=n,a=YM(r,o,i);return e.makeTensorInfo([a.length],"float32",a)}const v4={kernelName:JC,backendName:"webgl",kernelFunc:x4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const C4=es+`
  return x < 0.0 ? 0./0. : log(x);
`,w4=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,S4=Ae({opSnippet:C4,packedOpSnippet:w4,cpuKernelImpl:QM}),b4={kernelName:e1,backendName:"webgl",kernelFunc:S4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const I4=es+`
  return log(1.0 + x);
`,$4=Ae({opSnippet:I4}),R4={kernelName:t1,backendName:"webgl",kernelFunc:$4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const E4="return float(a >= 1.0 && b >= 1.0);",_4=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,P4=ut({opSnippet:E4,packedOpSnippet:_4,dtype:"bool"}),k4={kernelName:n1,backendName:"webgl",kernelFunc:P4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const T4="return float(!(x >= 1.0));",A4=Ae({opSnippet:T4}),N4={kernelName:r1,backendName:"webgl",kernelFunc:A4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const O4="return float(a >= 1.0 || b >= 1.0);",D4=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,F4=ut({opSnippet:O4,packedOpSnippet:D4,dtype:"bool"}),L4={kernelName:o1,backendName:"webgl",kernelFunc:F4};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class M4{constructor(e,n,r,o,i){this.variableNames=["x"],this.outputShape=[];const a=n,u=e[3]-1;this.outputShape=e;let l;const d=`float(${r}) + float(${o}) * sum`;i===.5?l=`inversesqrt(${d})`:i===1?l=`1.0/(${d})`:l=`exp(log(${d}) * float(-${i}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${a}; j <= ${a}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${u}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${l};
        setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class B4{constructor(e,n,r,o,i){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const a=n,u=e[3]-1;this.outputShape=e;let l;const d=`float(${r}) + float(${o}) * sum`;i===.5?l=`inversesqrt(${d})`:i===1?l=`1.0/(${d})`:l=`exp(log(${d}) * float(-${i}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${a};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${a}; j <= ${a}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${u}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${l};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const U4=t=>{const{inputs:e,backend:n,attrs:r}=t,{x:o}=e,{depthRadius:i,bias:a,alpha:u,beta:l}=r,d=V().getBool("WEBGL_PACK_NORMALIZATION")?new B4(o.shape,i,a,u,l):new M4(o.shape,i,a,u,l);return n.runWebGLProgram(d,[o],o.dtype)},W4={kernelName:i1,backendName:"webgl",kernelFunc:U4};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class V4{constructor(e,n,r,o,i){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=n,this.bias=r,this.alpha=o,this.beta=i,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${n})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${n} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${o}) * norm + float(${r});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${o})
                * float(${i})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${i});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const z4=t=>{const{inputs:e,backend:n,attrs:r}=t,{x:o,y:i,dy:a}=e,{depthRadius:u,bias:l,alpha:d,beta:f}=r,p=new V4(o.shape,u,l,d,f);return n.runWebGLProgram(p,[o,i,a],o.dtype)},G4={kernelName:s1,backendName:"webgl",kernelFunc:z4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H4(t,e,n,r){const o=Y(e),a=Y(t.shape)/o,u=ue({inputs:{x:t},attrs:{shape:[a,o]},backend:r}),l=qo(u,t.dtype,"max",r),d=ue({inputs:{x:l},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(u),r.disposeIntermediateTensorInfo(l),d}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FS(t){const{inputs:e,backend:n,attrs:r}=t,{x:o}=e,{reductionIndices:i,keepDims:a}=r,u=o.shape.length,l=Je(i,o.shape);let d=l;const f=dt(d,u),p=f!=null,h=n.shouldExecuteOnCPU([o]);let g=o;if(p){if(h){const I=n.texData.get(g.dataId).values,E=new Array(u);for(let k=0;k<E.length;k++)E[k]=o.shape[f[k]];const R=Gp(I,o.shape,o.dtype,f,E);g=n.makeTensorInfo(E,o.dtype);const T=n.texData.get(g.dataId);T.values=R}else g=kl(o,f,n);d=ft(d.length,u)}Ft("max",d,u);const[y,x]=Ht(g.shape,d);let v=y;a&&(v=Fn(y,l));let w;if(h){const I=n.texData.get(g.dataId).values,E=ZM(I,Y(x),v,o.dtype);w=n.makeTensorInfo(v,o.dtype);const R=n.texData.get(w.dataId);R.values=E}else w=H4(g,x,v,n);return p&&n.disposeIntermediateTensorInfo(g),w}const j4={kernelName:a1,backendName:"webgl",kernelFunc:FS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const X4=Hp+`
  return max(a, b);
`,q4=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Xo+`
  return result;
`,K4=ut({opSnippet:X4,packedOpSnippet:q4,cpuKernelImpl:JM}),Y4={kernelName:zf,backendName:"webgl",kernelFunc:K4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q4(t){const{inputs:e,backend:n,attrs:r}=t,{x:o}=e;Ta(o,"maxPool");const{filterSize:i,strides:a,pad:u,dimRoundingMode:l}=r,d=1;re(Fr(a,d),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${d}'`);const f=vn(o.shape,i,a,d,u,l);if(f.filterWidth===1&&f.filterHeight===1&&je(f.inShape,f.outShape))return Dt({inputs:{x:o},backend:n});const p=new va(f,"max",!1);return n.runWebGLProgram(p,[o],o.dtype)}const Z4={kernelName:u1,backendName:"webgl",kernelFunc:Q4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J4(t){const{inputs:e,backend:n,attrs:r}=t,{x:o}=e,{filterSize:i,strides:a,pad:u,dataFormat:l,dimRoundingMode:d}=r,f=[1,1,1],p=Zn(o.shape,i,a,f,u,d,l),h=new Xp(p,"max",!1);return n.runWebGLProgram(h,[o],o.dtype)}const eG={kernelName:c1,backendName:"webgl",kernelFunc:J4};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tG{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const n=e.strideHeight,r=e.strideWidth,o=e.dilationHeight,i=e.effectiveFilterHeight,a=e.effectiveFilterWidth,u=i-1-e.padInfo.top,l=a-1-e.padInfo.left,d=i*a-1;this.userCode=`
      const ivec2 pads = ivec2(${u}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${i};
          wR += ${o}) {
          float dyR = float(dyRCorner + wR) / ${n}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${a}; wC++) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${d} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${a} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}}class nG{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const n=e.strideDepth,r=e.strideHeight,o=e.strideWidth,i=e.dilationDepth,a=e.dilationHeight,u=e.dilationWidth,l=e.effectiveFilterDepth,d=e.effectiveFilterHeight,f=e.effectiveFilterWidth,p=l-1-e.padInfo.front,h=d-1-e.padInfo.top,g=f-1-e.padInfo.left,y=l*d*f-1;this.userCode=`
      const ivec3 pads = ivec3(${p}, ${h}, ${g});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${l};
           wD += ${i}) {
          float dyD = float(dyDCorner + wD) / ${n}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${d};
              wR += ${a}) {
            float dyR = float(dyRCorner + wR) / ${r}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${f};
                wC += ${u}) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${y} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${d} * ${f} +
                  wR * ${f} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rG(t){const{inputs:e,backend:n,attrs:r}=t,{dy:o,input:i}=e,a=i,{filterSize:u,strides:l,pad:d,dimRoundingMode:f}=r,p=[1,1,1],h=Zn(a.shape,u,l,p,d,f),g=new Xp(h,"max",!0),y=n.runWebGLProgram(g,[a],a.dtype),x=new nG(h),v=n.runWebGLProgram(x,[o,y],a.dtype);return n.disposeIntermediateTensorInfo(y),v}const oG={kernelName:d1,backendName:"webgl",kernelFunc:rG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iG(t){const{inputs:e,backend:n,attrs:r}=t,{dy:o,input:i,output:a}=e,u=i;Ta([i,a],"maxPoolGrad");const{filterSize:l,strides:d,pad:f,dimRoundingMode:p}=r,h=vn(u.shape,l,d,1,f,p),g=!0,y=new va(h,"max",g),x=n.runWebGLProgram(y,[u],u.dtype),v=new tG(h),w=n.runWebGLProgram(v,[o,x],u.dtype);return n.disposeIntermediateTensorInfo(x),w}const sG={kernelName:l1,backendName:"webgl",kernelFunc:iG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aG(t,e,n,r){let o=new va(n,"max",!1);const i=r.runWebGLProgram(o,[t],"float32");o=new va(n,"max",!0,!0,e);const a=r.runWebGLProgram(o,[t],"float32");return[i,a]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uG={kernelName:f1,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:r}=t,{filterSize:o,strides:i,pad:a,includeBatchInIndex:u}=e,l=n;re(r.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);const d=[1,1];re(Fr(i,d),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${d}'`);const f=vn(r.shape,o,i,d,a),[p,h]=aG(r,u,f,l);return[p,h]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lG(t,e,n,r){const o=Y(e),a=Y(t.shape)/o,u=ue({inputs:{x:t},attrs:{shape:[a,o]},backend:r}),l=qo(u,"float32","mean",r),d=ue({inputs:{x:l},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(u),r.disposeIntermediateTensorInfo(l),d}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cG={kernelName:p1,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:r}=t,{keepDims:o,axis:i}=e,a=n,u=r.shape.length,l=Je(i,r.shape);let d=l;const f=dt(d,u),p=f!=null,h=a.shouldExecuteOnCPU([r]),g=[];let y=r;if(p){if(h){const E=a.texData.get(y.dataId).values,R=new Array(u);for(let D=0;D<R.length;D++)R[D]=r.shape[f[D]];const T=Gp(E,r.shape,r.dtype,f,R);y=a.makeTensorInfo(R,r.dtype);const k=a.texData.get(y.dataId);k.values=T}else y=kl(r,f,a);g.push(y),d=ft(d.length,u)}Ft("sum",d,u);const[x,v]=Ht(y.shape,d);let w=x;o&&(w=Fn(x,l));const S=lG(y,v,w,a);for(const I of g)a.disposeIntermediateTensorInfo(I);return S}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dG(t){const{inputs:e,backend:n,attrs:r}=t,{x:o}=e,{axis:i,keepDims:a}=r,u=o.shape.length,l=Je(i,o.shape);let d=l;const f=dt(d,u);let p=o;f!=null&&(p=Ct({inputs:{x:o},backend:n,attrs:{perm:f}}),d=ft(d.length,o.shape.length)),Ft("min",d,u);const[h,g]=Ht(p.shape,d),y=Y(g),x=ue({inputs:{x:p},backend:n,attrs:{shape:[-1,y]}}),v=qo(x,x.dtype,"min",n);let w;if(a){const S=Fn(h,l);w=ue({inputs:{x:v},backend:n,attrs:{shape:S}})}else w=ue({inputs:{x:v},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(v),f!=null&&n.disposeIntermediateTensorInfo(p),w}const fG={kernelName:h1,backendName:"webgl",kernelFunc:dG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pG=Hp+`
  return min(a, b);
`,hG=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Xo+`
  return result;
`,mG=ut({opSnippet:pG,packedOpSnippet:hG,cpuKernelImpl:eB}),gG={kernelName:m1,backendName:"webgl",kernelFunc:mG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yG{constructor(e,n,r){this.variableNames=["x"],this.outputShape=n.map((f,p)=>f[0]+e[p]+f[1]);const o=e.length,i=Me(o),a=n.map(f=>f[0]).join(","),u=n.map((f,p)=>f[0]+e[p]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,o),d=r==="reflect"?0:1;if(o===1){this.userCode=`
        int start = ${a};
        int end = ${u};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${d};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${d};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${i} start = ${i}(${a});
      ${i} end = ${i}(${u});

      void main() {
        ${i} outC = getOutputCoords();
        for (int i = 0; i < ${o}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${d};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${d};
          }
        }
        ${i} coords = outC - start;
        setOutput(getX(${l}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xG{constructor(e,n,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n.map((y,x)=>y[0]+e[x]+y[1]);const o=e.length,i=Me(o),a=n.map(y=>y[0]).join(","),u=n.map((y,x)=>y[0]+e[x]).join(","),l=vt("rc",o),d=vt("source",o),f=`${l[o-1]} < ${this.outputShape[o-1]}`,p=o===1?"source":`vec2(${d.slice(-2).join()})`,h=r==="reflect"?0:1;let g="";if(o===1){const y=`
        ${i} source = rc;
        if (source < start) {
          source = start * 2 - source - ${h};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${h};
        }
        source -= start;
      `;g=`
        ${i} rc = outputLoc;
        ${y}
        result[0] = getChannel(getX(${d.join()}), ${p});
        ${l[o-1]} += 1;
        if(${f}) {
          ${y}
          result[1] = getChannel(getX(${d.join()}), ${p});
        }
      `}else{const y=`
        ${i} source = rc;
        ${i} lt = ${i}(lessThan(source, start));
        ${i} gte = ${i}(greaterThanEqual(source, end));
        ${i} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${h}) +
                gte * ((end - 1) * 2 - source + ${h});
        source -= start;
      `;g=`
        ${i} rc = outputLoc;
        ${y}
        result[0] = getChannel(getX(${d.join()}), ${p});
        ${l[o-1]} += 1;
        if(${f}) {
          ${y}
          result[1] = getChannel(getX(${d.join()}), ${p});
        }
        rc = outputLoc;
        ${l[o-2]} += 1;
        if(${l[o-2]} < ${this.outputShape[o-2]}) {
          ${y}
          result[2] = getChannel(getX(${d.join()}), ${p});
          ${l[o-1]} += 1;
          if(${f}) {
            ${y}
            result[3] = getChannel(getX(${d.join()}), ${p});
          }
        }
      `}this.userCode=`
      const ${i} start = ${i}(${a});
      const ${i} end = ${i}(${u});

      void main() {
        ${i} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${g}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vG=({inputs:t,backend:e,attrs:n})=>{const{x:r}=t,{paddings:o,mode:i}=n,a=V().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new xG(r.shape,o,i):new yG(r.shape,o,i);return e.runWebGLProgram(a,[r],r.dtype)},CG={kernelName:g1,backendName:"webgl",kernelFunc:vG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wG=`if (b == 0.0) return NAN;
  return mod(a, b);`,SG=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+Xo+`
  return result;
`,bG=ut({opSnippet:wG,packedOpSnippet:SG}),IG={kernelName:y1,backendName:"webgl",kernelFunc:bG};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $G{constructor(e,n,r){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,r],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${n-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${n-1}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RG=`
if (a == b) {
  return 1.0;
};
return a / b;`,EG=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,LS=ut({opSnippet:RG,packedOpSnippet:EG,checkOutOfBounds:!0}),_G={kernelName:Mf,backendName:"webgl",kernelFunc:LS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nx="return a - b;",MS=ut({opSnippet:nx,packedOpSnippet:nx,supportsComplex:!0,cpuKernelImpl:wB}),PG={kernelName:Jf,backendName:"webgl",kernelFunc:MS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BS(t){const{inputs:e,backend:n,attrs:r}=t,{logits:o}=e,{dim:i}=r,a=Je([i],o.shape),u=FS({inputs:{x:o},backend:n,attrs:{reductionIndices:a,keepDims:!1}}),l=Fn(u.shape,a),d=ue({inputs:{x:u},backend:n,attrs:{shape:l}}),f=MS({inputs:{a:o,b:d},backend:n}),p=NS({inputs:{x:f},backend:n}),h=Tl({inputs:{x:p},backend:n,attrs:{axis:a,keepDims:!1}}),g=ue({inputs:{x:h},backend:n,attrs:{shape:l}}),y=LS({inputs:{a:p,b:g},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(g),y}const kG={kernelName:Y1,backendName:"webgl",kernelFunc:BS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TG(t){const{inputs:e,backend:n,attrs:r}=t,{logits:o}=e,{numSamples:i,seed:a,normalized:u}=r,l=u?o:BS({inputs:{logits:o},backend:n,attrs:{dim:o.shape.length-1}}),d=l.shape[0],f=l.shape[1],p=new $G(d,f,i),h=[[a]],g=n.runWebGLProgram(p,[l],"int32",h);return u||n.disposeIntermediateTensorInfo(l),g}const AG={kernelName:x1,backendName:"webgl",kernelFunc:TG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NG=nn+`
  return -x;
`,OG=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function DG(t){const{inputs:e,backend:n}=t,{x:r}=e;if(n.shouldExecuteOnCPU([r])){const i=n.texData.get(r.dataId),[a,u]=nB(i.values,r.shape,r.dtype);return n.makeTensorInfo(u,r.dtype,a)}let o;return V().getBool("WEBGL_PACK_UNARY_OPERATIONS")?o=new kr(r.shape,OG):o=new An(r.shape,NG),n.runWebGLProgram(o,[r],r.dtype)}const FG={kernelName:v1,backendName:"webgl",kernelFunc:DG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LG=H0;function MG(t){yn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:r}=t,{boxes:o,scores:i}=e,{maxOutputSize:a,iouThreshold:u,scoreThreshold:l}=r,d=n.readSync(o.dataId),f=n.readSync(i.dataId),{selectedIndices:p}=LG(d,f,a,u,l);return n.makeTensorInfo([p.length],"int32",new Int32Array(p))}const BG={kernelName:w1,backendName:"webgl",kernelFunc:MG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UG=_R;function WG(t){yn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:r}=t,{boxes:o,scores:i}=e,{maxOutputSize:a,iouThreshold:u,scoreThreshold:l,padToMaxOutputSize:d}=r,f=n.readSync(o.dataId),p=n.readSync(i.dataId),{selectedIndices:h,validOutputs:g}=UG(f,p,a,u,l,d);return[n.makeTensorInfo([h.length],"int32",new Int32Array(h)),n.makeTensorInfo([],"int32",new Int32Array([g]))]}const VG={kernelName:II,backendName:"webgl",kernelFunc:WG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zG=j0;function GG(t){yn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:r}=t,{boxes:o,scores:i}=e,{maxOutputSize:a,iouThreshold:u,scoreThreshold:l,softNmsSigma:d}=r,f=n.readSync(o.dataId),p=n.readSync(i.dataId),h=a,g=u,y=l,x=d,{selectedIndices:v,selectedScores:w}=zG(f,p,h,g,y,x);return[n.makeTensorInfo([v.length],"int32",new Int32Array(v)),n.makeTensorInfo([w.length],"float32",new Float32Array(w))]}const HG={kernelName:S1,backendName:"webgl",kernelFunc:GG};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jG{constructor(e,n,r,o){this.variableNames=["indices"],this.outputShape=[e,n],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${o}), float(${r}),
                      float(index == coords.y)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XG=t=>{const{inputs:e,backend:n,attrs:r}=t,{indices:o}=e,{dtype:i,depth:a,onValue:u,offValue:l}=r,d=Y(o.shape),f=new jG(d,a,u,l),p=ue({inputs:{x:o},backend:n,attrs:{shape:[d]}}),h=n.runWebGLProgram(f,[p],i);n.disposeIntermediateTensorInfo(p);const g=[...o.shape,a],y=ue({inputs:{x:h},backend:n,attrs:{shape:g}});return n.disposeIntermediateTensorInfo(h),y},qG={kernelName:I1,backendName:"webgl",kernelFunc:XG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ml(t){const{inputs:e,backend:n}=t,{x:r}=e;if(r.dtype==="complex64"){const o=Na({inputs:{input:r},backend:n}),i=ml({inputs:{x:o},backend:n}),a=Al({inputs:{input:r},backend:n}),u=ml({inputs:{x:a},backend:n}),l=Mr({inputs:{real:i,imag:u},backend:n});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(u),l}else return Oa({attrs:{shape:r.shape,dtype:r.dtype,value:r.dtype==="string"?"":0},backend:n})}const KG={kernelName:tp,backendName:"webgl",kernelFunc:ml};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function US(t){const{inputs:e,backend:n}=t,{x:r}=e;if(r.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(r.dtype==="complex64"){const o=Na({inputs:{input:r},backend:n}),i=US({inputs:{x:o},backend:n}),a=Al({inputs:{input:r},backend:n}),u=ml({inputs:{x:a},backend:n}),l=Mr({inputs:{real:i,imag:u},backend:n});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(u),l}else return Oa({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:n})}const YG={kernelName:b1,backendName:"webgl",kernelFunc:US};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QG(t){const{inputs:e,backend:n,attrs:r}=t,{axis:o}=r;if(e.length===1)return $f({inputs:{input:e[0]},backend:n,attrs:{dim:o}});const i=e[0].shape,a=e[0].dtype;e.forEach(f=>{Tf(i,f.shape,"All tensors passed to stack must have matching shapes"),re(a===f.dtype,()=>"All tensors passed to stack must have matching dtypes")});const u=[],l=e.map(f=>{const p=$f({inputs:{input:f},backend:n,attrs:{dim:o}});return u.push(p),p}),d=$S({inputs:l,backend:n,attrs:{axis:o}});return u.forEach(f=>n.disposeIntermediateTensorInfo(f)),d}const ZG={kernelName:$1,backendName:"webgl",kernelFunc:QG};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class JG{constructor(e,n,r){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=n.map((d,f)=>d[0]+e[f]+d[1]);const o=e.length,i=Me(o),a=n.map(d=>d[0]).join(","),u=n.map((d,f)=>d[0]+e[f]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,o);if(o===1){this.userCode=`
        int start = ${a};
        int end = ${u};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${i} start = ${i}(${a});
      ${i} end = ${i}(${u});

      void main() {
        ${i} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${i} coords = outC - start;
          setOutput(getX(${l}));
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class eH{constructor(e,n,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=n.map((x,v)=>x[0]+e[v]+x[1]);const o=e.length,i=Me(o),a=n.map(x=>x[0]).join(","),u=n.map((x,v)=>x[0]+e[v]).join(","),l=vt("rc",o),d=vt("source",o),f=`${l[o-1]} < ${this.outputShape[o-1]}`,p=o===1?"source":`vec2(${d.slice(-2).join()})`,h=[`${i} rc = outputLoc;`,`${l[o-1]} += 1;
       if(${f}) {
      `,o===1?"":`}
       rc = outputLoc;
       ${l[o-2]} += 1;
       if(${l[o-2]} < ${this.outputShape[o-2]}) {`,o===1?"":`  ${l[o-1]} += 1;
         if(${f}) {`],g=o===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let y="";for(let x=0,v=o===1?2:4;x<v;x++)y+=`
        ${h[x]}
        if (${g}) {
          result[${x}] = float(value);
        } else {
          ${i} source = rc - start;
          result[${x}] = getChannel(getX(${d.join()}), ${p});
        }
      `;y+=o===1?"} ":"}}",this.userCode=`
      const ${i} start = ${i}(${a});
      const ${i} end = ${i}(${u});

      void main() {
        ${i} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${y}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WS=t=>{const{inputs:e,backend:n,attrs:r}=t,{x:o}=e,{paddings:i,constantValue:a}=r;if(Y(o.shape)===0){const d=i.map((f,p)=>f[0]+o.shape[p]+f[1]);return Oa({backend:n,attrs:{shape:d,value:a,dtype:o.dtype}})}const u=V().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new eH(o.shape,i,a):new JG(o.shape,i,a),l=[[a]];return n.runWebGLProgram(u,[o],o.dtype,l)},tH={kernelName:R1,backendName:"webgl",kernelFunc:WS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nH=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,rH=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+Xo+`
  return result;
`,oH=ut({opSnippet:nH,packedOpSnippet:rH}),iH={kernelName:Hf,backendName:"webgl",kernelFunc:oH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sH(t){const{inputs:e,backend:n,attrs:r}=t,{x:o}=e,{axis:i,keepDims:a}=r,u=o.shape.length,l=[],d=Je(i,o.shape);let f=d;const p=dt(f,u);let h=o;p!=null&&(h=Ct({inputs:{x:o},backend:n,attrs:{perm:p}}),f=ft(f.length,u),l.push(h)),Ft("prod",f,u);let g;if(n.shouldExecuteOnCPU([h])){const y=n.texData.get(h.dataId).values,{outVals:x,outShape:v,outDtype:w}=oB(h.shape,h.dtype,y,f);g=n.makeTensorInfo(v,w,x)}else{const[y,x]=Ht(h.shape,f),v=Y(x),w=ue({inputs:{x:h},backend:n,attrs:{shape:[-1,v]}}),S=wl(o.dtype),I=qo(w,S,"prod",n);g=ue({inputs:{x:I},backend:n,attrs:{shape:y}}),l.push(w),l.push(I)}if(a){l.push(g);const y=Fn(g.shape,d);g=ue({inputs:{x:g},backend:n,attrs:{shape:y}})}return l.forEach(y=>n.disposeIntermediateTensorInfo(y)),g}const aH={kernelName:E1,backendName:"webgl",kernelFunc:sH};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uH(t){const{inputs:e,backend:n,attrs:r}=t,{paramsNestedSplits:o,paramsDenseValues:i,indices:a}=e,{outputRaggedRank:u}=r,l=o.map(w=>n.readSync(w.dataId)),d=o.map(w=>w.shape),f=n.readSync(i.dataId),p=n.readSync(a.dataId),[h,g,y]=iB(l,d,f,i.shape,i.dtype,p,a.shape,u),x=h.map(w=>n.makeTensorInfo([w.length],"int32",w)),v=n.makeTensorInfo(y,i.dtype,g);return x.concat([v])}const lH={kernelName:$I,backendName:"webgl",kernelFunc:uH};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cH(t){const{inputs:e,backend:n}=t,{starts:r,limits:o,deltas:i}=e,a=n.readSync(r.dataId),u=n.readSync(o.dataId),l=n.readSync(i.dataId),[d,f]=sB(a,r.shape,r.dtype,u,o.shape,l,i.shape),p=n.makeTensorInfo([d.length],"int32",d),h=n.makeTensorInfo([f.length],r.dtype,f);return[p,h]}const dH={kernelName:RI,backendName:"webgl",kernelFunc:cH};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fH(t){const{inputs:e,backend:n,attrs:r}=t,{shape:o,values:i,defaultValue:a,rowPartitionTensors:u}=e,{rowPartitionTypes:l}=r,d=n.readSync(o.dataId),f=n.readSync(i.dataId),p=n.readSync(a.dataId),h=u.map(v=>n.readSync(v.dataId)),g=u.map(v=>v.shape),[y,x]=aB(d,o.shape,f,i.shape,i.dtype,p,a.shape,h,g,l);return n.makeTensorInfo(y,i.dtype,x)}const pH={kernelName:EI,backendName:"webgl",kernelFunc:fH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VS=t=>{const{backend:e,attrs:n}=t,{start:r,stop:o,step:i,dtype:a}=n,u=uB(r,o,i,a);return e.makeTensorInfo([u.length],a,u)},hH={kernelName:_1,backendName:"webgl",kernelFunc:VS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mH="return 1.0 / x;",gH=Ae({opSnippet:mH}),yH={kernelName:k1,backendName:"webgl",kernelFunc:gH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xH=nn+`
  return (x < 0.0) ? 0.0 : x;
`,vH=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,CH=Ae({opSnippet:xH,packedOpSnippet:vH}),wH={kernelName:Xf,backendName:"webgl",kernelFunc:CH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SH=nn+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,bH=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,IH=Ae({opSnippet:SH,packedOpSnippet:bH}),$H={kernelName:Kf,backendName:"webgl",kernelFunc:IH};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class RH{constructor(e,n,r,o,i){this.variableNames=["A"],this.outputShape=[];const[a,u,l,d]=e;this.outputShape=[a,n,r,d];const f=[o&&n>1?u-1:u,o&&r>1?l-1:l],p=[o&&n>1?n-1:n,o&&r>1?r-1:r];let h;i?h="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":h="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${f[0]/p[0]},
          ${f[1]/p[1]});
      const vec2 inputShapeRC = vec2(${u}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${h};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class EH{constructor(e,n,r,o,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[a,u,l,d]=e;this.outputShape=[a,n,r,d];const f=[o&&n>1?u-1:u,o&&r>1?l-1:l],p=[o&&n>1?n-1:n,o&&r>1?r-1:r];let h;i?h="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":h="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${f[0]/p[0]},
          ${f[1]/p[1]},
          ${f[1]/p[1]});
      const vec3 inputShapeRC = vec3(${u}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${h};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${d-1};
        bool hasNextRow = coords.z < ${r-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _H(t){const{inputs:e,backend:n,attrs:r}=t,{images:o}=e,{alignCorners:i,halfPixelCenters:a,size:u}=r,[l,d]=u,f=V().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new EH(o.shape,l,d,i,a):new RH(o.shape,l,d,i,a);return n.runWebGLProgram(f,[o],"float32")}const PH={kernelName:N1,backendName:"webgl",kernelFunc:_H};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kH{constructor(e,n,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=n;const[,o,i]=n,[,a,u]=e,l=[r&&a>1?o-1:o,r&&u>1?i-1:i],d=[r&&a>1?a-1:a,r&&u>1?u-1:u],f=l[0]/d[0],p=l[1]/d[1],h=1/f,g=1/p,y=Math.ceil(h)*2+2,x=Math.ceil(g)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${f});
        const float widthScale = float(${p});

        const float invHeightScale = float(${h});
        const float invWidthScale = float(${g});

        const int winHeight = int(${y});
        const int winWidth = int(${x});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${u}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${o-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${i-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TH(t){const{inputs:e,backend:n,attrs:r}=t,{images:o,dy:i}=e,{alignCorners:a}=r,u=new kH(i.shape,o.shape,a);return n.runWebGLProgram(u,[i],i.dtype)}const AH={kernelName:O1,backendName:"webgl",kernelFunc:TH};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class NH{constructor(e,n,r,o,i){this.variableNames=["A"],this.outputShape=[];const[a,u,l,d]=e;this.outputShape=[a,n,r,d];const f=[o&&n>1?u-1:u,o&&r>1?l-1:l],p=[o&&n>1?n-1:n,o&&r>1?r-1:r],h=o?"0.5":"0.0";let g;i?g="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":g="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${f[0]/p[0]},
          ${f[1]/p[1]});
      const vec2 inputShapeRC = vec2(${u}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${g};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${h})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class OH{constructor(e,n,r,o,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[a,u,l,d]=e;this.outputShape=[a,n,r,d];const f=[o&&n>1?u-1:u,o&&r>1?l-1:l],p=[o&&n>1?n-1:n,o&&r>1?r-1:r],h=o?"0.5":"0.0";let g;i?g="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":g="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${f[0]/p[0]},
          ${f[1]/p[1]},
          ${f[1]/p[1]});
      const vec3 inputShapeRC = vec3(${u}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${g};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${h})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${d-1};
        bool hasNextRow = coords.z < ${r-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DH(t){const{inputs:e,backend:n,attrs:r}=t,{images:o}=e,{alignCorners:i,halfPixelCenters:a,size:u}=r,[l,d]=u,f=V().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new OH(o.shape,l,d,i,a):new NH(o.shape,l,d,i,a);return n.runWebGLProgram(f,[o],o.dtype)}const FH={kernelName:T1,backendName:"webgl",kernelFunc:DH};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class LH{constructor(e,n,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=n;const[,o,i]=n,[,a,u]=e,l=[r&&a>1?o-1:o,r&&u>1?i-1:i],d=[r&&a>1?a-1:a,r&&u>1?u-1:u],f=l[0]/d[0],p=l[1]/d[1],h=1/f,g=1/p,y=Math.ceil(h)*2+2,x=Math.ceil(g)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${f});
        const float widthScale = float(${p});

        const float invHeightScale = float(${h});
        const float invWidthScale = float(${g});

        const int winHeight = int(${y});
        const int winWidth = int(${x});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${u}) {
              continue;
            }

            float sourceFracRow =
              float(${l[0]}) *
                (float(dyR) / float(${d[0]}));

            float sourceFracCol =
                float(${l[1]}) *
                  (float(dyC) / float(${d[1]}));

            int sourceNearestRow = int(min(
                float(int(${o}) - 1),
                ${r} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${i}) - 1),
                ${r} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MH(t){const{inputs:e,backend:n,attrs:r}=t,{images:o,dy:i}=e,{alignCorners:a}=r,u=new LH(i.shape,o.shape,a);return n.runWebGLProgram(u,[i],i.dtype)}const BH={kernelName:A1,backendName:"webgl",kernelFunc:MH};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class UH{constructor(e,n){this.variableNames=["x"];const r=e.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);if(this.outputShape=e,r===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}const o=u=>n.indexOf(u)!==-1&&e[u]!==1?`${e[u]} - coords[${u}] - 1`:`coords[${u}]`,i=e.map((u,l)=>o(l)).join(","),a=Me(r);this.userCode=`
      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${i}));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class WH{constructor(e,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const r=e.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);this.outputShape=e;const o=vt("rc",r),i=`${o[r-1]} + 1 < ${this.outputShape[r-1]}`,a=`${o[r-2]} + 1 < ${this.outputShape[r-2]}`,u=Me(r);r===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${i}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${u} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${l(o.slice())};
          if(${i}){
            result.g = ${d(o.slice())};
          }
          if(${a}) {
            result.b = ${f(o.slice())};
            if(${i}) {
              result.a = ${p(o.slice())};
            }
          }
          setOutput(result);
        }
    `;function l(y){return h(y)}function d(y){return y[r-1]="("+y[r-1]+" + 1)",h(y)}function f(y){return y[r-2]="("+y[r-2]+" + 1)",h(y)}function p(y){return y[r-1]="("+y[r-1]+" + 1)",y[r-2]="("+y[r-2]+" + 1)",h(y)}function h(y){const x=e.map((S,I)=>g(I,y)),v=x.join(","),w=x.slice(-2).join(",");return`getChannel(getX(${v}), vec2(${w}))`}function g(y,x){return n.indexOf(y)!==-1&&e[y]!==1?`${e[y]} - ${x[y]} - 1`:`${x[y]}`}}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VH(t){const{inputs:e,backend:n,attrs:r}=t,{x:o}=e,{dims:i}=r,a=o.shape.length,u=Je(i,o.shape);if(a===0)return Dt({inputs:{x:o},backend:n});const l=V().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new WH(o.shape,u):new UH(o.shape,u);return n.runWebGLProgram(l,[o],o.dtype)}const zH={kernelName:D1,backendName:"webgl",kernelFunc:VH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class GH{constructor(e,n){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const r=e[1],o=e[2];this.outputShape=e;let i="";typeof n=="number"?i=`float outputValue = ${n.toFixed(2)};`:i=`
        vec3 fill = vec3(${n.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${i}
          if(coordX >= 0 && coordX < ${o} && coordY >= 0 && coordY < ${r}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HH={kernelName:f0,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{image:r}=t,{radians:o,fillValue:i,center:a}=e,u=n,l=new GH(r.shape,i),[d,f]=yp(a,r.shape[1],r.shape[2]),p=[[d,f,Math.sin(o),Math.cos(o)]];return u.runWebGLProgram(l,[r],r.dtype,p)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jH=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,XH=Ae({opSnippet:jH}),qH={kernelName:F1,backendName:"webgl",kernelFunc:XH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KH="return inversesqrt(x);",YH=Ae({opSnippet:KH,cpuKernelImpl:lB}),QH={kernelName:L1,backendName:"webgl",kernelFunc:YH};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qp{constructor(e,n,r,o,i,a,u=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=a;const d=Me(i.length),f=Me(a.length);let p="";r===1?p="i":r===2&&(p="i, j");const h=`getIndices(${p})`;let g="";o===1?g="i":o===2&&(g="i, coords[1]");const y=`getUpdates(${g})`;let x="";l&&(x="coords[0], coords[1]");const v=`getDefaultValue(${x})`,w=n>1?"strides[j]":"strides";this.userCode=`
        ${d} strides = ${d}(${i});

        void main() {
          ${f} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${n}; j++) {
              int index = round(${h});
              flattenedIndex += index * ${w};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${y};
              found = true;
            }
          }
          setOutput(mix(${v}, sum, float(found)));
        }
      `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ZH{constructor(e,n,r,o,i,a,u=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=a;const d=Me(i.length),f=Me(a.length);let p="";r===1?p="i":r===2&&(p="i, j");const h=`getIndices(${p})`;let g="";o===1?g="i":o===2&&(g="i, coords[1]");const y=`getUpdates(${g})`;let x="";l&&(x="coords[0], coords[1]");const v=`getDefaultValue(${x})`,w=n>1?"strides[j]":"strides",S=n>1?"strides[j + 1]":"strides";this.userCode=`
        ${d} strides = ${d}(${i});

        void main() {
          ${f} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${e}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${n}; j+=2) {
              ivec4 index = round(${h});
              flattenedIndex += index.xz * ${w};
              if (j + 1 < ${n}) {
                flattenedIndex += index.yw * ${S};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${y};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${v}, sum, found));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JH(t){const{inputs:e,backend:n,attrs:r}=t,{indices:o,updates:i}=e,{shape:a}=r,{sliceRank:u,numUpdates:l,sliceSize:d,strides:f,outputSize:p}=Uo(i,o,a),h=[p/d,d];if(p===0)return n.makeTensorInfo(a,o.dtype);const g=ue({inputs:{x:o},backend:n,attrs:{shape:[l,u]}}),y=ue({inputs:{x:i},backend:n,attrs:{shape:[l,d]}}),x=n.makeTensorInfo([],"float32",new Float32Array([0]));let v;V().getBool("WEBGL_PACK")?v=new ZH(l,u,g.shape.length,y.shape.length,f,h):v=new qp(l,u,g.shape.length,y.shape.length,f,h);const w=n.runWebGLProgram(v,[y,g,x],y.dtype),S=ue({inputs:{x:w},backend:n,attrs:{shape:a}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(w),n.disposeIntermediateTensorInfo(x),S}const ej={kernelName:M1,backendName:"webgl",kernelFunc:JH};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tj{constructor(e,n,r,o){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,r];const i="while (left < right) {",a=`for (int i = 0; i < ${Math.ceil(Math.log2(n+1))}; ++i) { if (left >= right) break;`,u=V().getNumber("WEBGL_VERSION")===2?i:a,l=o==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${u}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${l} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nj(t){const{inputs:e,backend:n,attrs:r}=t,{sortedSequence:o,values:i}=e,{side:a}=r,u=new tj(o.shape[0],o.shape[1],i.shape[1],a),l=[[o.shape[1]]];return n.runWebGLProgram(u,[o,i],"int32",l)}const rj={kernelName:U1,backendName:"webgl",kernelFunc:nj};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oj{constructor(e,n,r){this.variableNames=["c","a","b"],this.outputShape=n;let o,i;if(r>4)throw Error(`Where for rank ${r} is not yet supported`);if(r===1)i="resRC",o="resRC";else{const u=["resRC.x","resRC.y","resRC.z","resRC.w"],l=[],d=[];for(let f=0;f<n.length;f++)d.push(`${u[f]}`),f<e&&l.push(`${u[f]}`);o=l.join(),i=d.join()}const a=Me(r);this.userCode=`
      void main() {
        ${a} resRC = getOutputCoords();
        float cVal = getC(${o});
        if (cVal >= 1.0) {
          setOutput(getA(${i}));
        } else {
          setOutput(getB(${i}));
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ij(t){const{inputs:e,backend:n}=t,{condition:r,t:o,e:i}=e,a=new oj(r.shape.length,o.shape,o.shape.length);return n.runWebGLProgram(a,[r,o,i],Rt(o.dtype,i.dtype))}const sj={kernelName:W1,backendName:"webgl",kernelFunc:ij};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aj=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${Cp};
  float scale = ${wp};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,uj=Ae({opSnippet:aj}),lj={kernelName:V1,backendName:"webgl",kernelFunc:uj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cj=es+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,dj=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,fj=Ae({opSnippet:cj,packedOpSnippet:dj,cpuKernelImpl:dB}),pj={kernelName:Yf,backendName:"webgl",kernelFunc:fj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hj=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,mj=Ae({opSnippet:hj}),gj={kernelName:j1,backendName:"webgl",kernelFunc:mj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yj=es+`
  return sin(x);
`,xj=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${Xo}
  return result;
`,vj=Ae({opSnippet:yj,packedOpSnippet:xj}),Cj={kernelName:G1,backendName:"webgl",kernelFunc:vj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wj=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,Sj=Ae({opSnippet:wj}),bj={kernelName:H1,backendName:"webgl",kernelFunc:Sj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ij=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,$j=Ae({opSnippet:Ij}),Rj={kernelName:X1,backendName:"webgl",kernelFunc:$j};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ej=t=>{const{inputs:e,backend:n,attrs:r}=t,{x:o}=e,{blockShape:i,paddings:a}=r;re(o.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const u=i.reduce((w,S)=>w*S),l=[[0,0]];l.push(...a);for(let w=1+i.length;w<o.shape.length;++w)l.push([0,0]);const d=[],f=WS({inputs:{x:o},backend:n,attrs:{paddings:l,constantValue:0}}),p=Ra(f.shape,i,u,!1),h=Ea(p.length,i.length,!1),g=_a(f.shape,i,u,!1),y=ue({inputs:{x:f},backend:n,attrs:{shape:p}}),x=Ct({inputs:{x:y},backend:n,attrs:{perm:h}}),v=ue({inputs:{x},backend:n,attrs:{shape:g}});return d.push(f),d.push(y),d.push(x),d.forEach(w=>n.disposeIntermediateTensorInfo(w)),v},_j={kernelName:q1,backendName:"webgl",kernelFunc:Ej};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pj(t){const{inputs:e,backend:n}=t,{indices:r,values:o,denseShape:i,defaultValue:a}=e;if(i.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${i.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${r.shape}`);if(o.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${o.shape}`);if(a.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${a.shape}`);const u=n.readSync(r.dataId),l=n.readSync(o.dataId),d=n.readSync(i.dataId),f=n.readSync(a.dataId)[0],[p,h,g,y,x]=pB(u,r.shape,r.dtype,l,o.dtype,d,f);return[n.makeTensorInfo(h,r.dtype,p),n.makeTensorInfo([h[0]],o.dtype,g),n.makeTensorInfo([y.length],"bool",new Uint8Array(y.map(v=>Number(v)))),n.makeTensorInfo([x.length],r.dtype,new Int32Array(x))]}const kj={kernelName:_I,backendName:"webgl",kernelFunc:Pj};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tj(t){const{inputs:e,backend:n}=t,{inputIndices:r,inputShape:o,newShape:i}=e;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(o.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${o.shape}`);if(i.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const a=Array.from(n.readSync(o.dataId)),u=n.readSync(r.dataId),l=Array.from(n.readSync(i.dataId)),[d,f,p]=hB(u,r.shape,r.dtype,a,l);return[n.makeTensorInfo(f,r.dtype,d),n.makeTensorInfo([p.length],i.dtype,new Int32Array(p))]}const Aj={kernelName:PI,backendName:"webgl",kernelFunc:Tj};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nj(t){const{inputs:e,backend:n}=t,{data:r,indices:o,segmentIds:i}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${o.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${i.shape}`);const a=n.readSync(r.dataId),u=n.readSync(o.dataId),l=n.readSync(i.dataId),[d,f]=fS(a,r.shape,r.dtype,u,l,!0);return n.makeTensorInfo(f,r.dtype,d)}const Oj={kernelName:Q1,backendName:"webgl",kernelFunc:Nj};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dj(t){const{inputs:e,backend:n}=t,{data:r,indices:o,segmentIds:i}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${o.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${i.shape}`);const a=n.readSync(r.dataId),u=n.readSync(o.dataId),l=n.readSync(i.dataId),[d,f]=fS(a,r.shape,r.dtype,u,l);return n.makeTensorInfo(f,r.dtype,d)}const Fj={kernelName:Z1,backendName:"webgl",kernelFunc:Dj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lj(t){const{inputs:e,backend:n,attrs:r}=t,{sparseIndices:o,sparseValues:i,defaultValue:a}=e,{outputShape:u}=r,{sliceRank:l,numUpdates:d,sliceSize:f,strides:p,outputSize:h}=Uo(i,o,u),g=!1;if(i.dtype==="string"){const w=n.bufferSync(o),S=n.bufferSync(i),I=Yn(n.readSync(a.dataId)[0]),E=cB(w,S,u,h,f,d,l,p,I,g);return n.makeTensorInfo(u,E.dtype,E.values)}const y=new qp(d,l,o.shape.length,i.shape.length,p,[h,1],g),x=n.runWebGLProgram(y,[i,o,a],i.dtype),v=ue({inputs:{x},backend:n,attrs:{shape:u}});return n.disposeIntermediateTensorInfo(x),v}const Mj={kernelName:J1,backendName:"webgl",kernelFunc:Lj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bj(t){const{inputs:e,backend:n,attrs:r}=t,{x:o}=e,{numOrSizeSplits:i,axis:a}=r,u=Je(a,o.shape)[0],l=Np(o,i,u),d=o.shape.length,f=new Array(d).fill(0),p=o.shape.slice();return l.map(h=>{const g=[...p];g[u]=h;const y=ts({inputs:{x:o},backend:n,attrs:{begin:f,size:g}});return f[u]+=h,y})}const Uj={kernelName:K1,backendName:"webgl",kernelFunc:Bj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rx="return sqrt(x);",Wj=Ae({opSnippet:rx,packedOpSnippet:rx,cpuKernelImpl:mB}),Vj={kernelName:Qf,backendName:"webgl",kernelFunc:Wj};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zj="return x * x;",Gj=Ae({opSnippet:zj}),Hj={kernelName:t0,backendName:"webgl",kernelFunc:Gj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ox="return (a - b) * (a - b);",jj=ut({opSnippet:ox,packedOpSnippet:ox}),Xj={kernelName:e0,backendName:"webgl",kernelFunc:jj};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qj(t){const{inputs:e,backend:n,attrs:r}=t,{x:o}=e;if(o.dtype!=="string")throw new Error("Input must be of datatype string");const i=n.readSync(o.dataId),a=Or(i),u=gB(a,"string",r);return n.makeTensorInfo(o.shape,"string",u)}const Kj={kernelName:kI,backendName:"webgl",kernelFunc:qj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yj({inputs:t,attrs:e,backend:n}){const{x:r}=t,o=nn+`
    return x > 0.0 ? 1.0 : float(${e.alpha});
  `,i=new An(r.shape,o);return n.runWebGLProgram(i,[r],r.dtype)}const Qj={kernelName:np,backendName:"webgl",kernelFunc:Yj};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Zj{constructor(e,n,r){this.variableNames=["x"],this.outputShape=r;const o=r.length,i=Me(r.length),a=Me(r.length);let u="";if(o===1)u="coords * strides + begin";else{let l=0;u=r.map((d,f)=>(l++,r.length===1?`coords * strides[${f}] + begin[${f}]`:`coords[${l-1}] * strides[${f}] + begin[${f}]`)).join(",")}this.userCode=`
      ${i} begin = ${i}(${e});
      ${i} strides = ${i}(${n});

      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${u}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jj(t){const{inputs:e,backend:n,attrs:r}=t,{x:o}=e,{begin:i,end:a,strides:u,beginMask:l,endMask:d,ellipsisMask:f,newAxisMask:p,shrinkAxisMask:h}=r,{finalShapeSparse:g,finalShape:y,isIdentity:x,sliceDim0:v,isSimpleSlice:w,begin:S,end:I,strides:E}=hp(o.shape,i,a,u,l,d,f,p,h);let R;if(x)R=ue({inputs:{x:o},backend:n,attrs:{shape:y}});else if(v||w){re(o.shape.length>=1,()=>`Input must have rank at least 1, got: ${o.shape.length}`);const k=cp(S,I,E),D=ts({inputs:{x:o},backend:n,attrs:{begin:S,size:k}});R=ue({inputs:{x:D},backend:n,attrs:{shape:y}}),n.disposeIntermediateTensorInfo(D)}else if(n.shouldExecuteOnCPU([o])){const D=n.readSync(o.dataId),N=Xe(o.shape,o.dtype,D),O=yB(g,N,E,S);R=n.makeTensorInfo(y,o.dtype,O.values)}else{const D=new Zj(S,E,g);R=n.runWebGLProgram(D,[o],o.dtype)}const T=ue({inputs:{x:R},backend:n,attrs:{shape:y}});return n.disposeIntermediateTensorInfo(R),T}const e6={kernelName:n0,backendName:"webgl",kernelFunc:Jj};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t6(t){const{inputs:e,backend:n,attrs:r}=t,{separator:o,nGramWidths:i,leftPad:a,rightPad:u,padWidth:l,preserveShortSequences:d}=r,{data:f,dataSplits:p}=e,h=n.readSync(f.dataId),g=n.readSync(p.dataId),[y,x]=xB(h,g,o,i,a,u,l,d);return[n.makeTensorInfo([y.length],"string",y),n.makeTensorInfo(p.shape,"int32",x)]}const n6={kernelName:r0,backendName:"webgl",kernelFunc:t6};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r6(t){const{inputs:e,backend:n,attrs:r}=t,{skipEmpty:o}=r,{input:i,delimiter:a}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(i.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(a.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${a.shape}`);const u=n.readSync(i.dataId),l=n.readSync(a.dataId)[0],[d,f,p]=vB(u,l,o),h=f.length;return[n.makeTensorInfo([h,2],"int32",d),n.makeTensorInfo([h],"string",f),n.makeTensorInfo([2],"int32",new Int32Array(p))]}const o6={kernelName:TI,backendName:"webgl",kernelFunc:r6};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i6(t){const{inputs:e,backend:n,attrs:r}=t,{numBuckets:o}=r,{input:i}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(o<=0)throw new Error("Number of buckets must be at least 1");const a=n.readSync(i.dataId),u=CB(a,o);return n.makeTensorInfo(i.shape,"int32",u)}const s6={kernelName:AI,backendName:"webgl",kernelFunc:i6};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const a6="return tan(x);",u6=Ae({opSnippet:a6}),l6={kernelName:o0,backendName:"webgl",kernelFunc:u6};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const c6=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,d6=Ae({opSnippet:c6}),f6={kernelName:i0,backendName:"webgl",kernelFunc:d6};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p6(t){const{inputs:e,backend:n,attrs:r}=t,{tensor:o,indices:i,updates:a}=e,{sliceRank:u,numUpdates:l,sliceSize:d,strides:f,outputSize:p}=Uo(a,i,o.shape),h=[p/d,d];if(p===0)return n.makeTensorInfo(o.shape,i.dtype);const g=ue({inputs:{x:i},backend:n,attrs:{shape:[l,u]}}),y=ue({inputs:{x:a},backend:n,attrs:{shape:[l,d]}}),x=ue({inputs:{x:o},backend:n,attrs:{shape:h}}),v=new qp(l,u,g.shape.length,y.shape.length,f,h,!1,!0),w=n.runWebGLProgram(v,[y,g,x],x.dtype),S=ue({inputs:{x:w},backend:n,attrs:{shape:o.shape}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(w),S}const h6={kernelName:B1,backendName:"webgl",kernelFunc:p6};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class m6{constructor(e,n){this.variableNames=["A"];const r=new Array(e.length);for(let a=0;a<r.length;a++)r[a]=e[a]*n[a];this.outputShape=r,this.rank=r.length;const o=Me(this.rank),i=g6(e);this.userCode=`
      void main() {
        ${o} resRC = getOutputCoords();
        setOutput(getA(${i}));
      }
    `}}function g6(t){const e=t.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(e===1)return`imod(resRC, ${t[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let o=0;o<t.length;o++)r.push(`imod(${n[o]}, ${t[o]})`);return r.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zS(t){const{inputs:e,backend:n,attrs:r}=t,{x:o}=e,{reps:i}=r;if(o.dtype==="string"||o.shape.length>5){const l=n.readSync(o.dataId),d=o.dtype==="string"?l.map(h=>Yn(h)):l,f=Xe(o.shape,o.dtype,d),p=SB(f,i);return n.makeTensorInfo(p.shape,p.dtype,p.values)}const a=new m6(o.shape,i);return n.runWebGLProgram(a,[o],o.dtype)}const y6={kernelName:ep,backendName:"webgl",kernelFunc:zS};class x6{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}}class v6{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yr(t,e){e!==null&&t.disposeIntermediateTensorInfo(e)}function ix(t){let e=1;for(;e<t;)e*=2;return e}function C6(t){const{inputs:e,backend:n,attrs:r}=t,{x:o}=e,{k:i,sorted:a}=r,u=V().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=V().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),d=o.shape,f=d[d.length-1];if(n.shouldExecuteOnCPU([o])||f<u||i>l){const O=n.readSync(o.dataId),[_,F]=bB(O,d,o.dtype,i,a);return[n.makeTensorInfo(_.shape,_.dtype,_.values),n.makeTensorInfo(F.shape,F.dtype,F.values)]}if(i===0)return d[d.length-1]=0,[n.makeTensorInfo(d,o.dtype,[]),n.makeTensorInfo(d,"int32",[])];if(f===1)return[o,Oa({attrs:{shape:d,dtype:"int32",value:0},backend:n})];const p=n.texData.get(o.dataId),h=p!==null&&p.isPacked,g=h?n.unpackTensor(o):o,x=Y(d)/f,v=ue({inputs:{x:g},attrs:{shape:[x,f]},backend:n});h&&Yr(n,g);const w=ix(i),S=ix(f);let I=null;const E=()=>I===null?[v,v]:[v,I],R=(O,_,F)=>{const U=E(),G=new x6(F),Z=[[f],[I===null?1:0],[Number.NEGATIVE_INFINITY],[O],[_]],L=I;I=n.runWebGLProgram(G,U,"int32",Z),Yr(n,L)};for(let O=1;O<w;O*=2){const _=O*2;for(let F=O;F>=1;F/=2)R(_,F,[x,S])}for(let O=S;O>w;O/=2){const _=E(),F=new v6([x,O/2]),G=[[f],[I===null?1:0],[w]],j=I;I=n.runWebGLProgram(F,_,"int32",G),Yr(n,j);const Z=w/2,L=Z*2;for(let X=Z;X>=1;X/=2)R(L,X,I.shape)}let T=I;I=ts({inputs:{x:I},backend:n,attrs:{begin:0,size:[x,i]}}),Yr(n,T);let k=DS({inputs:{x:v,indices:I},backend:n,attrs:{axis:1,batchDims:1}});Yr(n,v);const D=d.slice(0,-1);D.push(i),T=I,I=ue({inputs:{x:I},attrs:{shape:D},backend:n}),Yr(n,T);const N=k;return k=ue({inputs:{x:k},attrs:{shape:D},backend:n}),Yr(n,N),[k,I]}const w6={kernelName:s0,backendName:"webgl",kernelFunc:C6};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class S6{constructor(e,n,r,o,i,a){this.variableNames=["Image","Transforms"],this.outputShape=a;const u=r==="nearest"?1:2;let l;switch(o){case"constant":l=1;break;case"reflect":l=2;break;case"wrap":l=3;break;case"nearest":l=4;break;default:l=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${l} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${n}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${i});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${i});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${n}));
                float mapY = mapCoord(inY, float(${e}));

                if (${u} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b6(t){const{inputs:e,backend:n,attrs:r}=t,{image:o,transforms:i}=e,{interpolation:a,fillMode:u,fillValue:l,outputShape:d}=r,[f,p,h,g]=o.shape,[y,x]=d??[p,h],v=[f,y,x,g],w=new S6(p,h,a,u,l,v);return n.runWebGLProgram(w,[o,i],"float32")}const I6={kernelName:a0,backendName:"webgl",kernelFunc:b6};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $6(t){const{inputs:e,attrs:n,backend:r}=t,{axis:o}=n,{x:i}=e;Ta(i,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const a=r.readSync(i.dataId),{outputValues:u,outputShape:l,indices:d}=IB(a,o,i.shape,i.dtype);return[r.makeTensorInfo(l,i.dtype,u),r.makeTensorInfo([d.length],"int32",d)]}const R6={kernelName:NI,backendName:"webgl",kernelFunc:$6};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E6(t){const{inputs:e,backend:n,attrs:r}=t,{value:o}=e;let{axis:i}=r;i<0&&(i+=o.shape.length);const a=o,u=a.shape.length,l=o.shape[i],d=new Array(u-1);let f=0;for(let x=0;x<u;x++)x!==i&&(d[f++]=a.shape[x]);const p=[],h=new Array(u).fill(0),g=a.shape.slice();g[i]=1;const y=new Array(l);for(let x=0;x<y.length;x++){h[i]=x;const v=ts({inputs:{x:a},backend:n,attrs:{begin:h,size:g}}),w=ue({inputs:{x:v},backend:n,attrs:{shape:d}});y[x]=w,p.push(v)}return p.forEach(x=>n.disposeIntermediateTensorInfo(x)),y}const _6={kernelName:l0,backendName:"webgl",kernelFunc:E6};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class P6{constructor(e,n){this.variableNames=["x","segmentIds"];const r=e.windowSize,o=e.batchSize,i=e.inSize,a=e.numSegments,u=a*Math.ceil(i/r);this.outputShape=[o,u];const l="0.0",d="sumValue",f=Math.floor(r/4)*4,p=r%4,h=`
        sumValue += dot(values, segFilter);
    `;let g="";i%r>0&&(g=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return initializationValue;
        }
      `);let y="";i%r>0&&(y=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${l};

      float getValue(int batch, int inIdx) {
        ${g}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${y}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${a})) * float(${r}));
        int currentSeg = int(mod(float(outIdx), float(${a})));

        float sumValue = 0.0;

        for (int i = 0; i < ${f}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${h}
        }

        int inIdx = inOffset + ${f};
        if (${p===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${h}
        } else if (${p===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${h}
        } else if (${p===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${h}
        }
        setOutput(${d});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k6(t){const{inputs:e,backend:n,attrs:r}=t,{x:o,segmentIds:i}=e,{numSegments:a}=r,u=o.shape.length,l=[];let d=0;const f=dt([d],u);let p=o;f!=null&&(p=Ct({inputs:{x:o},backend:n,attrs:{perm:f}}),l.push(p),d=ft(1,u)[0]);const h=Op(p.shape,d,a),g=Y([p.shape[d]]),y=ue({inputs:{x:p},backend:n,attrs:{shape:[-1,g]}});l.push(y);const x=wl(o.dtype),v=(E,R,T,k,D)=>{const N=E.shape[0],O=E.shape[1],_=yw(O,D),F={windowSize:_,inSize:O,batchSize:N,numSegments:D},U=new P6(F,R),G=n.compileAndRun(U,[E,T],k);if(l.push(G),G.shape[1]===D)return G;const j=VS({backend:n,attrs:{start:0,stop:D,step:1,dtype:"float32"}}),Z=zS({inputs:{x:j},backend:n,attrs:{reps:[O/_]}});return l.push(j),l.push(Z),v(G,R,Z,k,D)},w=v(y,"unsortedSegmentSum",i,x,a),S=ue({inputs:{x:w},backend:n,attrs:{shape:h}});let I=S;if(f!=null){l.push(S);const E=$a(f);I=Ct({inputs:{x:I},backend:n,attrs:{perm:E}})}return l.forEach(E=>n.disposeIntermediateTensorInfo(E)),I}const T6={kernelName:c0,backendName:"webgl",kernelFunc:k6};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const A6=[mU,yU,CU,bU,$U,_U,kU,AU,FU,MU,WU,GU,XU,QU,eW,nW,oW,uW,cW,fW,gW,bW,$W,PW,TW,LW,BW,zW,ZB,jW,QW,tV,aV,cV,fV,hV,gV,CV,bV,RV,_V,kV,AV,DV,LV,WV,zV,jV,KV,QV,tz,iz,lz,fz,mz,gz,xz,Cz,Sz,Iz,Rz,kz,Nz,Fz,Mz,Wz,Gz,qz,Zz,QB,e4,KW,r4,s4,l4,eU,p4,y4,v4,b4,R4,k4,N4,L4,W4,G4,j4,Y4,Z4,eG,oG,sG,uG,cG,fG,gG,CG,IG,AG,rU,FG,BG,VG,HG,NW,qG,YG,ZG,tH,iH,nU,aH,lH,dH,pH,hH,OW,_G,yH,wH,$H,iU,PH,AH,FH,BH,zH,HH,qH,QH,ej,rj,sj,lj,pj,gj,Cj,bj,wW,kG,Rj,_j,kj,Aj,Oj,Fj,Mj,Uj,Vj,Hj,Xj,Kj,Qj,e6,n6,o6,s6,PG,fU,l6,f6,h6,y6,w6,I6,pU,R6,_6,T6,KG];for(const t of A6)g0(t);function N6(){const[t,e]=Yu.useState(null),[n,r]=Yu.useState(null);Yu.useEffect(()=>{const a=u=>{u.origin.startsWith("https://tryli-app-production.up.railway.app")&&u.data.image&&e(u.data.image)};return window.addEventListener("message",a),()=>window.removeEventListener("message",a)},[]);const o=()=>{window.open("/webcam","_blank")},i=a=>{const u=a.target.files[0];u&&r(URL.createObjectURL(u))};return Be.jsxs("div",{style:{padding:"2rem",textAlign:"center"},children:[Be.jsx("h1",{children:"🧥 Tryli - Virtual Try-On"}),Be.jsx("p",{children:"Upload your photo or capture one using your webcam!"}),Be.jsxs("form",{children:[Be.jsx("input",{type:"file",accept:"image/*"}),Be.jsx("br",{}),Be.jsx("br",{}),Be.jsx("button",{type:"submit",children:"Try On"})]}),Be.jsx("hr",{style:{margin:"2rem 0"}}),Be.jsx("button",{onClick:o,children:"📸 Open Webcam in New Tab"}),Be.jsxs("div",{style:{marginTop:"1rem"},children:[Be.jsx("label",{htmlFor:"bodyUpload",children:Be.jsx("strong",{children:"👤 Upload Your Body Photo"})}),Be.jsx("br",{}),Be.jsx("input",{id:"bodyUpload",type:"file",accept:"image/*",onChange:i,style:{marginTop:"0.5rem"}})]}),t&&Be.jsxs(Be.Fragment,{children:[Be.jsx("h3",{children:"📸 Captured Preview:"}),Be.jsx("img",{src:t,alt:"Captured",style:{maxWidth:"100%",marginTop:"1rem"}})]}),n&&Be.jsxs(Be.Fragment,{children:[Be.jsx("h3",{children:"👤 Body Photo Preview:"}),Be.jsx("img",{src:n,alt:"Body",style:{maxWidth:"100%",marginTop:"1rem"}})]}),Be.jsx("hr",{style:{margin:"2rem 0"}}),Be.jsx("button",{onClick:()=>window.open("/tryon","_blank"),children:"🧍 Try Virtual Clothes On Body Photo"})]})}var Qr={},Zr={},Ri={},Wt={},Wd={exports:{}},Jr={},eo={},to={},an={},Vd={},sx;function Da(){return sx||(sx=1,function(t){Object.defineProperty(t,"__esModule",{value:!0}),t.LifecycleHook=t.MessageType=t.PermissionType=t.isV1Config=void 0;function e(n){return n.shopOrigin!==void 0}t.isV1Config=e,function(n){n.Dispatch="Dispatch",n.Subscribe="Subscribe"}(t.PermissionType||(t.PermissionType={})),function(n){n.GetState="getState",n.Dispatch="dispatch",n.Subscribe="subscribe",n.Unsubscribe="unsubscribe"}(t.MessageType||(t.MessageType={})),function(n){n.UpdateAction="UpdateAction",n.DispatchAction="DispatchAction"}(t.LifecycleHook||(t.LifecycleHook={}))}(Vd)),Vd}var no={},ax;function Kp(){if(ax)return no;ax=1,Object.defineProperty(no,"__esModule",{value:!0}),no.removeFromCollection=no.addAndRemoveFromCollection=void 0;function t(n,r,o){return n.push(r),function(){return e(n,r,o)}}no.addAndRemoveFromCollection=t;function e(n,r,o){var i=n.findIndex(function(a){return a===r});return i>=0?(n.splice(i,1),o&&o(r),!0):!1}return no.removeFromCollection=e,no}var zd={},Gd={},ux;function De(){return ux||(ux=1,function(t){Object.defineProperty(t,"__esModule",{value:!0}),t.ComponentType=t.Group=void 0,function(e){e.AuthCode="AuthCode",e.Button="Button",e.ButtonGroup="ButtonGroup",e.Cart="Cart",e.Client="Client",e.ContextualSaveBar="ContextualSaveBar",e.Error="Error",e.Features="Features",e.FeedbackModal="FeedbackModal",e.Fullscreen="Fullscreen",e.LeaveConfirmation="LeaveConfirmation",e.Link="Link",e.Loading="Loading",e.Menu="Menu",e.Modal="Modal",e.Navigation="Navigation",e.Performance="Performance",e.Pos="Pos",e.Print="Print",e.ResourcePicker="Resource_Picker",e.Scanner="Scanner",e.SessionToken="SessionToken",e.Share="Share",e.TitleBar="TitleBar",e.Toast="Toast",e.MarketingExternalActivityTopBar="MarketingExternalActivityTopBar"}(t.Group||(t.Group={})),function(e){e.Button="Button",e.ButtonGroup="ButtonGroup"}(t.ComponentType||(t.ComponentType={}))}(Gd)),Gd}var lx;function Fa(){return lx||(lx=1,function(t){Object.defineProperty(t,"__esModule",{value:!0}),t.throwError=t.fromAction=t.AppBridgeError=t.invalidOriginAction=t.isErrorEventName=t.permissionAction=t.networkAction=t.persistenceAction=t.unsupportedOperationAction=t.unexpectedAction=t.invalidAction=t.invalidActionType=t.invalidPayload=t.Message=t.AppActionType=t.Action=void 0;var e=Fe(),n=De(),r;(function(S){S.INVALID_ACTION="APP::ERROR::INVALID_ACTION",S.INVALID_ACTION_TYPE="APP::ERROR::INVALID_ACTION_TYPE",S.INVALID_PAYLOAD="APP::ERROR::INVALID_PAYLOAD",S.INVALID_OPTIONS="APP::ERROR::INVALID_OPTIONS",S.UNEXPECTED_ACTION="APP::ERROR::UNEXPECTED_ACTION",S.PERSISTENCE="APP::ERROR::PERSISTENCE",S.UNSUPPORTED_OPERATION="APP::ERROR::UNSUPPORTED_OPERATION",S.NETWORK="APP::ERROR::NETWORK",S.PERMISSION="APP::ERROR::PERMISSION",S.FAILED_AUTHENTICATION="APP::ERROR::FAILED_AUTHENTICATION",S.INVALID_ORIGIN="APP::ERROR::INVALID_ORIGIN"})(r=t.Action||(t.Action={})),function(S){S.INVALID_CONFIG="APP::ERROR::INVALID_CONFIG",S.MISSING_CONFIG="APP::APP_ERROR::MISSING_CONFIG",S.MISSING_APP_BRIDGE_MIDDLEWARE="APP::APP_ERROR::MISSING_APP_BRIDGE_MIDDLEWARE",S.WINDOW_UNDEFINED="APP::APP_ERROR::WINDOW_UNDEFINED",S.REDUX_REINSTANTIATED="APP::APP_ERROR::REDUX_REINSTANTIATED",S.MISSING_LOCAL_ORIGIN="APP::APP_ERROR::MISSING_LOCAL_ORIGIN",S.MISSING_HOST_PROVIDER="APP::APP_ERROR::MISSING_HOST_PROVIDER",S.MISSING_ROUTER_CONTEXT="APP::APP_ERROR::MISSING_ROUTER_CONTEXT",S.MISSING_HISTORY_BLOCK="APP::APP_ERROR::MISSING_HISTORY_BLOCK"}(t.AppActionType||(t.AppActionType={}));function o(S,I,E){var R=I.payload;return e.actionWrapper({type:S,group:n.Group.Error,payload:{action:I,message:E,type:S,id:R&&R.id?R.id:void 0}})}(function(S){S.MISSING_PAYLOAD="Missing payload",S.INVALID_PAYLOAD_ID="Id in payload is missing or invalid"})(t.Message||(t.Message={}));function i(S,I){return o(r.INVALID_PAYLOAD,S,I||"The action's payload is missing required properties or has invalid properties")}t.invalidPayload=i;function a(S,I){return e.actionWrapper({group:n.Group.Error,payload:{action:S,message:I||"The action type is invalid or unsupported",type:r.INVALID_ACTION_TYPE},type:r.INVALID_ACTION_TYPE})}t.invalidActionType=a;function u(S,I){return e.actionWrapper({group:n.Group.Error,payload:{action:S,message:I||"The action's has missing/invalid values for `group`, `type` or `version`",type:r.INVALID_ACTION},type:r.INVALID_ACTION})}t.invalidAction=u;function l(S,I){return e.actionWrapper({group:n.Group.Error,payload:{action:S,message:I||"Action cannot be called at this time",type:r.UNEXPECTED_ACTION},type:r.UNEXPECTED_ACTION})}t.unexpectedAction=l;function d(S,I){return o(r.UNSUPPORTED_OPERATION,S,I||"The action type is unsupported")}t.unsupportedOperationAction=d;function f(S,I){return o(r.PERSISTENCE,S,I||"Action cannot be persisted on server")}t.persistenceAction=f;function p(S,I){return o(r.NETWORK,S,I||"Network error")}t.networkAction=p;function h(S,I){return o(r.PERMISSION,S,I||"Action is not permitted")}t.permissionAction=h;function g(S){var I=e.findMatchInEnum(r,S);return typeof I=="string"}t.isErrorEventName=g;function y(S){return e.actionWrapper({group:n.Group.Error,payload:{message:S,type:r.INVALID_ORIGIN},type:r.INVALID_ORIGIN})}t.invalidOriginAction=y;var x=function(){function S(I){this.name="AppBridgeError",this.message=I,typeof Error.captureStackTrace=="function"?Error.captureStackTrace(this,this.constructor):this.stack=new Error(this.message).stack}return S}();t.AppBridgeError=x,x.prototype=Object.create(Error.prototype);function v(S,I,E){var R=S?I+": "+S:I,T=new x(R);return T.action=E,T.type=I,T}t.fromAction=v;function w(){for(var S=[],I=0;I<arguments.length;I++)S[I]=arguments[I];var E=S[0],R,T;throw typeof S[1]=="string"?R=S[1]:(T=S[1],R=S[2]||""),v(R,E,T)}t.throwError=w}(zd)),zd}var ro={},cx;function GS(){return cx||(cx=1,Object.defineProperty(ro,"__esModule",{value:!0}),ro.SEPARATOR=ro.PREFIX=void 0,ro.PREFIX="APP",ro.SEPARATOR="::"),ro}var ju={},dx;function HS(){if(dx)return ju;dx=1,Object.defineProperty(ju,"__esModule",{value:!0});function t(e,n){if(n==null||typeof e>"u"||!Object.prototype.isPrototypeOf.call(Object.getPrototypeOf(e),n)||n.constructor.name!=="Object"&&n.constructor.name!=="Array")return n;var r={};return Object.keys(n).forEach(function(o){var i=Object.prototype.hasOwnProperty.call(e,o);i&&typeof e[o]=="object"&&!Array.isArray(e[o])?r[o]=t(e[o],n[o]):r[o]=n[o]}),Object.keys(e).forEach(function(o){var i=Object.prototype.hasOwnProperty.call(n,o);i||(r[o]=e[o])}),Object.setPrototypeOf(r,Object.getPrototypeOf(e)),r}return ju.default=t,ju}var Ei={},fx;function O6(){if(fx)return Ei;fx=1,Object.defineProperty(Ei,"__esModule",{value:!0}),Ei.generateUuid=void 0;function t(r){return Array.from(r).map(function(o){return("00"+o.toString(16)).slice(-2)}).join("")}function e(r){if(typeof Uint8Array=="function"&&typeof window=="object"&&window.crypto){var o=new Uint8Array(r),i=window.crypto.getRandomValues(o);if(i)return i}return Array.from(new Array(r),function(){return Math.random()*255|0})}function n(){var r=64,o=e(1),i=e(2);return o[0]&=191,i[0]&=15|r,[t(e(4)),"-",t(e(2)),"-",t(i),"-",t(o),t(e(1)),"-",t(e(6))].join("")}return Ei.generateUuid=n,Ei.default=n,Ei}const D6="@shopify/app-bridge",F6="2.0.11",L6={name:D6,version:F6};var px;function Fe(){return px||(px=1,function(t){var e=an&&an.__extends||function(){var _=function(F,U){return _=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(G,j){G.__proto__=j}||function(G,j){for(var Z in j)j.hasOwnProperty(Z)&&(G[Z]=j[Z])},_(F,U)};return function(F,U){_(F,U);function G(){this.constructor=F}F.prototype=U===null?Object.create(U):(G.prototype=U.prototype,new G)}}(),n=an&&an.__assign||function(){return n=Object.assign||function(_){for(var F,U=1,G=arguments.length;U<G;U++){F=arguments[U];for(var j in F)Object.prototype.hasOwnProperty.call(F,j)&&(_[j]=F[j])}return _},n.apply(this,arguments)},r=an&&an.__spreadArrays||function(){for(var _=0,F=0,U=arguments.length;F<U;F++)_+=arguments[F].length;for(var G=Array(_),j=0,F=0;F<U;F++)for(var Z=arguments[F],L=0,X=Z.length;L<X;L++,j++)G[j]=Z[L];return G},o=an&&an.__importDefault||function(_){return _&&_.__esModule?_:{default:_}};Object.defineProperty(t,"__esModule",{value:!0}),t.NonSnakeCaseGroup=t.findMatchInEnum=t.forEachInEnum=t.getMergedProps=t.updateActionFromPayload=t.ActionSetWithChildren=t.ActionSet=t.isValidOptionalString=t.isValidOptionalNumber=t.getEventNameSpace=t.getVersion=t.actionWrapper=void 0;var i=Da(),a=Kp(),u=Fa(),l=GS(),d=o(HS()),f=De(),p=o(O6()),h=L6;function g(_){return n(n({},_),{version:y(),clientInterface:{name:h.name,version:y()}})}t.actionWrapper=g;function y(){return h.version}t.getVersion=y;function x(_,F,U){if(F.startsWith(""+l.PREFIX+l.SEPARATOR))return F;var G=O(_);if(U){var j=U.subgroups,Z=U.type;j&&j.length>0&&(G+=G.length>0?l.SEPARATOR:"",j.forEach(function(L,X){G+=""+L.toUpperCase()+(X<j.length-1?l.SEPARATOR:"")})),Z!==_&&Z&&(G+=""+(G.length>0?l.SEPARATOR:"")+Z.toUpperCase())}return G&&(G+=""+(G.length>0?l.SEPARATOR:"")+F.toUpperCase()),""+l.PREFIX+l.SEPARATOR+G}t.getEventNameSpace=x;function v(_){return _==null||typeof _=="number"}t.isValidOptionalNumber=v;function w(_){return _==null||typeof _=="string"}t.isValidOptionalString=w;var S=function(){function _(F,U,G,j){var Z=this;this.app=F,this.type=U,this.group=G,this.subgroups=[],this.subscriptions=[],F||u.throwError(u.Action.INVALID_ACTION,"Missing required `app`"),this.id=j||p.default(),this.defaultGroup=G;var L=this.set;this.set=function(){for(var X,ne=[],Q=0;Q<arguments.length;Q++)ne[Q]=arguments[Q];return Z.app.hooks?(X=Z.app.hooks).run.apply(X,r([i.LifecycleHook.UpdateAction,L,Z],ne)):L.apply(Z,ne)}}return _.prototype.set=function(){},Object.defineProperty(_.prototype,"component",{get:function(){return{id:this.id,subgroups:this.subgroups,type:this.type}},enumerable:!1,configurable:!0}),_.prototype.updateSubscription=function(F,U,G){var j=F.eventType,Z=F.callback,L=F.component,X;return X=this.subscriptions.findIndex(function(ne){return ne===F}),X>=0?this.subscriptions[X].unsubscribe():X=void 0,this.group=U,this.subgroups=G,Object.assign(L,{subgroups:this.subgroups}),this.subscribe(j,Z,L,X)},_.prototype.error=function(F){var U=this,G=[];return k(u.Action,function(j){G.push(U.subscriptions.length),U.subscribe(j,F)}),function(){var j=G.map(function(Z){return U.subscriptions[Z]});j.forEach(function(Z){a.removeFromCollection(U.subscriptions,Z,function(L){L.unsubscribe()})})}},_.prototype.subscribe=function(F,U,G,j){var Z=this,L=G||this.component,X=F.toUpperCase(),ne=typeof j=="number"?U:U.bind(this),Q;u.isErrorEventName(F)?Q=x(f.Group.Error,F,n(n({},L),{type:""})):Q=x(this.group,F,L);var H=this.app.subscribe(Q,ne,G?G.id:this.id),K={eventType:X,unsubscribe:H,callback:ne,component:L,updateSubscribe:function(J,ge){return Z.updateSubscription(K,J,ge)}};return typeof j=="number"&&j>=0&&j<this.subscriptions.length?this.subscriptions[j]=K:this.subscriptions.push(K),H},_.prototype.unsubscribe=function(F){return F===void 0&&(F=!1),E(this.subscriptions,this.defaultGroup,F),this},_}();t.ActionSet=S;var I=function(_){e(F,_);function F(){var U=_!==null&&_.apply(this,arguments)||this;return U.children=[],U}return F.prototype.unsubscribe=function(U,G){return U===void 0&&(U=!0),G===void 0&&(G=!1),E(this.subscriptions,this.defaultGroup,G),this.children.forEach(function(j){j instanceof F?j.unsubscribe(U,!U):j.unsubscribe(!U)}),this},F.prototype.getChild=function(U){var G=this.children.findIndex(function(j){return j.id===U});return G>=0?this.children[G]:void 0},F.prototype.getChildIndex=function(U){return this.children.findIndex(function(G){return G.id===U})},F.prototype.getChildSubscriptions=function(U,G){return this.subscriptions.filter(function(j){return j.component.id===U&&(!G||G===j.eventType)})},F.prototype.addChild=function(U,G,j){var Z=this,L=U.subscriptions,X=this.getChild(U.id);return X||this.children.push(U),!L||G===U.group&&j===U.subgroups?this:(L.forEach(function(ne){var Q=ne.updateSubscribe;Q(G,j)}),Object.assign(U,{group:G,subgroups:j}),U instanceof F&&U.children.forEach(function(ne){return Z.addChild(ne,G,j)}),this)},F.prototype.removeChild=function(U){var G=this;return a.removeFromCollection(this.children,this.getChild(U),function(){var j=G.subscriptions.filter(function(Z){return Z.component.id===U});j.forEach(function(Z){a.removeFromCollection(G.subscriptions,Z,function(L){L.unsubscribe()})})}),this},F.prototype.subscribeToChild=function(U,G,j){var Z=this,L=j.bind(this);if(G instanceof Array)return G.forEach(function(H){return Z.subscribeToChild(U,H,j)}),this;if(typeof G!="string")return this;var X=G.toUpperCase(),ne=this.getChildSubscriptions(U.id,X);if(ne.length>0)ne.forEach(function(H){return H.updateSubscribe(Z.group,U.subgroups)});else{var Q={id:U.id,subgroups:U.subgroups,type:U.type};this.subscribe(X,L,Q)}return this},F.prototype.getUpdatedChildActions=function(U,G){if(U.length===0){for(;G.length>0;){var j=G.pop();if(!j)break;this.removeChild(j.id)}return}for(var Z=U.filter(function(ne,Q,H){return Q===H.indexOf(ne)}),L=Z.map(function(ne){return ne.id}),X=G.filter(function(ne){return L.indexOf(ne.id)<0});X.length>0;){var j=X.pop();if(!j)break;this.removeChild(j.id)}return Z},F}(S);t.ActionSetWithChildren=I;function E(_,F,U){U===void 0&&(U=!1),_.forEach(function(G){if(U){var j=G.updateSubscribe;j(F,[])}else{var Z=G.unsubscribe;Z()}}),U||(_.length=0)}function R(_,F){var U=_.id;return U===F.id?(Object.assign(_,T(_,F)),!0):!1}t.updateActionFromPayload=R;function T(_,F){var U=d.default(_,F);if(!U){var G=Object.assign(_,F);return G}return U}t.getMergedProps=T;function k(_,F){Object.keys(_).forEach(function(U){F(_[U])})}t.forEachInEnum=k;function D(_,F){var U=Object.keys(_).find(function(G){return F===_[G]});return U?_[U]:void 0}t.findMatchInEnum=D;function N(_){return _.replace(/([A-Z])/g,function(F,U,G){return(G===0?"":"_")+F[0].toLowerCase()})}t.NonSnakeCaseGroup=[f.Group.AuthCode,f.Group.Button,f.Group.ButtonGroup,f.Group.Cart,f.Group.Error,f.Group.Features,f.Group.Fullscreen,f.Group.Link,f.Group.Loading,f.Group.Menu,f.Group.Modal,f.Group.Navigation,f.Group.Pos,f.Group.Print,f.Group.ResourcePicker,f.Group.Scanner,f.Group.SessionToken,f.Group.Share,f.Group.TitleBar,f.Group.Toast];function O(_){return t.NonSnakeCaseGroup.includes(_)?_.toUpperCase():N(_).toUpperCase()}}(an)),an}var Hd={},hx;function jS(){return hx||(hx=1,function(t){Object.defineProperty(t,"__esModule",{value:!0}),t.app=t.Action=void 0;var e=Fe(),n=De(),r;(function(i){i.APP="APP::PRINT::APP"})(r=t.Action||(t.Action={}));function o(){return e.actionWrapper({group:n.Group.Print,type:r.APP})}t.app=o}(Hd)),Hd}var jd={},Vt={},mx;function XS(){if(mx)return Vt;mx=1,Object.defineProperty(Vt,"__esModule",{value:!0}),Vt.isAppMessage=Vt.isPermitted=Vt.getPermissionKey=Vt.isFromApp=Vt.isAppBridgeAction=void 0;var t=Da(),e=GS(),n=Fe();function r(l){return l instanceof Object&&Object.prototype.hasOwnProperty.call(l,"type")&&l.type.toString().startsWith(e.PREFIX)}Vt.isAppBridgeAction=r;function o(l){return typeof l!="object"||typeof l.source!="object"?!1:typeof l.source.apiKey=="string"}Vt.isFromApp=o;function i(l){return l.replace(new RegExp("^"+e.PREFIX+e.SEPARATOR+"\\w+"+e.SEPARATOR),"")}Vt.getPermissionKey=i;function a(l,d,f){var p=d.group,h=d.type;if(!p||!Object.prototype.hasOwnProperty.call(l,p))return!1;var g=l[p];if(!g)return!1;var y=i(h);return g[y]?g[y][f]===!0:!1}Vt.isPermitted=a;function u(l){if(typeof l!="object"||!l.data||typeof l.data!="object")return!1;var d=l.data;return Object.prototype.hasOwnProperty.call(d,"type")&&n.findMatchInEnum(t.MessageType,d.type)!==void 0}return Vt.isAppMessage=u,Vt}var Xd={},gx;function qS(){return gx||(gx=1,function(t){var e={},n,r;Object.defineProperty(t,"__esModule",{value:!0}),t.isUnframed=t.isDevelopmentClient=t.isProduction=t.isDevelopment=t.isClient=t.isServer=void 0,t.isServer=typeof window>"u",t.isClient=!t.isServer,t.isDevelopment=typeof process<"u"&&e&&!1,t.isProduction=!t.isDevelopment,t.isDevelopmentClient=t.isDevelopment&&t.isClient,t.isUnframed=t.isClient&&((r=(n=window.navigator)===null||n===void 0?void 0:n.userAgent)===null||r===void 0?void 0:r.indexOf("Unframed"))>0}(Xd)),Xd}var oo={},yx;function M6(){if(yx)return oo;yx=1;var t=oo&&oo.__importDefault||function(r){return r&&r.__esModule?r:{default:r}};Object.defineProperty(oo,"__esModule",{value:!0}),oo.parsePayloadWithContext=void 0;var e=t(HS());function n(r){var o=typeof window.MobileWebView.context=="function"?window.MobileWebView.context():window.__context__;if(!o)return JSON.stringify(r);var i=e.default(r,{id:r.id,context:o,data:{payload:{context:o},context:o}});return JSON.stringify(i)}return oo.parsePayloadWithContext=n,oo}var xx;function Yp(){return xx||(xx=1,function(t){Object.defineProperty(t,"__esModule",{value:!0}),t.createTransportListener=t.fromWindow=t.fromFrame=t.Context=void 0;var e=Fa(),n=XS(),r=Da(),o=Kp(),i=qS(),a=M6();(function(f){f.Modal="Modal",f.Main="Main"})(t.Context||(t.Context={}));function u(f,p,h){var g=[];if(typeof f>"u"||!f.ownerDocument||!f.ownerDocument.defaultView)throw e.fromAction("App frame is undefined",e.AppActionType.WINDOW_UNDEFINED);var y=f.ownerDocument.defaultView;return y.addEventListener("message",function(x){if(n.isAppMessage(x)){if(x.origin!==p){var v=f.contentWindow;if(v){var w="Message origin '"+x.origin+"' does not match app origin '"+p+"'.",S=e.invalidOriginAction(w),I={type:"dispatch",payload:S};v.postMessage(I,x.origin)}return}for(var E=0,R=g;E<R.length;E++){var T=R[E];T(x)}}}),{context:h,localOrigin:p,frameWindow:f.contentWindow,hostFrame:y,dispatch:function(x){var v=f.contentWindow;v&&v.postMessage(x,p)},subscribe:function(x){return o.addAndRemoveFromCollection(g,x)}}}t.fromFrame=u;function l(f,p){var h=[];return typeof window!==void 0&&window.addEventListener("message",function(g){if(!(window===f&&!i.isUnframed||g.source!==f||!(n.isAppBridgeAction(g.data.payload)||n.isAppMessage(g))))for(var y=0,x=h;y<x.length;y++){var v=x[y];v(g)}}),{localOrigin:p,hostFrame:f,dispatch:function(g){var y;if(!((y=g.source)===null||y===void 0)&&y.host){if(i.isUnframed&&window&&window.MobileWebView){var x=a.parsePayloadWithContext({id:"unframed://fromClient",origin:p,data:g});window.MobileWebView.postMessage(x);return}var v=new URL("https://"+g.source.host).origin;f.postMessage(g,v)}},subscribe:function(g){return o.addAndRemoveFromCollection(h,g)}}}t.fromWindow=l;function d(){var f=[],p={};function h(g){function y(){if(arguments.length<2)return o.addAndRemoveFromCollection(f,{callback:arguments[0]});var x=Array.from(arguments),v=x[0],w=x[1],S=x[2],I={callback:w,id:S},E={type:v,id:S};return Object.prototype.hasOwnProperty.call(p,v)||(p[v]=[]),g&&g(r.MessageType.Subscribe,E),o.addAndRemoveFromCollection(p[v],I,function(){g&&g(r.MessageType.Unsubscribe,E)})}return y}return{createSubscribeHandler:h,handleMessage:function(g){f.forEach(function(y){return y.callback(g)})},handleActionDispatch:function(g){var y=g.type,x=g.payload,v=!1;if(Object.prototype.hasOwnProperty.call(p,y))for(var w=0,S=p[y];w<S.length;w++){var I=S[w],E=I.id,R=I.callback,T=x&&x.id===E;(T||!E)&&(R(x),v=!0)}return v}}}t.createTransportListener=d}(jd)),jd}var js={},vx;function B6(){if(vx)return js;vx=1,Object.defineProperty(js,"__esModule",{value:!0}),js.serverAppBridge=void 0;var t=Fa(),e=function(){};return js.serverAppBridge={dispatch:function(){return{}},error:function(){return e},featuresAvailable:function(){return Promise.reject(t.fromAction("Feature detection is only available on the client side.",t.AppActionType.WINDOW_UNDEFINED))},getState:function(){return Promise.reject(t.fromAction("State is only available on the client side.",t.AppActionType.WINDOW_UNDEFINED))},localOrigin:"",subscribe:function(){return e}},js}var qd={},Cx;function KS(){return Cx||(Cx=1,function(t){Object.defineProperty(t,"__esModule",{value:!0}),t.initialize=t.Action=void 0;var e=De(),n=Fe(),r;(function(i){i.INITIALIZE="APP::CLIENT::INITIALIZE"})(r=t.Action||(t.Action={}));function o(){return n.actionWrapper({group:e.Group.Client,type:r.INITIALIZE})}t.initialize=o}(qd)),qd}var Xs={},un={},wx;function YS(){if(wx)return un;wx=1,Object.defineProperty(un,"__esModule",{value:!0}),un.getWindow=un.getLocation=un.redirect=un.shouldRedirect=void 0;function t(i){return i===window}un.shouldRedirect=t;function e(i){var a=n();a&&a.assign(i)}un.redirect=e;function n(){return o()?window.location:void 0}un.getLocation=n;function r(){return o()?window:void 0}un.getWindow=r;function o(){return typeof window<"u"}return un}var Sx;function U6(){if(Sx)return Xs;Sx=1,Object.defineProperty(Xs,"__esModule",{value:!0}),Xs.handleAppPrint=void 0;var t=YS();function e(){return navigator.userAgent.indexOf("iOS")>=0}function n(){var a=t.getWindow();if(!(!a||!a.document||!a.document.body)){var u=window.document.createElement("input");return u.style.display="none",window.document.body.appendChild(u),u}}function r(){t.getWindow()&&window.print()}function o(){var a=n();a&&(a.select(),r(),a.remove())}function i(){e()?o():r()}return Xs.handleAppPrint=i,Xs}var Xu={},bx;function W6(){if(bx)return Xu;bx=1,Object.defineProperty(Xu,"__esModule",{value:!0});var t=Kp(),e=function(){function n(){this.map={}}return n.prototype.set=function(r,o){Object.prototype.hasOwnProperty.call(this.map,r)||(this.map[r]=[]);var i={handler:o,remove:function(){}},a=t.addAndRemoveFromCollection(this.map[r],i);return i={handler:o,remove:a},a},n.prototype.get=function(r){var o=this.map[r];return o?o.map(function(i){return i.handler}):void 0},n.prototype.run=function(r,o,i){for(var a=[],u=3;u<arguments.length;u++)a[u-3]=arguments[u];var l=0,d=this.get(r)||[];function f(){for(var p=[],h=0;h<arguments.length;h++)p[h]=arguments[h];var g=d[l++];return g?g(f).apply(i,p):o.apply(i,p)}return f.apply(i,a)},n}();return Xu.default=e,Xu}var Ix;function $x(){return Ix||(Ix=1,function(t){var e=to&&to.__assign||function(){return e=Object.assign||function(E){for(var R,T=1,k=arguments.length;T<k;T++){R=arguments[T];for(var D in R)Object.prototype.hasOwnProperty.call(R,D)&&(E[D]=R[D])}return E},e.apply(this,arguments)},n=to&&to.__importDefault||function(E){return E&&E.__esModule?E:{default:E}};Object.defineProperty(t,"__esModule",{value:!0}),t.createApp=t.createAppWrapper=t.createClientApp=t.WINDOW_UNDEFINED_MESSAGE=void 0;var r=Fe(),o=jS(),i=Fa(),a=Yp(),u=B6(),l=qS(),d=KS(),f=U6(),p=YS(),h=Da(),g=n(W6());t.WINDOW_UNDEFINED_MESSAGE="window is not defined. Running an app outside a browser is not supported";function y(E,R){var T=R.apiKey,k=R.host,D=R.forceRedirect,N=D===void 0?!l.isDevelopmentClient:D,O=p.getLocation();if(!(l.isUnframed||!O||!T||!k||!N||!p.shouldRedirect(E))){var _="https://"+k+"/apps/"+T+O.pathname+(O.search||"");p.redirect(_)}}function x(E){E.subscribe(o.Action.APP,f.handleAppPrint),E.dispatch(d.initialize())}t.createClientApp=function(E,R){R===void 0&&(R=[]);var T=[],k=a.createTransportListener(),D=function(N){var O=N.data,_=O.type,F=O.payload;switch(_){case"getState":{var U=T.splice(0);U.forEach(function(Z){return Z(F)});break}case"dispatch":{k.handleMessage(F);var G=k.handleActionDispatch(F);if(G)return;var j=r.findMatchInEnum(i.Action,F.type);j&&i.throwError(j,F);break}}};return E.subscribe(D),function(N){if(!N.host)throw i.fromAction("host must be provided",i.AppActionType.INVALID_CONFIG);if(!N.apiKey)throw i.fromAction("apiKey must be provided",i.AppActionType.INVALID_CONFIG);var O;try{O=v(N)}catch{var _="not a valid host, please use the value provided by Shopify";throw i.fromAction(_,i.AppActionType.INVALID_CONFIG)}var F=I(E,O),U=k.createSubscribeHandler(F);F(h.MessageType.Unsubscribe);function G(Q){return F(h.MessageType.Dispatch,Q),Q}y(E.hostFrame,O);for(var j=new g.default,Z={localOrigin:E.localOrigin,hooks:j,dispatch:function(Q){return Z.hooks?Z.hooks.run(h.LifecycleHook.DispatchAction,G,Z,Q):G(Q)},featuresAvailable:function(Q){return Z.getState("features").then(function(H){return Q?Q.reduce(function(K,J){return Object.keys(H).includes(J)&&(K[J]=H[J]),K},{}):H})},getState:function(Q){return Q&&typeof Q!="string"?Promise.resolve(void 0):new Promise(function(H){T.push(H),F(h.MessageType.GetState)}).then(function(H){var K=H;if(Q)for(var J=0,ge=Q.split(".");J<ge.length;J++){var ve=ge[J];if(K==null||typeof K!="object"||Array.isArray(K)||!Object.keys(K).includes(ve))return;K=K[ve]}return K})},subscribe:U,error:function(Q,H){var K=[];return r.forEachInEnum(i.Action,function(J){K.push(U(J,Q,H))}),function(){K.forEach(function(J){return J()})}}},L=0,X=R;L<X.length;L++){var ne=X[L];ne(j,Z)}return x(Z),Z}};function v(E){var R;return e(e({},E),{host:atob((R=E.host)===null||R===void 0?void 0:R.replace(/_/g,"/").replace(/-/g,"+"))})}function w(E,R,T){if(T===void 0&&(T=[]),!E)throw i.fromAction(t.WINDOW_UNDEFINED_MESSAGE,i.AppActionType.WINDOW_UNDEFINED);var k=p.getLocation(),D=R||k&&k.origin;if(!D)throw i.fromAction("local origin cannot be blank",i.AppActionType.MISSING_LOCAL_ORIGIN);var N=a.fromWindow(E,D),O=t.createClientApp(N,T);return O}t.createAppWrapper=w;function S(E){var R=p.getWindow();return R?w(R.top)(E):u.serverAppBridge}t.createApp=S;function I(E,R){return function(T,k){E.dispatch({payload:k,source:R,type:T})}}t.default=S}(to)),to}var Rx;function Ex(){return Rx||(Rx=1,function(t){var e=eo&&eo.__createBinding||(Object.create?function(o,i,a,u){u===void 0&&(u=a),Object.defineProperty(o,u,{enumerable:!0,get:function(){return i[a]}})}:function(o,i,a,u){u===void 0&&(u=a),o[u]=i[a]}),n=eo&&eo.__exportStar||function(o,i){for(var a in o)a!=="default"&&!i.hasOwnProperty(a)&&e(i,o,a)};Object.defineProperty(t,"__esModule",{value:!0});var r=$x();n(Da(),t),n($x(),t),t.default=r.createClientApp}(eo)),eo}var _x;function V6(){return _x||(_x=1,function(t){var e=Jr&&Jr.__createBinding||(Object.create?function(o,i,a,u){u===void 0&&(u=a),Object.defineProperty(o,u,{enumerable:!0,get:function(){return i[a]}})}:function(o,i,a,u){u===void 0&&(u=a),o[u]=i[a]}),n=Jr&&Jr.__exportStar||function(o,i){for(var a in o)a!=="default"&&!i.hasOwnProperty(a)&&e(i,o,a)};Object.defineProperty(t,"__esModule",{value:!0});var r=Ex();Object.defineProperty(t,"default",{enumerable:!0,get:function(){return r.createApp}}),n(Yp(),t),n(Ex(),t)}(Jr)),Jr}var Px;function z6(){return Px||(Px=1,Wd.exports=V6()),Wd.exports}var qs={},kx;function wn(){if(kx)return qs;kx=1,Object.defineProperty(qs,"__esModule",{value:!0}),qs.AppBridgeContext=void 0;var t=wt();return qs.AppBridgeContext=t.createContext(null),qs}const G6="2.0.5",H6={version:G6};var Tx;function j6(){return Tx||(Tx=1,function(t){var e=Wt&&Wt.__extends||function(){var p=function(h,g){return p=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(y,x){y.__proto__=x}||function(y,x){for(var v in x)x.hasOwnProperty(v)&&(y[v]=x[v])},p(h,g)};return function(h,g){p(h,g);function y(){this.constructor=h}h.prototype=g===null?Object.create(g):(y.prototype=g.prototype,new y)}}(),n=Wt&&Wt.__createBinding||(Object.create?function(p,h,g,y){y===void 0&&(y=g),Object.defineProperty(p,y,{enumerable:!0,get:function(){return h[g]}})}:function(p,h,g,y){y===void 0&&(y=g),p[y]=h[g]}),r=Wt&&Wt.__setModuleDefault||(Object.create?function(p,h){Object.defineProperty(p,"default",{enumerable:!0,value:h})}:function(p,h){p.default=h}),o=Wt&&Wt.__importStar||function(p){if(p&&p.__esModule)return p;var h={};if(p!=null)for(var g in p)g!=="default"&&Object.hasOwnProperty.call(p,g)&&n(h,p,g);return r(h,p),h},i=Wt&&Wt.__importDefault||function(p){return p&&p.__esModule?p:{default:p}};Object.defineProperty(t,"__esModule",{value:!0}),t.setClientInterfaceHook=void 0;var a=i(wt()),u=o(z6()),l=wn(),d=H6,f=function(p){e(h,p);function h(){var g=p!==null&&p.apply(this,arguments)||this;return g.app=g.appInstance,g}return Object.defineProperty(h.prototype,"appInstance",{get:function(){return this.app||(this.app=u.default(this.props.config),this.app&&this.app.hooks&&this.app.hooks.set(u.LifecycleHook.DispatchAction,t.setClientInterfaceHook)),this.app},enumerable:!1,configurable:!0}),h.prototype.render=function(){return a.default.createElement(l.AppBridgeContext.Provider,{value:this.appInstance},this.props.children)},h}(a.default.Component);t.default=f,t.setClientInterfaceHook=function(p){return function(h){return h.clientInterface={name:"@shopify/app-bridge-react",version:d.version},p(h)}}}(Wt)),Wt}var Ax;function X6(){if(Ax)return Ri;Ax=1;var t=Ri&&Ri.__importDefault||function(n){return n&&n.__esModule?n:{default:n}};Object.defineProperty(Ri,"__esModule",{value:!0});var e=t(j6());return Ri.default=e.default,Ri}var _i={},br={},ln={},Kd={},Nx;function q6(){return Nx||(Nx=1,function(t){Object.defineProperty(t,"__esModule",{value:!0}),t.respond=t.request=t.Action=void 0;var e=Fe(),n=De(),r;(function(a){a.REQUEST="APP::AUTH_CODE::REQUEST",a.RESPOND="APP::AUTH_CODE::RESPOND"})(r=t.Action||(t.Action={}));function o(a){return e.actionWrapper({group:n.Group.AuthCode,type:r.REQUEST,payload:{id:a}})}t.request=o;function i(a){return e.actionWrapper({payload:a,group:n.Group.AuthCode,type:r.RESPOND})}t.respond=i}(Kd)),Kd}var io={},Ox;function La(){return Ox||(Ox=1,function(t){var e=io&&io.__extends||function(){var p=function(h,g){return p=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(y,x){y.__proto__=x}||function(y,x){for(var v in x)x.hasOwnProperty(v)&&(y[v]=x[v])},p(h,g)};return function(h,g){p(h,g);function y(){this.constructor=h}h.prototype=g===null?Object.create(g):(y.prototype=g.prototype,new y)}}(),n=io&&io.__assign||function(){return n=Object.assign||function(p){for(var h,g=1,y=arguments.length;g<y;g++){h=arguments[g];for(var x in h)Object.prototype.hasOwnProperty.call(h,x)&&(p[x]=h[x])}return p},n.apply(this,arguments)};Object.defineProperty(t,"__esModule",{value:!0}),t.create=t.Button=t.isValidButtonProps=t.update=t.clickButton=t.Style=t.Icon=t.Action=void 0;var r=Fe(),o=De(),i;(function(p){p.CLICK="CLICK",p.UPDATE="UPDATE"})(i=t.Action||(t.Action={})),function(p){p.Print="print"}(t.Icon||(t.Icon={})),function(p){p.Danger="danger"}(t.Style||(t.Style={}));function a(p,h,g){var y=h.id,x=r.getEventNameSpace(p,i.CLICK,h),v={id:y,payload:g};return r.actionWrapper({type:x,group:p,payload:v})}t.clickButton=a;function u(p,h,g){var y=h.id,x=g.label,v=r.getEventNameSpace(p,i.UPDATE,h),w=n(n({},g),{id:y,label:x});return r.actionWrapper({type:v,group:p,payload:w})}t.update=u;function l(p){return typeof p.id=="string"&&typeof p.label=="string"}t.isValidButtonProps=l;var d=function(p){e(h,p);function h(g,y){var x=p.call(this,g,o.ComponentType.Button,o.Group.Button)||this;return x.disabled=!1,x.loading=!1,x.plain=!1,x.set(y,!1),x}return Object.defineProperty(h.prototype,"options",{get:function(){return{disabled:this.disabled,icon:this.icon,label:this.label,style:this.style,loading:this.loading,plain:this.plain}},enumerable:!1,configurable:!0}),Object.defineProperty(h.prototype,"payload",{get:function(){return n(n({},this.options),{id:this.id})},enumerable:!1,configurable:!0}),h.prototype.set=function(g,y){y===void 0&&(y=!0);var x=r.getMergedProps(this.options,g),v=x.label,w=x.disabled,S=x.icon,I=x.style,E=x.loading,R=x.plain;return this.label=v,this.disabled=!!w,this.icon=S,this.style=I,this.loading=!!E,this.plain=!!R,y&&this.dispatch(i.UPDATE),this},h.prototype.dispatch=function(g,y){switch(g){case i.CLICK:this.app.dispatch(a(this.group,this.component,y));break;case i.UPDATE:{var x=u(this.group,this.component,this.payload);this.app.dispatch(x);break}}return this},h}(r.ActionSet);t.Button=d;function f(p,h){return new d(p,h)}t.create=f}(io)),io}var so={},Ks={},Dx;function Nl(){if(Dx)return Ks;Dx=1,Object.defineProperty(Ks,"__esModule",{value:!0}),Ks.getSingleButton=void 0;var t=La();function e(n,r,o,i){return n.addChild(r,n.group,o),n.subscribeToChild(r,t.Action.UPDATE,i),r.payload}return Ks.getSingleButton=e,Ks}var Fx;function Qp(){return Fx||(Fx=1,function(t){var e=so&&so.__extends||function(){var g=function(y,x){return g=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(v,w){v.__proto__=w}||function(v,w){for(var S in w)w.hasOwnProperty(S)&&(v[S]=w[S])},g(y,x)};return function(y,x){g(y,x);function v(){this.constructor=y}y.prototype=x===null?Object.create(x):(v.prototype=x.prototype,new v)}}(),n=so&&so.__assign||function(){return n=Object.assign||function(g){for(var y,x=1,v=arguments.length;x<v;x++){y=arguments[x];for(var w in y)Object.prototype.hasOwnProperty.call(y,w)&&(g[w]=y[w])}return g},n.apply(this,arguments)};Object.defineProperty(t,"__esModule",{value:!0}),t.create=t.ButtonGroup=t.isGroupedButtonPayload=t.isGroupedButton=t.update=t.Action=void 0;var r=Nl(),o=Fe(),i=De(),a;(function(g){g.UPDATE="UPDATE"})(a=t.Action||(t.Action={}));function u(g,y,x){return h(g,y,a.UPDATE,x)}t.update=u;function l(g){var y=g;return y.buttons&&y.buttons.length>0&&y.label!==void 0}t.isGroupedButton=l;function d(g){var y=g;return Array.isArray(y.buttons)&&typeof y.id=="string"&&typeof y.label=="string"}t.isGroupedButtonPayload=d;var f=function(g){e(y,g);function y(x,v){var w=g.call(this,x,i.ComponentType.ButtonGroup,i.Group.ButtonGroup)||this;return w.disabled=!1,w.plain=!1,w.buttonsOptions=[],w.buttons=[],w.set(v,!1),w}return Object.defineProperty(y.prototype,"options",{get:function(){return{buttons:this.buttonsOptions,disabled:this.disabled,label:this.label,plain:this.plain}},enumerable:!1,configurable:!0}),Object.defineProperty(y.prototype,"payload",{get:function(){return n(n({},this.options),{buttons:this.buttons,id:this.id})},enumerable:!1,configurable:!0}),y.prototype.set=function(x,v){v===void 0&&(v=!0);var w=o.getMergedProps(this.options,x),S=w.label,I=w.disabled,E=w.buttons,R=w.plain;return this.label=S,this.disabled=!!I,this.buttons=this.getButtons(E),this.plain=!!R,v&&this.dispatch(a.UPDATE),this},y.prototype.dispatch=function(x){switch(x){case a.UPDATE:{var v=u(this.group,this.component,this.payload);this.app.dispatch(v);break}}return this},y.prototype.updateButtons=function(x){if(!(!this.buttons||this.buttons.length===0)){for(var v,w=0,S=this.buttons;w<S.length;w++){var I=S[w];if(v=o.updateActionFromPayload(I,x),v)break}v&&this.dispatch(a.UPDATE)}},y.prototype.getSingleButton=function(x){return r.getSingleButton(this,x,this.subgroups,this.updateButtons)},y.prototype.getButtons=function(x){var v=this,w=[];return x?(x.forEach(function(S){var I=r.getSingleButton(v,S,v.subgroups,v.updateButtons);w.push(I)}),this.buttonsOptions=x,w):[]},y}(o.ActionSetWithChildren);t.ButtonGroup=f;function p(g,y){return new f(g,y)}t.create=p;function h(g,y,x,v,w){var S=y.id,I=v.label,E=o.getEventNameSpace(g,x,y),R=n(n({},v),{id:S,label:I,payload:w});return o.actionWrapper({type:E,group:g,payload:R})}}(so)),so}var ao={},Lx;function K6(){return Lx||(Lx=1,function(t){var e=ao&&ao.__extends||function(){var k=function(D,N){return k=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(O,_){O.__proto__=_}||function(O,_){for(var F in _)_.hasOwnProperty(F)&&(O[F]=_[F])},k(D,N)};return function(D,N){k(D,N);function O(){this.constructor=D}D.prototype=N===null?Object.create(N):(O.prototype=N.prototype,new O)}}(),n=ao&&ao.__assign||function(){return n=Object.assign||function(k){for(var D,N=1,O=arguments.length;N<O;N++){D=arguments[N];for(var _ in D)Object.prototype.hasOwnProperty.call(D,_)&&(k[_]=D[_])}return k},n.apply(this,arguments)};Object.defineProperty(t,"__esModule",{value:!0}),t.create=t.Cart=t.setLineItemProperties=t.removeLineItemDiscount=t.setLineItemDiscount=t.removeLineItem=t.updateLineItem=t.addLineItem=t.removeProperties=t.setProperties=t.setDiscount=t.updateCustomerAddress=t.addCustomerAddress=t.setCustomer=t.update=t.fetch=t.Action=void 0;var r=Fe(),o=De(),i;(function(k){k.FETCH="APP::CART::FETCH",k.UPDATE="APP::CART::UPDATE",k.SET_CUSTOMER="APP::CART::SET_CUSTOMER",k.REMOVE_CUSTOMER="APP::CART::REMOVE_CUSTOMER",k.ADD_CUSTOMER_ADDRESS="APP::CART::ADD_CUSTOMER_ADDRESS",k.UPDATE_CUSTOMER_ADDRESS="APP::CART::UPDATE_CUSTOMER_ADDRESS",k.SET_DISCOUNT="APP::CART::SET_DISCOUNT",k.REMOVE_DISCOUNT="APP::CART::REMOVE_DISCOUNT",k.SET_PROPERTIES="APP::CART::SET_PROPERTIES",k.REMOVE_PROPERTIES="APP::CART::REMOVE_PROPERTIES",k.CLEAR="APP::CART::CLEAR",k.ADD_LINE_ITEM="APP::CART::ADD_LINE_ITEM",k.UPDATE_LINE_ITEM="APP::CART::UPDATE_LINE_ITEM",k.REMOVE_LINE_ITEM="APP::CART::REMOVE_LINE_ITEM",k.SET_LINE_ITEM_DISCOUNT="APP::CART::SET_LINE_ITEM_DISCOUNT",k.REMOVE_LINE_ITEM_DISCOUNT="APP::CART::REMOVE_LINE_ITEM_DISCOUNT",k.SET_LINE_ITEM_PROPERTIES="APP::CART::SET_LINE_ITEM_PROPERTIES",k.REMOVE_LINE_ITEM_PROPERTIES="APP::CART::REMOVE_LINE_ITEM_PROPERTIES"})(i=t.Action||(t.Action={}));function a(k,D){return D===void 0&&(D={}),r.actionWrapper({group:o.Group.Cart,type:k,payload:D})}function u(){return a(i.FETCH)}t.fetch=u;function l(k){return a(i.UPDATE,k)}t.update=l;function d(k){return a(i.SET_CUSTOMER,k)}t.setCustomer=d;function f(k){return a(i.ADD_CUSTOMER_ADDRESS,k)}t.addCustomerAddress=f;function p(k){return a(i.UPDATE_CUSTOMER_ADDRESS,k)}t.updateCustomerAddress=p;function h(k){return a(i.SET_DISCOUNT,k)}t.setDiscount=h;function g(k){return a(i.SET_PROPERTIES,k)}t.setProperties=g;function y(k){return a(i.REMOVE_PROPERTIES,k)}t.removeProperties=y;function x(k){return a(i.ADD_LINE_ITEM,k)}t.addLineItem=x;function v(k){return a(i.UPDATE_LINE_ITEM,k)}t.updateLineItem=v;function w(k){return a(i.REMOVE_LINE_ITEM,k)}t.removeLineItem=w;function S(k){return a(i.SET_LINE_ITEM_DISCOUNT,k)}t.setLineItemDiscount=S;function I(k){return a(i.REMOVE_LINE_ITEM_DISCOUNT,k)}t.removeLineItemDiscount=I;function E(k){return a(i.SET_LINE_ITEM_PROPERTIES,k)}t.setLineItemProperties=E;var R=function(k){e(D,k);function D(N,O){return k.call(this,N,o.Group.Cart,o.Group.Cart,O?O.id:void 0)||this}return D.prototype.dispatch=function(N,O){switch(N){case i.FETCH:this.dispatchCartAction(i.FETCH);break;case i.UPDATE:this.dispatchCartAction(i.UPDATE,O);break;case i.SET_CUSTOMER:this.dispatchCartAction(i.SET_CUSTOMER,O);break;case i.REMOVE_CUSTOMER:this.dispatchCartAction(i.REMOVE_CUSTOMER,O);break;case i.ADD_CUSTOMER_ADDRESS:this.dispatchCartAction(i.ADD_CUSTOMER_ADDRESS,O);break;case i.UPDATE_CUSTOMER_ADDRESS:this.dispatchCartAction(i.UPDATE_CUSTOMER_ADDRESS,O);break;case i.SET_DISCOUNT:this.dispatchCartAction(i.SET_DISCOUNT,O);break;case i.REMOVE_DISCOUNT:this.dispatchCartAction(i.REMOVE_DISCOUNT,O);break;case i.SET_PROPERTIES:this.dispatchCartAction(i.SET_PROPERTIES,O);break;case i.REMOVE_PROPERTIES:this.dispatchCartAction(i.REMOVE_PROPERTIES,O);break;case i.CLEAR:this.dispatchCartAction(i.CLEAR,O);break;case i.ADD_LINE_ITEM:this.dispatchCartAction(i.ADD_LINE_ITEM,O);break;case i.UPDATE_LINE_ITEM:this.dispatchCartAction(i.UPDATE_LINE_ITEM,O);break;case i.REMOVE_LINE_ITEM:this.dispatchCartAction(i.REMOVE_LINE_ITEM,O);break;case i.SET_LINE_ITEM_DISCOUNT:this.dispatchCartAction(i.SET_LINE_ITEM_DISCOUNT,O);break;case i.REMOVE_LINE_ITEM_DISCOUNT:this.dispatchCartAction(i.REMOVE_LINE_ITEM_DISCOUNT,O);break;case i.SET_LINE_ITEM_PROPERTIES:this.dispatchCartAction(i.SET_LINE_ITEM_PROPERTIES,O);break;case i.REMOVE_LINE_ITEM_PROPERTIES:this.dispatchCartAction(i.REMOVE_LINE_ITEM_PROPERTIES,O);break}return this},D.prototype.dispatchCartAction=function(N,O){this.app.dispatch(a(N,n(n({},O),{id:this.id})))},D}(r.ActionSet);t.Cart=R;function T(k,D){return new R(k,D)}t.create=T}(ao)),ao}var uo={},Ys={},lo={},Mx;function Rf(){return Mx||(Mx=1,function(t){var e=lo&&lo.__extends||function(){var f=function(p,h){return f=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(g,y){g.__proto__=y}||function(g,y){for(var x in y)y.hasOwnProperty(x)&&(g[x]=y[x])},f(p,h)};return function(p,h){f(p,h);function g(){this.constructor=p}p.prototype=h===null?Object.create(h):(g.prototype=h.prototype,new g)}}(),n=lo&&lo.__assign||function(){return n=Object.assign||function(f){for(var p,h=1,g=arguments.length;h<g;h++){p=arguments[h];for(var y in p)Object.prototype.hasOwnProperty.call(p,y)&&(f[y]=p[y])}return f},n.apply(this,arguments)};Object.defineProperty(t,"__esModule",{value:!0}),t.create=t.Toast=t.clear=t.show=t.Action=void 0;var r=Fe(),o=De(),i;(function(f){f.SHOW="APP::TOAST::SHOW",f.CLEAR="APP::TOAST::CLEAR"})(i=t.Action||(t.Action={}));function a(f){return r.actionWrapper({group:o.Group.Toast,payload:f,type:i.SHOW})}t.show=a;function u(f){return r.actionWrapper({payload:f,group:o.Group.Toast,type:i.CLEAR})}t.clear=u;var l=function(f){e(p,f);function p(h,g){var y=f.call(this,h,o.Group.Toast,o.Group.Toast)||this;return y.message="",y.duration=5e3,y.set(g),y}return Object.defineProperty(p.prototype,"options",{get:function(){return{duration:this.duration,isError:this.isError,message:this.message}},enumerable:!1,configurable:!0}),Object.defineProperty(p.prototype,"payload",{get:function(){return n({id:this.id},this.options)},enumerable:!1,configurable:!0}),p.prototype.set=function(h){var g=r.getMergedProps(this.options,h),y=g.message,x=g.duration,v=g.isError;return this.message=y,this.duration=x,this.isError=v,this},p.prototype.dispatch=function(h){switch(h){case i.SHOW:{var g=a(this.payload);this.app.dispatch(g);break}case i.CLEAR:this.app.dispatch(u({id:this.id}));break}return this},p}(r.ActionSet);t.Toast=l;function d(f,p){return new l(f,p)}t.create=d}(lo)),lo}var Bx;function Y6(){return Bx||(Bx=1,function(t){var e=Ys&&Ys.__extends||function(){var a=function(u,l){return a=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,f){d.__proto__=f}||function(d,f){for(var p in f)f.hasOwnProperty(p)&&(d[p]=f[p])},a(u,l)};return function(u,l){a(u,l);function d(){this.constructor=u}u.prototype=l===null?Object.create(l):(d.prototype=l.prototype,new d)}}();Object.defineProperty(t,"__esModule",{value:!0}),t.create=t.Flash=void 0;var n=Rf(),r=Rf();Object.defineProperty(t,"clear",{enumerable:!0,get:function(){return r.clear}}),Object.defineProperty(t,"show",{enumerable:!0,get:function(){return r.show}});var o=function(a){e(u,a);function u(){return a!==null&&a.apply(this,arguments)||this}return u}(n.Toast);t.Flash=o;function i(a,u){return new o(a,u)}t.create=i}(Ys)),Ys}var Ux;function Q6(){return Ux||(Ux=1,function(t){var e=uo&&uo.__createBinding||(Object.create?function(r,o,i,a){a===void 0&&(a=i),Object.defineProperty(r,a,{enumerable:!0,get:function(){return o[i]}})}:function(r,o,i,a){a===void 0&&(a=i),r[a]=o[i]}),n=uo&&uo.__exportStar||function(r,o){for(var i in r)i!=="default"&&!o.hasOwnProperty(i)&&e(o,r,i)};Object.defineProperty(t,"__esModule",{value:!0}),n(Y6(),t)}(uo)),uo}var co={},cn={},Yd={},Wx;function QS(){return Wx||(Wx=1,function(t){Object.defineProperty(t,"__esModule",{value:!0}),t.Action=void 0,function(e){e.UPDATE="APP::FEATURES::UPDATE",e.REQUEST="APP::FEATURES::REQUEST",e.REQUEST_UPDATE="APP::FEATURES::REQUEST::UPDATE"}(t.Action||(t.Action={}))}(Yd)),Yd}var Vx;function Z6(){if(Vx)return cn;Vx=1;var t=cn&&cn.__extends||function(){var u=function(l,d){return u=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(f,p){f.__proto__=p}||function(f,p){for(var h in p)p.hasOwnProperty(h)&&(f[h]=p[h])},u(l,d)};return function(l,d){u(l,d);function f(){this.constructor=l}l.prototype=d===null?Object.create(d):(f.prototype=d.prototype,new f)}}(),e=cn&&cn.__assign||function(){return e=Object.assign||function(u){for(var l,d=1,f=arguments.length;d<f;d++){l=arguments[d];for(var p in l)Object.prototype.hasOwnProperty.call(l,p)&&(u[p]=l[p])}return u},e.apply(this,arguments)};Object.defineProperty(cn,"__esModule",{value:!0}),cn.create=cn.Features=void 0;var n=Fe(),r=De(),o=QS(),i=function(u){t(l,u);function l(d,f){return u.call(this,d,r.Group.Features,r.Group.Features,f?f.id:void 0)||this}return l.prototype.dispatch=function(d,f){switch(d){case o.Action.REQUEST:this.dispatchFeaturesAction(o.Action.REQUEST,f);break}return this},l.prototype.dispatchFeaturesAction=function(d,f){this.app.dispatch(n.actionWrapper({group:r.Group.Features,type:d,payload:e(e({},f||{}),{id:this.id})}))},l}(n.ActionSet);cn.Features=i;function a(u,l){return new i(u,l)}return cn.create=a,cn}var zx;function J6(){return zx||(zx=1,function(t){var e=co&&co.__createBinding||(Object.create?function(r,o,i,a){a===void 0&&(a=i),Object.defineProperty(r,a,{enumerable:!0,get:function(){return o[i]}})}:function(r,o,i,a){a===void 0&&(a=i),r[a]=o[i]}),n=co&&co.__exportStar||function(r,o){for(var i in r)i!=="default"&&!o.hasOwnProperty(i)&&e(o,r,i)};Object.defineProperty(t,"__esModule",{value:!0}),n(Z6(),t),n(QS(),t)}(co)),co}var fo={},Gx;function eX(){return Gx||(Gx=1,function(t){var e=fo&&fo.__extends||function(){var f=function(p,h){return f=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(g,y){g.__proto__=y}||function(g,y){for(var x in y)y.hasOwnProperty(x)&&(g[x]=y[x])},f(p,h)};return function(p,h){f(p,h);function g(){this.constructor=p}p.prototype=h===null?Object.create(h):(g.prototype=h.prototype,new g)}}(),n=fo&&fo.__assign||function(){return n=Object.assign||function(f){for(var p,h=1,g=arguments.length;h<g;h++){p=arguments[h];for(var y in p)Object.prototype.hasOwnProperty.call(p,y)&&(f[y]=p[y])}return f},n.apply(this,arguments)};Object.defineProperty(t,"__esModule",{value:!0}),t.create=t.FeedbackModal=t.close=t.open=t.Action=void 0;var r=Fe(),o=De(),i;(function(f){f.OPEN="APP::FEEDBACK_MODAL::OPEN",f.CLOSE="APP::FEEDBACK_MODAL::CLOSE"})(i=t.Action||(t.Action={}));function a(f){return r.actionWrapper({group:o.Group.FeedbackModal,payload:f,type:i.OPEN})}t.open=a;function u(f){return r.actionWrapper({group:o.Group.FeedbackModal,payload:f,type:i.CLOSE})}t.close=u;var l=function(f){e(p,f);function p(h,g){var y=f.call(this,h,o.Group.FeedbackModal,o.Group.FeedbackModal)||this;return y.options=g,y.set(g),y}return Object.defineProperty(p.prototype,"payload",{get:function(){return n({id:this.id},this.options)},enumerable:!1,configurable:!0}),p.prototype.set=function(h){return this.options=r.getMergedProps(this.options,h),this},p.prototype.dispatch=function(h){switch(h){case i.OPEN:{var g=a(this.payload);this.app.dispatch(g);break}case i.CLOSE:{var y=u(this.payload);this.app.dispatch(y);break}}return this},p}(r.ActionSet);t.FeedbackModal=l;function d(f,p){return new l(f,p)}t.create=d}(fo)),fo}var Qs={},Hx;function tX(){return Hx||(Hx=1,function(t){var e=Qs&&Qs.__extends||function(){var d=function(f,p){return d=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(h,g){h.__proto__=g}||function(h,g){for(var y in g)g.hasOwnProperty(y)&&(h[y]=g[y])},d(f,p)};return function(f,p){d(f,p);function h(){this.constructor=f}f.prototype=p===null?Object.create(p):(h.prototype=p.prototype,new h)}}();Object.defineProperty(t,"__esModule",{value:!0}),t.create=t.Fullscreen=t.exit=t.enter=t.Action=void 0;var n=Fe(),r=De(),o;(function(d){d.ENTER="APP::FULLSCREEN::ENTER",d.EXIT="APP::FULLSCREEN::EXIT"})(o=t.Action||(t.Action={}));function i(){return n.actionWrapper({group:r.Group.Fullscreen,type:o.ENTER})}t.enter=i;function a(){return n.actionWrapper({group:r.Group.Fullscreen,type:o.EXIT})}t.exit=a;var u=function(d){e(f,d);function f(p){return d.call(this,p,r.Group.Fullscreen,r.Group.Fullscreen)||this}return Object.defineProperty(f.prototype,"payload",{get:function(){return{id:this.id}},enumerable:!1,configurable:!0}),f.prototype.dispatch=function(p){return this.app.dispatch(n.actionWrapper({group:this.group,type:p,payload:this.payload})),this},f}(n.ActionSet);t.Fullscreen=u;function l(d){return new u(d)}t.create=l}(Qs)),Qs}var po={},jx;function nX(){return jx||(jx=1,function(t){var e=po&&po.__extends||function(){var p=function(h,g){return p=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(y,x){y.__proto__=x}||function(y,x){for(var v in x)x.hasOwnProperty(v)&&(y[v]=x[v])},p(h,g)};return function(h,g){p(h,g);function y(){this.constructor=h}h.prototype=g===null?Object.create(g):(y.prototype=g.prototype,new y)}}(),n=po&&po.__assign||function(){return n=Object.assign||function(p){for(var h,g=1,y=arguments.length;g<y;g++){h=arguments[g];for(var x in h)Object.prototype.hasOwnProperty.call(h,x)&&(p[x]=h[x])}return p},n.apply(this,arguments)};Object.defineProperty(t,"__esModule",{value:!0}),t.create=t.LeaveConfirmation=t.confirm=t.disable=t.enable=t.Action=void 0;var r=Fe(),o=De(),i;(function(p){p.ENABLE="APP::LEAVE_CONFIRMATION::ENABLE",p.DISABLE="APP::LEAVE_CONFIRMATION::DISABLE",p.CONFIRM="APP::LEAVE_CONFIRMATION::CONFIRM"})(i=t.Action||(t.Action={}));function a(p){return p===void 0&&(p={}),r.actionWrapper({group:o.Group.LeaveConfirmation,payload:p,type:i.ENABLE})}t.enable=a;function u(p){return p===void 0&&(p={}),r.actionWrapper({group:o.Group.LeaveConfirmation,payload:p,type:i.DISABLE})}t.disable=u;function l(p){return p===void 0&&(p={}),r.actionWrapper({group:o.Group.LeaveConfirmation,payload:p,type:i.CONFIRM})}t.confirm=l;var d=function(p){e(h,p);function h(g,y){y===void 0&&(y={});var x=p.call(this,g,o.Group.LeaveConfirmation,o.Group.LeaveConfirmation)||this;return x.options=y,x.set(y),x}return Object.defineProperty(h.prototype,"payload",{get:function(){return n({id:this.id},this.options)},enumerable:!1,configurable:!0}),h.prototype.set=function(g){return this.options=r.getMergedProps(this.options,g),this},h.prototype.dispatch=function(g){switch(g){case i.ENABLE:{var y=a(this.payload);this.app.dispatch(y);break}case i.DISABLE:{var x=u(this.payload);this.app.dispatch(x);break}case i.CONFIRM:{var v=l(this.payload);this.app.dispatch(v);break}}return this},h}(r.ActionSet);t.LeaveConfirmation=d;function f(p,h){return h===void 0&&(h={}),new d(p,h)}t.create=f}(po)),po}var Zs={},Xx;function rX(){return Xx||(Xx=1,function(t){var e=Zs&&Zs.__extends||function(){var d=function(f,p){return d=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(h,g){h.__proto__=g}||function(h,g){for(var y in g)g.hasOwnProperty(y)&&(h[y]=g[y])},d(f,p)};return function(f,p){d(f,p);function h(){this.constructor=f}f.prototype=p===null?Object.create(p):(h.prototype=p.prototype,new h)}}();Object.defineProperty(t,"__esModule",{value:!0}),t.create=t.Loading=t.stop=t.start=t.Action=void 0;var n=Fe(),r=De(),o;(function(d){d.START="APP::LOADING::START",d.STOP="APP::LOADING::STOP"})(o=t.Action||(t.Action={}));function i(d){return n.actionWrapper({payload:d,group:r.Group.Loading,type:o.START})}t.start=i;function a(d){return n.actionWrapper({payload:d,group:r.Group.Loading,type:o.STOP})}t.stop=a;var u=function(d){e(f,d);function f(p){return d.call(this,p,r.Group.Loading,r.Group.Loading)||this}return Object.defineProperty(f.prototype,"payload",{get:function(){return{id:this.id}},enumerable:!1,configurable:!0}),f.prototype.dispatch=function(p){switch(p){case o.START:this.app.dispatch(i(this.payload));break;case o.STOP:this.app.dispatch(a(this.payload));break}return this},f}(n.ActionSet);t.Loading=u;function l(d){return new u(d)}t.create=l}(Zs)),Zs}var ho={},qx;function ZS(){return qx||(qx=1,function(t){var e=ho&&ho.__extends||function(){var R=function(T,k){return R=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(D,N){D.__proto__=N}||function(D,N){for(var O in N)N.hasOwnProperty(O)&&(D[O]=N[O])},R(T,k)};return function(T,k){R(T,k);function D(){this.constructor=T}T.prototype=k===null?Object.create(k):(D.prototype=k.prototype,new D)}}(),n=ho&&ho.__assign||function(){return n=Object.assign||function(R){for(var T,k=1,D=arguments.length;k<D;k++){T=arguments[k];for(var N in T)Object.prototype.hasOwnProperty.call(T,N)&&(R[N]=T[N])}return R},n.apply(this,arguments)};Object.defineProperty(t,"__esModule",{value:!0}),t.create=t.ModalIframe=t.ModalMessage=t.Modal=t.isMessageModal=t.isIframeModal=t.data=t.update=t.clickFooterButton=t.updateModalSize=t.closeModal=t.openModal=t.Size=t.Action=void 0;var r=Nl(),o=Fe(),i=De(),a=La(),u;(function(R){R.OPEN="APP::MODAL::OPEN",R.CLOSE="APP::MODAL::CLOSE",R.UPDATE="APP::MODAL::UPDATE",R.UPDATE_CONTENT="APP::MODAL::CONTENT::UPDATE",R.FOOTER_BUTTON_CLICK="APP::MODAL::FOOTER::BUTTON::CLICK",R.FOOTER_BUTTON_UPDATE="APP::MODAL::FOOTER::BUTTON::UPDATE",R.UPDATE_SIZE="APP::MODAL::UPDATE_SIZE",R.DATA="APP::MODAL::DATA"})(u=t.Action||(t.Action={}));var l;(function(R){R.Small="small",R.Medium="medium",R.Large="large",R.Full="full",R.Auto="auto"})(l=t.Size||(t.Size={}));var d={group:i.Group.Modal,subgroups:["Footer"],type:i.ComponentType.Button};function f(R){return o.actionWrapper({group:i.Group.Modal,payload:R,type:u.OPEN})}t.openModal=f;function p(R){return o.actionWrapper({group:i.Group.Modal,payload:R,type:u.CLOSE})}t.closeModal=p;function h(R){return o.actionWrapper({group:i.Group.Modal,payload:R,type:u.UPDATE_SIZE})}t.updateModalSize=h;function g(R,T){var k=n({id:R},d);return a.clickButton(i.Group.Modal,k,T)}t.clickFooterButton=g;function y(R){return o.actionWrapper({payload:R,group:i.Group.Modal,type:u.UPDATE})}t.update=y;function x(R){return o.actionWrapper({payload:R,group:i.Group.Modal,type:u.DATA})}t.data=x;function v(R){return typeof R.url=="string"||typeof R.path=="string"}t.isIframeModal=v;function w(R){return typeof R.message=="string"}t.isMessageModal=w;var S=function(R){e(T,R);function T(){var k=R!==null&&R.apply(this,arguments)||this;return k.size=l.Small,k}return Object.defineProperty(T.prototype,"footer",{get:function(){if(!(!this.footerPrimary&&!this.footerSecondary))return{buttons:{primary:this.footerPrimary,secondary:this.footerSecondary}}},enumerable:!1,configurable:!0}),Object.defineProperty(T.prototype,"footerOptions",{get:function(){if(!(!this.footerPrimaryOptions&&!this.footerSecondaryOptions))return{buttons:{primary:this.footerPrimaryOptions,secondary:this.footerSecondaryOptions}}},enumerable:!1,configurable:!0}),T.prototype.close=function(){this.app.dispatch(p({id:this.id}))},T.prototype.setFooterPrimaryButton=function(k,D){var N=this,O=d.subgroups;this.footerPrimaryOptions=this.getChildButton(k,this.footerPrimaryOptions),this.footerPrimary=this.footerPrimaryOptions?r.getSingleButton(this,this.footerPrimaryOptions,O,function(_){N.updatePrimaryFooterButton(_,D)}):void 0},T.prototype.setFooterSecondaryButtons=function(k,D){var N=this,O=d.subgroups,_=k||[],F=this.footerOptions&&this.footerOptions.buttons.secondary||[];this.footerSecondaryOptions=this.getUpdatedChildActions(_,F),this.footerSecondary=this.footerSecondaryOptions?this.footerSecondaryOptions.map(function(U){return r.getSingleButton(N,U,O,function(G){N.updateSecondaryFooterButton(G,D)})}):void 0},T.prototype.getChildButton=function(k,D){var N=k?[k]:[],O=D?[D]:[],_=this.getUpdatedChildActions(N,O);return _?_[0]:void 0},T.prototype.updatePrimaryFooterButton=function(k,D){!this.footer||!this.footer.buttons.primary||o.updateActionFromPayload(this.footer.buttons.primary,k)&&D()},T.prototype.updateSecondaryFooterButton=function(k,D){if(!(!this.footer||!this.footer.buttons||!this.footer.buttons.secondary)){for(var N,O=0,_=this.footer.buttons.secondary;O<_.length;O++){var F=_[O];if(N=o.updateActionFromPayload(F,k),N)break}N&&D()}},T}(o.ActionSetWithChildren);t.Modal=S;var I=function(R){e(T,R);function T(k,D){var N=R.call(this,k,i.Group.Modal,i.Group.Modal)||this;return N.set(D,!1),N}return Object.defineProperty(T.prototype,"payload",{get:function(){return n(n({},this.options),{footer:this.footer,id:this.id})},enumerable:!1,configurable:!0}),Object.defineProperty(T.prototype,"options",{get:function(){return{footer:this.footerOptions,message:this.message,size:this.size,title:this.title}},enumerable:!1,configurable:!0}),T.prototype.set=function(k,D){var N=this;D===void 0&&(D=!0);var O=o.getMergedProps(this.options,k),_=O.title,F=O.footer,U=O.message,G=O.size;return this.title=_,this.message=U,this.size=G,this.setFooterPrimaryButton(F?F.buttons.primary:void 0,function(){N.dispatch(u.UPDATE)}),this.setFooterSecondaryButtons(F?F.buttons.secondary:void 0,function(){N.dispatch(u.UPDATE)}),D&&this.dispatch(u.UPDATE),this},T.prototype.dispatch=function(k){switch(k){case u.OPEN:this.app.dispatch(f(this.payload));break;case u.CLOSE:this.close();break;case u.UPDATE:this.app.dispatch(y(this.payload));break}return this},T}(S);t.ModalMessage=I;var E=function(R){e(T,R);function T(k,D){var N=R.call(this,k,i.Group.Modal,i.Group.Modal)||this;return N.set(D,!1),N}return Object.defineProperty(T.prototype,"payload",{get:function(){return n(n({},this.options),{footer:this.footer,id:this.id})},enumerable:!1,configurable:!0}),Object.defineProperty(T.prototype,"options",{get:function(){return{footer:this.footerOptions,path:this.path,size:this.size,title:this.title,url:this.url,loading:this.loading}},enumerable:!1,configurable:!0}),T.prototype.set=function(k,D){var N=this;D===void 0&&(D=!0);var O=o.getMergedProps(this.options,k),_=O.title,F=O.footer,U=O.path,G=O.url,j=O.size,Z=O.loading;return this.title=_,this.url=G,this.path=U,this.size=j,this.loading=Z,this.setFooterPrimaryButton(F?F.buttons.primary:void 0,function(){N.dispatch(u.UPDATE)}),this.setFooterSecondaryButtons(F?F.buttons.secondary:void 0,function(){N.dispatch(u.UPDATE)}),D&&this.dispatch(u.UPDATE),this},T.prototype.dispatch=function(k,D){switch(k){case u.OPEN:this.app.dispatch(f(this.payload));break;case u.CLOSE:this.close();break;case u.UPDATE:this.app.dispatch(y(this.payload));break;case u.DATA:this.app.dispatch(x(D||{}));break}return this},T}(S);t.ModalIframe=E,t.create=function(R,T){return v(T)?new E(R,T):new I(R,T)}}(ho)),ho}var dn={},Kx;function oX(){return Kx||(Kx=1,function(t){var e=dn&&dn.__extends||function(){var p=function(h,g){return p=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(y,x){y.__proto__=x}||function(y,x){for(var v in x)x.hasOwnProperty(v)&&(y[v]=x[v])},p(h,g)};return function(h,g){p(h,g);function y(){this.constructor=h}h.prototype=g===null?Object.create(g):(y.prototype=g.prototype,new y)}}(),n=dn&&dn.__assign||function(){return n=Object.assign||function(p){for(var h,g=1,y=arguments.length;g<y;g++){h=arguments[g];for(var x in h)Object.prototype.hasOwnProperty.call(h,x)&&(p[x]=h[x])}return p},n.apply(this,arguments)},r=dn&&dn.__awaiter||function(p,h,g,y){function x(v){return v instanceof g?v:new g(function(w){w(v)})}return new(g||(g=Promise))(function(v,w){function S(R){try{E(y.next(R))}catch(T){w(T)}}function I(R){try{E(y.throw(R))}catch(T){w(T)}}function E(R){R.done?v(R.value):x(R.value).then(S,I)}E((y=y.apply(p,h||[])).next())})},o=dn&&dn.__generator||function(p,h){var g={label:0,sent:function(){if(v[0]&1)throw v[1];return v[1]},trys:[],ops:[]},y,x,v,w;return w={next:S(0),throw:S(1),return:S(2)},typeof Symbol=="function"&&(w[Symbol.iterator]=function(){return this}),w;function S(E){return function(R){return I([E,R])}}function I(E){if(y)throw new TypeError("Generator is already executing.");for(;g;)try{if(y=1,x&&(v=E[0]&2?x.return:E[0]?x.throw||((v=x.return)&&v.call(x),0):x.next)&&!(v=v.call(x,E[1])).done)return v;switch(x=0,v&&(E=[E[0]&2,v.value]),E[0]){case 0:case 1:v=E;break;case 4:return g.label++,{value:E[1],done:!1};case 5:g.label++,x=E[1],E=[0];continue;case 7:E=g.ops.pop(),g.trys.pop();continue;default:if(v=g.trys,!(v=v.length>0&&v[v.length-1])&&(E[0]===6||E[0]===2)){g=0;continue}if(E[0]===3&&(!v||E[1]>v[0]&&E[1]<v[3])){g.label=E[1];break}if(E[0]===6&&g.label<v[1]){g.label=v[1],v=E;break}if(v&&g.label<v[2]){g.label=v[2],g.ops.push(E);break}v[2]&&g.ops.pop(),g.trys.pop();continue}E=h.call(p,g)}catch(R){E=[6,R],x=0}finally{y=v=0}if(E[0]&5)throw E[1];return{value:E[0]?E[1]:void 0,done:!0}}};Object.defineProperty(t,"__esModule",{value:!0}),t.create=t.ModalContent=t.Action=void 0;var i=Fe(),a=De(),u=ZS(),l;(function(p){p.LOADING="LOADING",p.LOADED="LOADED"})(l=t.Action||(t.Action={}));var d=function(p){e(h,p);function h(g,y){return p.call(this,g,a.Group.Modal,a.Group.Modal,y?y.id:void 0)||this}return h.prototype.loaded=function(){this.dispatch(l.LOADED)},h.prototype.loading=function(){this.dispatch(l.LOADING)},h.prototype.dispatch=function(g){switch(g){case l.LOADED:this.dispatchModalAction(u.Action.UPDATE_CONTENT,{loading:!1});break;case l.LOADING:this.dispatchModalAction(u.Action.UPDATE_CONTENT,{loading:!0});break}return this},h.prototype.dispatchModalAction=function(g,y){return r(this,void 0,void 0,function(){var x;return o(this,function(v){return x=i.actionWrapper({type:g,group:a.Group.Modal,payload:n({},y)}),this.app.dispatch(x),[2]})})},h}(i.ActionSet);t.ModalContent=d;function f(p,h){return new d(p,h)}t.create=f}(dn)),dn}var mo={},Yx;function iX(){return Yx||(Yx=1,function(t){var e=mo&&mo.__extends||function(){var f=function(p,h){return f=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(g,y){g.__proto__=y}||function(g,y){for(var x in y)y.hasOwnProperty(x)&&(g[x]=y[x])},f(p,h)};return function(p,h){f(p,h);function g(){this.constructor=p}p.prototype=h===null?Object.create(h):(g.prototype=h.prototype,new g)}}(),n=mo&&mo.__assign||function(){return n=Object.assign||function(f){for(var p,h=1,g=arguments.length;h<g;h++){p=arguments[h];for(var y in p)Object.prototype.hasOwnProperty.call(p,y)&&(f[y]=p[y])}return f},n.apply(this,arguments)};Object.defineProperty(t,"__esModule",{value:!0}),t.create=t.History=t.replace=t.push=t.Action=void 0;var r=Fe(),o=De(),i;(function(f){f.PUSH="APP::NAVIGATION::HISTORY::PUSH",f.REPLACE="APP::NAVIGATION::HISTORY::REPLACE"})(i=t.Action||(t.Action={}));function a(f){return r.actionWrapper({payload:f,group:o.Group.Navigation,type:i.PUSH})}t.push=a;function u(f){return r.actionWrapper({payload:f,group:o.Group.Navigation,type:i.REPLACE})}t.replace=u;var l=function(f){e(p,f);function p(h){return f.call(this,h,"History",o.Group.Navigation)||this}return Object.defineProperty(p.prototype,"payload",{get:function(){return{id:this.id}},enumerable:!1,configurable:!0}),p.prototype.dispatch=function(h,g){var y=n(n({},this.payload),{path:g});switch(h){case i.PUSH:this.app.dispatch(a(y));break;case i.REPLACE:this.app.dispatch(u(y));break}return this},p}(r.ActionSet);t.History=l;function d(f){return new l(f)}t.create=d}(mo)),mo}var go={},Qx;function JS(){return Qx||(Qx=1,function(t){var e=go&&go.__extends||function(){var R=function(T,k){return R=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(D,N){D.__proto__=N}||function(D,N){for(var O in N)N.hasOwnProperty(O)&&(D[O]=N[O])},R(T,k)};return function(T,k){R(T,k);function D(){this.constructor=T}T.prototype=k===null?Object.create(k):(D.prototype=k.prototype,new D)}}(),n=go&&go.__assign||function(){return n=Object.assign||function(R){for(var T,k=1,D=arguments.length;k<D;k++){T=arguments[k];for(var N in T)Object.prototype.hasOwnProperty.call(T,N)&&(R[N]=T[N])}return R},n.apply(this,arguments)};Object.defineProperty(t,"__esModule",{value:!0}),t.create=t.Redirect=t.isRemotePayload=t.isAdminSectionPayload=t.isAdminPathPayload=t.isAppPayload=t.toDestination=t.toApp=t.toRemote=t.toAdminSection=t.toAdminPath=t.isProductVariantCreateResourcePayload=t.isProductVariantResourcePayload=t.isCreateResourcePayload=t.isResourcePayload=t.ResourceType=t.Action=void 0;var r=Fe(),o=De(),i;(function(R){R.ADMIN_SECTION="APP::NAVIGATION::REDIRECT::ADMIN::SECTION",R.ADMIN_PATH="APP::NAVIGATION::REDIRECT::ADMIN::PATH",R.REMOTE="APP::NAVIGATION::REDIRECT::REMOTE",R.APP="APP::NAVIGATION::REDIRECT::APP"})(i=t.Action||(t.Action={})),function(R){R.Product="products",R.Collection="collections",R.Order="orders",R.Customer="customers",R.Discount="discounts"}(t.ResourceType||(t.ResourceType={}));function a(R){return typeof R.id=="string"}t.isResourcePayload=a;function u(R){return R.create===!0}t.isCreateResourcePayload=u;function l(R){var T=R;return T.id!==void 0&&T.variant!==void 0}t.isProductVariantResourcePayload=l;function d(R){return l(R)?u(R.variant):!1}t.isProductVariantCreateResourcePayload=d;function f(R){return r.actionWrapper({payload:R,group:o.Group.Navigation,type:i.ADMIN_PATH})}t.toAdminPath=f;function p(R){return r.actionWrapper({payload:R,group:o.Group.Navigation,type:i.ADMIN_SECTION})}t.toAdminSection=p;function h(R){return r.actionWrapper({payload:R,group:o.Group.Navigation,type:i.REMOTE})}t.toRemote=h;function g(R){return r.actionWrapper({payload:R,group:o.Group.Navigation,type:i.APP})}t.toApp=g;function y(R,T,k){switch(R){case i.APP:{var D=x(T)?T:{path:T};return g(n({id:k},D))}case i.ADMIN_PATH:{var N=v(T)?T:{path:T};return f(n({id:k},N))}case i.ADMIN_SECTION:{var O=w(T)?T:{section:T};return p(n({id:k},O))}case i.REMOTE:{var _=S(T)?T:{url:T};return h(n({id:k},_))}}}t.toDestination=y;function x(R){return typeof R=="object"&&Object.prototype.hasOwnProperty.call(R,"path")}t.isAppPayload=x;function v(R){return typeof R=="object"&&Object.prototype.hasOwnProperty.call(R,"path")}t.isAdminPathPayload=v;function w(R){return typeof R=="object"&&typeof R.section=="object"&&Object.prototype.hasOwnProperty.call(R.section,"name")}t.isAdminSectionPayload=w;function S(R){return typeof R=="object"&&Object.prototype.hasOwnProperty.call(R,"url")}t.isRemotePayload=S;var I=function(R){e(T,R);function T(k){return R.call(this,k,"Redirect",o.Group.Navigation)||this}return Object.defineProperty(T.prototype,"payload",{get:function(){return{id:this.id}},enumerable:!1,configurable:!0}),T.prototype.dispatch=function(k,D){var N=y(k,D,this.payload.id);return this.app.dispatch(N),this},T}(r.ActionSet);t.Redirect=I;function E(R){return new I(R)}t.create=E}(go)),go}var yo={},Zx;function sX(){return Zx||(Zx=1,function(t){var e=yo&&yo.__extends||function(){var y=function(x,v){return y=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(w,S){w.__proto__=S}||function(w,S){for(var I in S)S.hasOwnProperty(I)&&(w[I]=S[I])},y(x,v)};return function(x,v){y(x,v);function w(){this.constructor=x}x.prototype=v===null?Object.create(v):(w.prototype=v.prototype,new w)}}(),n=yo&&yo.__assign||function(){return n=Object.assign||function(y){for(var x,v=1,w=arguments.length;v<w;v++){x=arguments[v];for(var S in x)Object.prototype.hasOwnProperty.call(x,S)&&(y[S]=x[S])}return y},n.apply(this,arguments)};Object.defineProperty(t,"__esModule",{value:!0}),t.create=t.ResourcePicker=t.update=t.close=t.cancel=t.open=t.select=t.ActionVerb=t.ResourceType=t.ProductStatus=t.ProductVariantInventoryManagement=t.ProductVariantInventoryPolicy=t.WeightUnit=t.FulfillmentServiceType=t.CollectionSortOrder=t.Action=void 0;var r=Fe(),o=De(),i;(function(y){y.OPEN="APP::RESOURCE_PICKER::OPEN",y.SELECT="APP::RESOURCE_PICKER::SELECT",y.CLOSE="APP::RESOURCE_PICKER::CLOSE",y.UPDATE="APP::RESOURCE_PICKER::UPDATE",y.CANCEL="APP::RESOURCE_PICKER::CANCEL"})(i=t.Action||(t.Action={})),function(y){y.Manual="MANUAL",y.BestSelling="BEST_SELLING",y.AlphaAsc="ALPHA_ASC",y.AlphaDesc="ALPHA_DESC",y.PriceDesc="PRICE_DESC",y.PriceAsc="PRICE_ASC",y.CreatedDesc="CREATED_DESC",y.Created="CREATED"}(t.CollectionSortOrder||(t.CollectionSortOrder={})),function(y){y.GiftCard="GIFT_CARD",y.Manual="MANUAL",y.ThirdParty="THIRD_PARTY"}(t.FulfillmentServiceType||(t.FulfillmentServiceType={})),function(y){y.Kilograms="KILOGRAMS",y.Grams="GRAMS",y.Pounds="POUNDS",y.Ounces="OUNCES"}(t.WeightUnit||(t.WeightUnit={})),function(y){y.Deny="DENY",y.Continue="CONTINUE"}(t.ProductVariantInventoryPolicy||(t.ProductVariantInventoryPolicy={})),function(y){y.Shopify="SHOPIFY",y.NotManaged="NOT_MANAGED",y.FulfillmentService="FULFILLMENT_SERVICE"}(t.ProductVariantInventoryManagement||(t.ProductVariantInventoryManagement={})),function(y){y.Active="ACTIVE",y.Archived="ARCHIVED",y.Draft="DRAFT"}(t.ProductStatus||(t.ProductStatus={}));var a;(function(y){y.Product="product",y.ProductVariant="variant",y.Collection="collection"})(a=t.ResourceType||(t.ResourceType={}));var u;(function(y){y.Add="add",y.Select="select"})(u=t.ActionVerb||(t.ActionVerb={}));function l(y){return r.actionWrapper({payload:y,group:o.Group.ResourcePicker,type:i.SELECT})}t.select=l;function d(y){return r.actionWrapper({payload:y,group:o.Group.ResourcePicker,type:i.OPEN})}t.open=d;function f(y){return r.actionWrapper({payload:y,group:o.Group.ResourcePicker,type:i.CANCEL})}t.cancel=f;function p(y){return r.actionWrapper({payload:y,group:o.Group.ResourcePicker,type:i.CANCEL})}t.close=p;function h(y){return r.actionWrapper({payload:y,group:o.Group.ResourcePicker,type:i.UPDATE})}t.update=h;var g=function(y){e(x,y);function x(v,w,S){var I=y.call(this,v,o.Group.ResourcePicker,o.Group.ResourcePicker)||this;return I.initialSelectionIds=[],I.selection=[],I.resourceType=S,I.set(w,!1),I}return Object.defineProperty(x.prototype,"payload",{get:function(){return n(n({},this.options),{id:this.id,resourceType:this.resourceType})},enumerable:!1,configurable:!0}),Object.defineProperty(x.prototype,"options",{get:function(){var v={initialQuery:this.initialQuery,selectMultiple:this.selectMultiple,initialSelectionIds:this.initialSelectionIds,showHidden:this.showHidden,actionVerb:this.actionVerb};if(this.resourceType===a.Product){var w=n(n({},v),{showVariants:this.showVariants,showDraft:this.showDraft,showArchived:this.showArchived,showDraftBadge:this.showDraftBadge,showArchivedBadge:this.showArchivedBadge});return w}return v},enumerable:!1,configurable:!0}),x.prototype.set=function(v,w){w===void 0&&(w=!0);var S=r.getMergedProps(this.options,v),I=S.initialQuery,E=S.initialSelectionIds,R=E===void 0?[]:E,T=S.showHidden,k=T===void 0?!0:T,D=S.showVariants,N=D===void 0?!0:D,O=S.showDraft,_=O===void 0?!0:O,F=S.showArchived,U=F===void 0?!0:F,G=S.showDraftBadge,j=G===void 0?!1:G,Z=S.showArchivedBadge,L=Z===void 0?!1:Z,X=S.selectMultiple,ne=X===void 0?!0:X,Q=S.actionVerb,H=Q===void 0?u.Add:Q;return this.initialQuery=I,this.initialSelectionIds=R,this.showHidden=k,this.showVariants=N,this.showDraft=_,this.showArchived=U,this.showDraftBadge=j,this.showArchivedBadge=L,this.selectMultiple=ne,this.actionVerb=H,w&&this.update(),this},x.prototype.dispatch=function(v,w){return v===i.OPEN?this.open():v===i.UPDATE?this.update():v===i.CLOSE||v===i.CANCEL?this.cancel():v===i.SELECT&&(this.selection=w,this.app.dispatch(l({id:this.id,selection:this.selection}))),this},x.prototype.update=function(){this.app.dispatch(h(this.payload))},x.prototype.open=function(){this.app.dispatch(d(this.payload))},x.prototype.cancel=function(){this.app.dispatch(f({id:this.id}))},x.prototype.close=function(){this.cancel()},x}(r.ActionSet);t.ResourcePicker=g,t.create=function(y,x){var v=x.resourceType,w=x.options,S=w===void 0?{}:w;return new g(y,S,v)}}(yo)),yo}var Js={},Jx;function aX(){return Jx||(Jx=1,function(t){var e=Js&&Js.__extends||function(){var d=function(f,p){return d=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(h,g){h.__proto__=g}||function(h,g){for(var y in g)g.hasOwnProperty(y)&&(h[y]=g[y])},d(f,p)};return function(f,p){d(f,p);function h(){this.constructor=f}f.prototype=p===null?Object.create(p):(h.prototype=p.prototype,new h)}}();Object.defineProperty(t,"__esModule",{value:!0}),t.capture=t.openCamera=t.create=t.Scanner=t.Action=void 0;var n=Fe(),r=De(),o;(function(d){d.OPEN_CAMERA="APP::SCANNER::OPEN::CAMERA",d.CAPTURE="APP::SCANNER::CAPTURE"})(o=t.Action||(t.Action={}));var i=function(d){e(f,d);function f(p,h){return d.call(this,p,r.Group.Scanner,r.Group.Scanner,h?h.id:void 0)||this}return f.prototype.dispatch=function(p){switch(p){case o.OPEN_CAMERA:this.dispatchScannerAction(o.OPEN_CAMERA);break}return this},f.prototype.dispatchScannerAction=function(p){this.app.dispatch(n.actionWrapper({type:p,group:r.Group.Scanner,payload:{id:this.id}}))},f}(n.ActionSet);t.Scanner=i;function a(d,f){return new i(d,f)}t.create=a;function u(){return n.actionWrapper({group:r.Group.Scanner,type:o.OPEN_CAMERA})}t.openCamera=u;function l(d){return n.actionWrapper({group:r.Group.Scanner,type:o.CAPTURE,payload:d})}t.capture=l}(Js)),Js}var Qd={},ev;function uX(){return ev||(ev=1,function(t){Object.defineProperty(t,"__esModule",{value:!0}),t.respond=t.request=t.Action=void 0;var e=Fe(),n=De(),r;(function(a){a.REQUEST="APP::SESSION_TOKEN::REQUEST",a.RESPOND="APP::SESSION_TOKEN::RESPOND"})(r=t.Action||(t.Action={}));function o(){return e.actionWrapper({group:n.Group.SessionToken,type:r.REQUEST})}t.request=o;function i(a){return e.actionWrapper({payload:a,group:n.Group.SessionToken,type:r.RESPOND})}t.respond=i}(Qd)),Qd}var xo={},ea={},tv;function lX(){if(tv)return ea;tv=1,Object.defineProperty(ea,"__esModule",{value:!0}),ea.getGroupedButton=void 0;var t=Qp();function e(n,r,o,i){n.addChild(r,n.group,o);var a=r.id,u=r.label,l=r.disabled,d=r.buttons,f=r.plain;return n.subscribeToChild(r,t.Action.UPDATE,i),{id:a,label:u,buttons:d,disabled:l,plain:f}}return ea.getGroupedButton=e,ea}var nv;function cX(){return nv||(nv=1,function(t){var e=xo&&xo.__extends||function(){var w=function(S,I){return w=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(E,R){E.__proto__=R}||function(E,R){for(var T in R)R.hasOwnProperty(T)&&(E[T]=R[T])},w(S,I)};return function(S,I){w(S,I);function E(){this.constructor=S}S.prototype=I===null?Object.create(I):(E.prototype=I.prototype,new E)}}(),n=xo&&xo.__assign||function(){return n=Object.assign||function(w){for(var S,I=1,E=arguments.length;I<E;I++){S=arguments[I];for(var R in S)Object.prototype.hasOwnProperty.call(S,R)&&(w[R]=S[R])}return w},n.apply(this,arguments)};Object.defineProperty(t,"__esModule",{value:!0}),t.create=t.TitleBar=t.update=t.clickBreadcrumb=t.clickActionButton=t.Action=void 0;var r=La(),o=Qp(),i=lX(),a=Nl(),u=Fe(),l=De(),d;(function(w){w.UPDATE="APP::TITLEBAR::UPDATE",w.BUTTON_CLICK="APP::TITLEBAR::BUTTONS::BUTTON::CLICK",w.BUTTON_UPDATE="APP::TITLEBAR::BUTTONS::BUTTON::UPDATE",w.BUTTON_GROUP_UPDATE="APP::TITLEBAR::BUTTONS::BUTTONGROUP::UPDATE",w.BREADCRUMBS_CLICK="APP::TITLEBAR::BREADCRUMBS::BUTTON::CLICK",w.BREADCRUMBS_UPDATE="APP::TITLEBAR::BREADCRUMBS::BUTTON::UPDATE"})(d=t.Action||(t.Action={}));var f={group:l.Group.TitleBar,subgroups:["Buttons"]},p={group:l.Group.TitleBar,subgroups:["Breadcrumbs"],type:l.ComponentType.Button};function h(w,S){var I=l.ComponentType.Button,E=n({id:w,type:I},f);return r.clickButton(l.Group.TitleBar,E,S)}t.clickActionButton=h;function g(w,S){var I=n({id:w},p);return r.clickButton(l.Group.TitleBar,I,S)}t.clickBreadcrumb=g;function y(w){return u.actionWrapper({payload:w,group:l.Group.TitleBar,type:d.UPDATE})}t.update=y;var x=function(w){e(S,w);function S(I,E){var R=w.call(this,I,l.Group.TitleBar,l.Group.TitleBar)||this;return R.set(E),R}return Object.defineProperty(S.prototype,"buttons",{get:function(){if(!(!this.primary&&!this.secondary))return{primary:this.primary,secondary:this.secondary}},enumerable:!1,configurable:!0}),Object.defineProperty(S.prototype,"buttonsOptions",{get:function(){if(!(!this.primaryOptions&&!this.secondaryOptions))return{primary:this.primaryOptions,secondary:this.secondaryOptions}},enumerable:!1,configurable:!0}),Object.defineProperty(S.prototype,"options",{get:function(){return{breadcrumbs:this.breadcrumbsOption,buttons:this.buttonsOptions,title:this.title}},enumerable:!1,configurable:!0}),Object.defineProperty(S.prototype,"payload",{get:function(){return n(n({},this.options),{breadcrumbs:this.breadcrumb,buttons:this.buttons,id:this.id})},enumerable:!1,configurable:!0}),S.prototype.set=function(I,E){E===void 0&&(E=!0);var R=u.getMergedProps(this.options,I),T=R.title,k=R.buttons,D=R.breadcrumbs;return this.title=T,this.setBreadcrumbs(D),this.setPrimaryButton(k?k.primary:void 0),this.setSecondaryButton(k?k.secondary:void 0),E&&this.dispatch(d.UPDATE),this},S.prototype.dispatch=function(I){switch(I){case d.UPDATE:this.app.dispatch(y(this.payload));break}return this},S.prototype.getButton=function(I,E,R){return I instanceof o.ButtonGroup?i.getGroupedButton(this,I,E,R):a.getSingleButton(this,I,E,R)},S.prototype.updatePrimaryButton=function(I){this.primary&&u.updateActionFromPayload(this.primary,I)&&this.dispatch(d.UPDATE)},S.prototype.updateSecondaryButtons=function(I){if(this.secondary){var E=this.secondary.find(function(T){return T.id===I.id});if(E){var R=!1;o.isGroupedButtonPayload(I),R=u.updateActionFromPayload(E,I),R&&this.dispatch(d.UPDATE)}}},S.prototype.updateBreadcrumbButton=function(I){this.breadcrumb&&u.updateActionFromPayload(this.breadcrumb,I)&&this.dispatch(d.UPDATE)},S.prototype.setPrimaryButton=function(I){this.primaryOptions=this.getChildButton(I,this.primaryOptions),this.primary=this.primaryOptions?this.getButton(this.primaryOptions,f.subgroups,this.updatePrimaryButton):void 0},S.prototype.setSecondaryButton=function(I){var E=this,R=I||[],T=this.secondaryOptions||[];this.secondaryOptions=this.getUpdatedChildActions(R,T),this.secondary=this.secondaryOptions?this.secondaryOptions.map(function(k){return E.getButton(k,f.subgroups,E.updateSecondaryButtons)}):void 0},S.prototype.setBreadcrumbs=function(I){this.breadcrumbsOption=this.getChildButton(I,this.breadcrumbsOption),this.breadcrumb=this.breadcrumbsOption?this.getButton(this.breadcrumbsOption,p.subgroups,this.updateBreadcrumbButton):void 0},S.prototype.getChildButton=function(I,E){var R=I?[I]:[],T=E?[E]:[],k=this.getUpdatedChildActions(R,T);return k?k[0]:void 0},S}(u.ActionSetWithChildren);t.TitleBar=x;function v(w,S){return new x(w,S)}t.create=v}(xo)),xo}var vo={},rv;function dX(){return rv||(rv=1,function(t){var e=vo&&vo.__extends||function(){var g=function(y,x){return g=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(v,w){v.__proto__=w}||function(v,w){for(var S in w)w.hasOwnProperty(S)&&(v[S]=w[S])},g(y,x)};return function(y,x){g(y,x);function v(){this.constructor=y}y.prototype=x===null?Object.create(x):(v.prototype=x.prototype,new v)}}(),n=vo&&vo.__assign||function(){return n=Object.assign||function(g){for(var y,x=1,v=arguments.length;x<v;x++){y=arguments[x];for(var w in y)Object.prototype.hasOwnProperty.call(y,w)&&(g[w]=y[w])}return g},n.apply(this,arguments)};Object.defineProperty(t,"__esModule",{value:!0}),t.create=t.ContextualSaveBar=t.discard=t.save=t.hide=t.show=t.Action=void 0;var r=Fe(),o=De(),i;(function(g){g.DISCARD="APP::CONTEXTUAL_SAVE_BAR::DISCARD",g.SAVE="APP::CONTEXTUAL_SAVE_BAR::SAVE",g.SHOW="APP::CONTEXTUAL_SAVE_BAR::SHOW",g.HIDE="APP::CONTEXTUAL_SAVE_BAR::HIDE",g.UPDATE="APP::CONTEXTUAL_SAVE_BAR::UPDATE"})(i=t.Action||(t.Action={}));function a(g,y){return r.actionWrapper({group:o.Group.ContextualSaveBar,type:g,payload:y})}function u(g){return a(i.SHOW,g)}t.show=u;function l(g){return a(i.HIDE,g)}t.hide=l;function d(g){return a(i.SAVE,g)}t.save=d;function f(g){return a(i.DISCARD,g)}t.discard=f;var p=function(g){e(y,g);function y(x,v){v===void 0&&(v={});var w=g.call(this,x,o.Group.ContextualSaveBar,o.Group.ContextualSaveBar)||this;return w.options=v,w.set(v,!1),w}return Object.defineProperty(y.prototype,"payload",{get:function(){return n({id:this.id},this.options)},enumerable:!1,configurable:!0}),y.prototype.set=function(x,v){v===void 0&&(v=!0);var w=r.getMergedProps(this.options,x);return this.options=w,v&&this.dispatch(i.UPDATE),this},y.prototype.dispatch=function(x){return this.app.dispatch(a(x,this.payload)),this},y}(r.ActionSet);t.ContextualSaveBar=p;function h(g,y){return new p(g,y)}t.create=h}(vo)),vo}var Co={},ov;function fX(){return ov||(ov=1,function(t){var e=Co&&Co.__extends||function(){var f=function(p,h){return f=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(g,y){g.__proto__=y}||function(g,y){for(var x in y)y.hasOwnProperty(x)&&(g[x]=y[x])},f(p,h)};return function(p,h){f(p,h);function g(){this.constructor=p}p.prototype=h===null?Object.create(h):(g.prototype=h.prototype,new g)}}(),n=Co&&Co.__assign||function(){return n=Object.assign||function(f){for(var p,h=1,g=arguments.length;h<g;h++){p=arguments[h];for(var y in p)Object.prototype.hasOwnProperty.call(p,y)&&(f[y]=p[y])}return f},n.apply(this,arguments)};Object.defineProperty(t,"__esModule",{value:!0}),t.close=t.show=t.create=t.Share=t.Action=void 0;var r=De(),o=Fe(),i;(function(f){f.SHOW="APP::SHARE::SHOW",f.CLOSE="APP::SHARE::CLOSE"})(i=t.Action||(t.Action={}));var a=function(f){e(p,f);function p(h){return f.call(this,h,r.Group.Share,r.Group.Share)||this}return p.prototype.dispatch=function(h,g){switch(h){case i.SHOW:this.dispatchShareAction(i.SHOW,g);break;default:throw new Error("Action: "+h+" not supported")}return this},p.prototype.dispatchShareAction=function(h,g){this.app.dispatch(o.actionWrapper({type:h,group:r.Group.Share,payload:n({id:this.id},g)}))},p}(o.ActionSet);t.Share=a;function u(f){return new a(f)}t.create=u;function l(){return o.actionWrapper({group:r.Group.Share,type:i.SHOW})}t.show=l;function d(){return o.actionWrapper({group:r.Group.Share,type:i.CLOSE})}t.close=d}(Co)),Co}var wo={},So={},iv;function Zp(){return iv||(iv=1,function(t){var e=So&&So.__extends||function(){var f=function(p,h){return f=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(g,y){g.__proto__=y}||function(g,y){for(var x in y)y.hasOwnProperty(x)&&(g[x]=y[x])},f(p,h)};return function(p,h){f(p,h);function g(){this.constructor=p}p.prototype=h===null?Object.create(h):(g.prototype=h.prototype,new g)}}(),n=So&&So.__assign||function(){return n=Object.assign||function(f){for(var p,h=1,g=arguments.length;h<g;h++){p=arguments[h];for(var y in p)Object.prototype.hasOwnProperty.call(p,y)&&(f[y]=p[y])}return f},n.apply(this,arguments)};Object.defineProperty(t,"__esModule",{value:!0}),t.create=t.AppLink=t.update=t.Action=void 0;var r=Fe(),o=De(),i=JS(),a;(function(f){f.UPDATE="UPDATE"})(a=t.Action||(t.Action={}));function u(f,p,h){var g=p.id,y=h.label,x=h.destination,v=n(n({},h),{id:g,label:y,destination:x});return r.actionWrapper({group:f,type:r.getEventNameSpace(f,a.UPDATE,p),payload:v})}t.update=u;var l=function(f){e(p,f);function p(h,g){var y=f.call(this,h,o.Group.Link,o.Group.Link)||this;return y.label="",y.destination="",y.set(g,!1),y}return Object.defineProperty(p.prototype,"options",{get:function(){var h=this,g=h.label,y=h.destination;return{label:g,destination:y,redirectType:i.Action.APP}},enumerable:!1,configurable:!0}),Object.defineProperty(p.prototype,"payload",{get:function(){var h=this.options,g=h.label,y=h.destination,x=h.redirectType,v=y;return{id:this.id,label:g,destination:{path:v},redirectType:x}},enumerable:!1,configurable:!0}),p.prototype.set=function(h,g){g===void 0&&(g=!0);var y=r.getMergedProps(this.options,h),x=y.label,v=y.destination;return this.label=x,this.destination=v,g&&this.dispatch(a.UPDATE),this},p.prototype.dispatch=function(h){switch(h){case a.UPDATE:{var g=u(this.group,this.component,this.payload);this.app.dispatch(g);break}}return this},p}(r.ActionSet);t.AppLink=l;function d(f,p){return new l(f,p)}t.create=d}(So)),So}var sv;function pX(){return sv||(sv=1,function(t){var e=wo&&wo.__extends||function(){var p=function(h,g){return p=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(y,x){y.__proto__=x}||function(y,x){for(var v in x)x.hasOwnProperty(v)&&(y[v]=x[v])},p(h,g)};return function(h,g){p(h,g);function y(){this.constructor=h}h.prototype=g===null?Object.create(g):(y.prototype=g.prototype,new y)}}(),n=wo&&wo.__assign||function(){return n=Object.assign||function(p){for(var h,g=1,y=arguments.length;g<y;g++){h=arguments[g];for(var x in h)Object.prototype.hasOwnProperty.call(h,x)&&(p[x]=h[x])}return p},n.apply(this,arguments)};Object.defineProperty(t,"__esModule",{value:!0}),t.create=t.NavigationMenu=t.update=t.Action=void 0;var r=Zp(),o=Fe(),i=De(),a=["Navigation_Menu"],u;(function(p){p.UPDATE="APP::MENU::NAVIGATION_MENU::UPDATE",p.LINK_UPDATE="APP::MENU::NAVIGATION_MENU::LINK::UPDATE"})(u=t.Action||(t.Action={}));function l(p){return o.actionWrapper({payload:p,group:i.Group.Menu,type:u.UPDATE})}t.update=l;var d=function(p){e(h,p);function h(g,y){var x=p.call(this,g,"Navigation_Menu",i.Group.Menu)||this;return x.items=[],x.set(y),x}return Object.defineProperty(h.prototype,"options",{get:function(){return{items:this.itemsOptions,active:this.activeOptions}},enumerable:!1,configurable:!0}),Object.defineProperty(h.prototype,"payload",{get:function(){return n(n({},this.options),{active:this.active,items:this.items,id:this.id})},enumerable:!1,configurable:!0}),h.prototype.set=function(g,y){y===void 0&&(y=!0);var x=o.getMergedProps(this.options,g),v=x.items,w=x.active;return this.setItems(v),this.activeOptions=w,this.active=w&&w.id,y&&this.dispatch(u.UPDATE),this},h.prototype.dispatch=function(g){switch(g){case u.UPDATE:this.app.dispatch(l(this.payload));break}return this},h.prototype.updateItem=function(g){if(this.items){var y=this.items.find(function(x){return x.id===g.id});y&&o.updateActionFromPayload(y,g)&&this.dispatch(u.UPDATE)}},h.prototype.setItems=function(g){var y=this,x=g||[],v=this.itemsOptions||[];this.itemsOptions=this.getUpdatedChildActions(x,v),this.items=this.itemsOptions?this.itemsOptions.map(function(w){return y.addChild(w,y.group,a),y.subscribeToChild(w,r.Action.UPDATE,y.updateItem),w.payload}):[]},h}(o.ActionSetWithChildren);t.NavigationMenu=d;function f(p,h){return new d(p,h)}t.create=f}(wo)),wo}var bo={},av;function hX(){return av||(av=1,function(t){var e=bo&&bo.__extends||function(){var p=function(h,g){return p=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(y,x){y.__proto__=x}||function(y,x){for(var v in x)x.hasOwnProperty(v)&&(y[v]=x[v])},p(h,g)};return function(h,g){p(h,g);function y(){this.constructor=h}h.prototype=g===null?Object.create(g):(y.prototype=g.prototype,new y)}}(),n=bo&&bo.__assign||function(){return n=Object.assign||function(p){for(var h,g=1,y=arguments.length;g<y;g++){h=arguments[g];for(var x in h)Object.prototype.hasOwnProperty.call(h,x)&&(p[x]=h[x])}return p},n.apply(this,arguments)};Object.defineProperty(t,"__esModule",{value:!0}),t.create=t.ChannelMenu=t.update=t.Action=void 0;var r=Zp(),o=Fe(),i=De(),a=["Channel_Menu"],u;(function(p){p.UPDATE="APP::MENU::CHANNEL_MENU::UPDATE",p.LINK_UPDATE="APP::MENU::CHANNEL_MENU::LINK::UPDATE"})(u=t.Action||(t.Action={}));function l(p){return o.actionWrapper({payload:p,group:i.Group.Menu,type:u.UPDATE})}t.update=l;var d=function(p){e(h,p);function h(g,y){var x=p.call(this,g,"Channel_Menu",i.Group.Menu)||this;return x.items=[],x.set(y),x}return Object.defineProperty(h.prototype,"options",{get:function(){return{items:this.itemsOptions,active:this.activeOptions}},enumerable:!1,configurable:!0}),Object.defineProperty(h.prototype,"payload",{get:function(){return n(n({},this.options),{active:this.active,items:this.items,id:this.id})},enumerable:!1,configurable:!0}),h.prototype.set=function(g,y){y===void 0&&(y=!0);var x=o.getMergedProps(this.options,g),v=x.items,w=x.active;return this.setItems(v),this.activeOptions=w,this.active=w&&w.id,y&&this.dispatch(u.UPDATE),this},h.prototype.dispatch=function(g){switch(g){case u.UPDATE:this.app.dispatch(l(this.payload));break}return this},h.prototype.updateItem=function(g){if(this.items){var y=this.items.find(function(x){return x.id===g.id});y&&o.updateActionFromPayload(y,g)&&this.dispatch(u.UPDATE)}},h.prototype.setItems=function(g){var y=this,x=g||[],v=this.itemsOptions||[];this.itemsOptions=this.getUpdatedChildActions(x,v),this.items=this.itemsOptions?this.itemsOptions.map(function(w){return y.addChild(w,y.group,a),y.subscribeToChild(w,r.Action.UPDATE,y.updateItem),w.payload}):[]},h}(o.ActionSetWithChildren);t.ChannelMenu=d;function f(p,h){return new d(p,h)}t.create=f}(bo)),bo}var ta={},uv;function mX(){return uv||(uv=1,function(t){var e=ta&&ta.__extends||function(){var l=function(d,f){return l=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(p,h){p.__proto__=h}||function(p,h){for(var g in h)h.hasOwnProperty(g)&&(p[g]=h[g])},l(d,f)};return function(d,f){l(d,f);function p(){this.constructor=d}d.prototype=f===null?Object.create(f):(p.prototype=f.prototype,new p)}}();Object.defineProperty(t,"__esModule",{value:!0}),t.create=t.Pos=t.close=t.Action=void 0;var n=Fe(),r=De(),o;(function(l){l.CLOSE="APP::POS::CLOSE",l.LOCATION_UPDATE="APP::POS::LOCATION::UPDATE",l.USER_UPDATE="APP::POS::USER::UPDATE",l.DEVICE_UPDATE="APP::POS::DEVICE::UPDATE"})(o=t.Action||(t.Action={}));function i(){return n.actionWrapper({group:r.Group.Pos,type:o.CLOSE})}t.close=i;var a=function(l){e(d,l);function d(f){return l.call(this,f,r.Group.Pos,r.Group.Pos)||this}return d.prototype.dispatch=function(f){switch(f){case o.CLOSE:this.app.dispatch(i());break}return this},d}(n.ActionSet);t.Pos=a;function u(l){return new a(l)}t.create=u}(ta)),ta}var Io={},lv;function gX(){return lv||(lv=1,function(t){var e=Io&&Io.__extends||function(){var g=function(y,x){return g=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(v,w){v.__proto__=w}||function(v,w){for(var S in w)w.hasOwnProperty(S)&&(v[S]=w[S])},g(y,x)};return function(y,x){g(y,x);function v(){this.constructor=y}y.prototype=x===null?Object.create(x):(v.prototype=x.prototype,new v)}}(),n=Io&&Io.__assign||function(){return n=Object.assign||function(g){for(var y,x=1,v=arguments.length;x<v;x++){y=arguments[x];for(var w in y)Object.prototype.hasOwnProperty.call(y,w)&&(g[w]=y[w])}return g},n.apply(this,arguments)};Object.defineProperty(t,"__esModule",{value:!0}),t.create=t.MarketingExternalActivityTopBar=t.update=t.clickActionButton=t.MarketingActivityStatusBadgeType=t.Action=void 0;var r=La(),o=Nl(),i=Fe(),a=De(),u;(function(g){g.UPDATE="APP::MARKETING_EXTERNAL_ACTIVITY_TOP_BAR::UPDATE",g.BUTTON_CLICK="APP::MARKETING_EXTERNAL_ACTIVITY_TOP_BAR::BUTTONS::BUTTON::CLICK",g.BUTTON_UPDATE="APP::MARKETING_EXTERNAL_ACTIVITY_TOP_BAR::BUTTONS::BUTTON::UPDATE"})(u=t.Action||(t.Action={})),function(g){g.Default="DEFAULT",g.Success="SUCCESS",g.Attention="ATTENTION",g.Warning="WARNING",g.Info="INFO"}(t.MarketingActivityStatusBadgeType||(t.MarketingActivityStatusBadgeType={}));var l={group:a.Group.MarketingExternalActivityTopBar,subgroups:["Buttons"]};function d(g,y){var x=a.ComponentType.Button,v=n({id:g,type:x},l);return r.clickButton(a.Group.MarketingExternalActivityTopBar,v,y)}t.clickActionButton=d;function f(g){return i.actionWrapper({payload:g,group:a.Group.MarketingExternalActivityTopBar,type:u.UPDATE})}t.update=f;var p=function(g){e(y,g);function y(x,v){var w=g.call(this,x,a.Group.MarketingExternalActivityTopBar,a.Group.MarketingExternalActivityTopBar)||this;return w.set(v),w}return Object.defineProperty(y.prototype,"buttons",{get:function(){if(!(!this.primary&&!this.secondary))return{primary:this.primary,secondary:this.secondary}},enumerable:!1,configurable:!0}),Object.defineProperty(y.prototype,"buttonsOptions",{get:function(){if(!(!this.primaryOptions&&!this.secondaryOptions))return{primary:this.primaryOptions,secondary:this.secondaryOptions}},enumerable:!1,configurable:!0}),Object.defineProperty(y.prototype,"options",{get:function(){return{title:this.title,status:this.status,saving:this.saving,saved:this.saved,buttons:this.buttonsOptions}},enumerable:!1,configurable:!0}),Object.defineProperty(y.prototype,"payload",{get:function(){return n(n({},this.options),{buttons:this.buttons,id:this.id})},enumerable:!1,configurable:!0}),y.prototype.set=function(x,v){v===void 0&&(v=!0);var w=i.getMergedProps(this.options,x),S=w.title,I=w.buttons,E=w.saved,R=w.saving,T=w.status;return this.title=S,this.saving=R,this.saved=E,this.status=T,this.setPrimaryButton(I?I.primary:void 0),this.setSecondaryButtons(I?I.secondary:void 0),v&&this.dispatch(u.UPDATE),this},y.prototype.dispatch=function(x){switch(x){case u.UPDATE:this.app.dispatch(f(this.payload));break}return this},y.prototype.getButton=function(x,v,w){return o.getSingleButton(this,x,v,w)},y.prototype.updatePrimaryButton=function(x){this.primary&&i.updateActionFromPayload(this.primary,x)&&this.dispatch(u.UPDATE)},y.prototype.updateSecondaryButtons=function(x){if(this.secondary){var v=this.secondary.find(function(S){return S.id===x.id});if(v){var w=i.updateActionFromPayload(v,x);w&&this.dispatch(u.UPDATE)}}},y.prototype.setPrimaryButton=function(x){this.primaryOptions=this.getChildButton(x,this.primaryOptions),this.primary=this.primaryOptions?this.getButton(this.primaryOptions,l.subgroups,this.updatePrimaryButton):void 0},y.prototype.setSecondaryButtons=function(x){var v=this,w=x||[],S=this.secondaryOptions||[];this.secondaryOptions=this.getUpdatedChildActions(w,S),this.secondary=this.secondaryOptions?this.secondaryOptions.map(function(I){return v.getButton(I,l.subgroups,v.updateSecondaryButtons)}):void 0},y.prototype.updateSaving=function(x){this.saving=x,this.dispatch(u.UPDATE)},y.prototype.updateSaved=function(x){this.saved=x,this.dispatch(u.UPDATE)},y.prototype.updateStatus=function(x){this.status=x,this.dispatch(u.UPDATE)},y.prototype.getChildButton=function(x,v){var w=x?[x]:[],S=v?[v]:[],I=this.getUpdatedChildActions(w,S);return I?I[0]:void 0},y}(i.ActionSetWithChildren);t.MarketingExternalActivityTopBar=p;function h(g,y){return new p(g,y)}t.create=h}(Io)),Io}var Zd={},cv;function yX(){return cv||(cv=1,function(t){Object.defineProperty(t,"__esModule",{value:!0}),t.fullPageLoad=t.skeletonPageLoad=t.Action=void 0;var e=De(),n=Fe(),r;(function(a){a.SKELETON_PAGE_LOAD="APP::PERFORMANCE::SKELETON_PAGE_LOAD",a.FULL_PAGE_LOAD="APP::PERFORMANCE::FULL_PAGE_LOAD"})(r=t.Action||(t.Action={}));function o(){return n.actionWrapper({group:e.Group.Performance,type:r.SKELETON_PAGE_LOAD})}t.skeletonPageLoad=o;function i(){return n.actionWrapper({group:e.Group.Performance,type:r.FULL_PAGE_LOAD})}t.fullPageLoad=i}(Zd)),Zd}var dv;function nr(){return dv||(dv=1,function(t){var e=ln&&ln.__createBinding||(Object.create?function(Q,H,K,J){J===void 0&&(J=K),Object.defineProperty(Q,J,{enumerable:!0,get:function(){return H[K]}})}:function(Q,H,K,J){J===void 0&&(J=K),Q[J]=H[K]}),n=ln&&ln.__setModuleDefault||(Object.create?function(Q,H){Object.defineProperty(Q,"default",{enumerable:!0,value:H})}:function(Q,H){Q.default=H}),r=ln&&ln.__importStar||function(Q){if(Q&&Q.__esModule)return Q;var H={};if(Q!=null)for(var K in Q)K!=="default"&&Object.hasOwnProperty.call(Q,K)&&e(H,Q,K);return n(H,Q),H},o=ln&&ln.__exportStar||function(Q,H){for(var K in Q)K!=="default"&&!H.hasOwnProperty(K)&&e(H,Q,K)};Object.defineProperty(t,"__esModule",{value:!0}),t.Performance=t.Pos=t.AppLink=t.ChannelMenu=t.NavigationMenu=t.Share=t.ContextualSaveBar=t.MarketingExternalActivityTopBar=t.TitleBar=t.SessionToken=t.ResourcePicker=t.Redirect=t.Print=t.ModalContent=t.Modal=t.Loading=t.LeaveConfirmation=t.History=t.Toast=t.Fullscreen=t.FeedbackModal=t.Features=t.Flash=t.Error=t.Client=t.Cart=t.Scanner=t.ButtonGroup=t.Button=t.AuthCode=void 0;var i=r(q6());t.AuthCode=i;var a=r(La());t.Button=a;var u=r(Qp());t.ButtonGroup=u;var l=r(K6());t.Cart=l;var d=r(KS());t.Client=d;var f=r(Fa());t.Error=f;var p=r(Q6());t.Flash=p;var h=r(J6());t.Features=h;var g=r(eX());t.FeedbackModal=g;var y=r(tX());t.Fullscreen=y;var x=r(nX());t.LeaveConfirmation=x;var v=r(rX());t.Loading=v;var w=r(ZS());t.Modal=w;var S=r(oX());t.ModalContent=S;var I=r(iX());t.History=I;var E=r(JS());t.Redirect=E;var R=r(jS());t.Print=R;var T=r(sX());t.ResourcePicker=T;var k=r(aX());t.Scanner=k;var D=r(uX());t.SessionToken=D;var N=r(cX());t.TitleBar=N;var O=r(Rf());t.Toast=O;var _=r(dX());t.ContextualSaveBar=_;var F=r(fX());t.Share=F;var U=r(pX());t.NavigationMenu=U;var G=r(hX());t.ChannelMenu=G;var j=r(Zp());t.AppLink=j;var Z=r(mX());t.Pos=Z;var L=r(gX());t.MarketingExternalActivityTopBar=L;var X=r(yX());t.Performance=X;var ne=XS();Object.defineProperty(t,"isAppBridgeAction",{enumerable:!0,get:function(){return ne.isAppBridgeAction}}),o(De(),t)}(ln)),ln}var fv;function xX(){if(fv)return br;fv=1;var t=br&&br.__extends||function(){var a=function(u,l){return a=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,f){d.__proto__=f}||function(d,f){for(var p in f)f.hasOwnProperty(p)&&(d[p]=f[p])},a(u,l)};return function(u,l){a(u,l);function d(){this.constructor=u}u.prototype=l===null?Object.create(l):(d.prototype=l.prototype,new d)}}(),e=br&&br.__importDefault||function(a){return a&&a.__esModule?a:{default:a}};Object.defineProperty(br,"__esModule",{value:!0});var n=e(wt()),r=nr(),o=wn(),i=function(a){t(u,a);function u(){return a!==null&&a.apply(this,arguments)||this}return u.prototype.componentDidMount=function(){var l=this.context;this.loading=r.Loading.create(l),this.loading!=null&&this.loading.dispatch(r.Loading.Action.START)},u.prototype.componentWillUnmount=function(){this.loading!=null&&this.loading.dispatch(r.Loading.Action.STOP)},u.prototype.render=function(){return null},u.contextType=o.AppBridgeContext,u}(n.default.Component);return br.default=i,br}var pv;function vX(){if(pv)return _i;pv=1;var t=_i&&_i.__importDefault||function(n){return n&&n.__esModule?n:{default:n}};Object.defineProperty(_i,"__esModule",{value:!0});var e=t(xX());return _i.default=e.default,_i}var Pi={},$o={},hv;function CX(){return hv||(hv=1,function(t){var e=$o&&$o.__extends||function(){var u=function(l,d){return u=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(f,p){f.__proto__=p}||function(f,p){for(var h in p)p.hasOwnProperty(h)&&(f[h]=p[h])},u(l,d)};return function(l,d){u(l,d);function f(){this.constructor=l}l.prototype=d===null?Object.create(d):(f.prototype=d.prototype,new f)}}(),n=$o&&$o.__importDefault||function(u){return u&&u.__esModule?u:{default:u}};Object.defineProperty(t,"__esModule",{value:!0}),t.DEFAULT_TOAST_DURATION=void 0;var r=n(wt()),o=nr(),i=wn();t.DEFAULT_TOAST_DURATION=5e3;var a=function(u){e(l,u);function l(){return u!==null&&u.apply(this,arguments)||this}return l.prototype.componentDidMount=function(){var d=this.context,f=this.props,p=f.error,h=f.content,g=f.duration,y=g===void 0?t.DEFAULT_TOAST_DURATION:g,x=f.onDismiss;this.toast=o.Toast.create(d,{message:h,duration:y,isError:p}),this.toast.subscribe(o.Toast.Action.CLEAR,x),this.toast.dispatch(o.Toast.Action.SHOW)},l.prototype.componentWillUnmount=function(){this.toast.unsubscribe()},l.prototype.render=function(){return null},l.contextType=i.AppBridgeContext,l}(r.default.PureComponent);t.default=a}($o)),$o}var mv;function wX(){if(mv)return Pi;mv=1;var t=Pi&&Pi.__importDefault||function(n){return n&&n.__esModule?n:{default:n}};Object.defineProperty(Pi,"__esModule",{value:!0});var e=t(CX());return Pi.default=e.default,Pi}var ki={},Ir={},zn={},gv;function eb(){if(gv)return zn;gv=1;var t=zn&&zn.__spreadArrays||function(){for(var d=0,f=0,p=arguments.length;f<p;f++)d+=arguments[f].length;for(var h=Array(d),g=0,f=0;f<p;f++)for(var y=arguments[f],x=0,v=y.length;x<v;x++,g++)h[g]=y[x];return h};Object.defineProperty(zn,"__esModule",{value:!0}),zn.transformActions=zn.generateRedirect=void 0;var e=nr();function n(d,f,p,h){if(p===void 0&&(p="APP"),f!=null){var g=e.Redirect.create(d),y=h===!0?{url:f,newContext:!0}:f;return function(){g.dispatch(r(p,h),y)}}}zn.generateRedirect=n;function r(d,f){return f===!0?e.Redirect.Action.REMOTE:e.Redirect.Action[d]}function o(d,f){var p=f.primaryAction,h=f.secondaryActions,g=f.actionGroups,y=a(d,p),x=t(u(d,h),l(d,g));return{primary:y,secondary:x}}zn.transformActions=o;function i(d,f){var p=f.destructive===!0?e.Button.Style.Danger:void 0,h=e.Button.create(d,{label:f.content||"",disabled:f.disabled,loading:f.loading,plain:f.plain,style:p});f.onAction&&h.subscribe(e.Button.Action.CLICK,f.onAction);var g=n(d,f.url,f.target,f.external);return g!=null&&h.subscribe(e.Button.Action.CLICK,g),h}function a(d,f){if(f!=null){var p=i(d,f);return p}}function u(d,f){f===void 0&&(f=[]);var p=t(f.map(function(h){return i(d,h)}));return p}function l(d,f){f===void 0&&(f=[]);var p=t(f.map(function(h){var g=h.actions.map(function(y){return i(d,y)});return e.ButtonGroup.create(d,{label:h.title,plain:h.plain,buttons:g})}));return p}return zn}var yv;function SX(){if(yv)return Ir;yv=1;var t=Ir&&Ir.__extends||function(){var u=function(l,d){return u=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(f,p){f.__proto__=p}||function(f,p){for(var h in p)p.hasOwnProperty(h)&&(f[h]=p[h])},u(l,d)};return function(l,d){u(l,d);function f(){this.constructor=l}l.prototype=d===null?Object.create(d):(f.prototype=d.prototype,new f)}}(),e=Ir&&Ir.__importDefault||function(u){return u&&u.__esModule?u:{default:u}};Object.defineProperty(Ir,"__esModule",{value:!0});var n=e(wt()),r=nr(),o=eb(),i=wn(),a=function(u){t(l,u);function l(){return u!==null&&u.apply(this,arguments)||this}return l.prototype.componentDidMount=function(){var d=this.context;this.titleBar=r.TitleBar.create(d,this.transformProps())},l.prototype.componentDidUpdate=function(){this.titleBar.unsubscribe(),this.titleBar.set(this.transformProps())},l.prototype.componentWillUnmount=function(){this.titleBar.unsubscribe()},l.prototype.render=function(){return null},l.prototype.transformProps=function(){var d=this.context,f=this.props,p=f.title,h=f.primaryAction,g=f.secondaryActions,y=f.actionGroups;return{title:p,buttons:o.transformActions(d,{primaryAction:h,secondaryActions:g,actionGroups:y}),breadcrumbs:this.transformBreadcrumbs()}},l.prototype.transformBreadcrumbs=function(){var d=this.context,f=this.props.breadcrumbs;if(!(f==null||f.length===0)){var p=f[f.length-1],h=p.url,g=p.onAction,y=p.target,x=p.content,v=r.Button.create(d,{label:x||""}),w=o.generateRedirect(d,h,y);return w!=null&&v.subscribe(r.Button.Action.CLICK,w),g!=null&&v.subscribe(r.Button.Action.CLICK,g),v}},l.contextType=i.AppBridgeContext,l}(n.default.PureComponent);return Ir.default=a,Ir}var xv;function bX(){if(xv)return ki;xv=1;var t=ki&&ki.__importDefault||function(n){return n&&n.__esModule?n:{default:n}};Object.defineProperty(ki,"__esModule",{value:!0});var e=t(SX());return ki.default=e.default,ki}var na={},_n={},vv;function IX(){if(vv)return _n;vv=1;var t=_n&&_n.__extends||function(){var d=function(f,p){return d=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(h,g){h.__proto__=g}||function(h,g){for(var y in g)g.hasOwnProperty(y)&&(h[y]=g[y])},d(f,p)};return function(f,p){d(f,p);function h(){this.constructor=f}f.prototype=p===null?Object.create(p):(h.prototype=p.prototype,new h)}}(),e=_n&&_n.__assign||function(){return e=Object.assign||function(d){for(var f,p=1,h=arguments.length;p<h;p++){f=arguments[p];for(var g in f)Object.prototype.hasOwnProperty.call(f,g)&&(d[g]=f[g])}return d},e.apply(this,arguments)},n=_n&&_n.__importDefault||function(d){return d&&d.__esModule?d:{default:d}};Object.defineProperty(_n,"__esModule",{value:!0});var r=n(wt()),o=nr(),i=eb(),a=wn(),u=function(d){t(f,d);function f(){var p=d!==null&&d.apply(this,arguments)||this;return p.focusReturnPoint=null,p}return f.prototype.componentDidMount=function(){var p=this.props,h=p.open,g=p.onClose,y=this.context;this.modal=o.Modal.create(y,this.transformProps()),g!=null&&this.modal.subscribe(o.Modal.Action.CLOSE,g),h&&(this.focusReturnPoint=document.activeElement,this.modal.dispatch(o.Modal.Action.OPEN))},f.prototype.componentDidUpdate=function(p){var h=this.props,g=h.open,y=h.onClose,x=p.open,v=this.transformProps(x);this.modal.unsubscribe(),l(v)?this.modal.set(v,g):this.modal.set(v,g),y!=null&&this.modal.subscribe(o.Modal.Action.CLOSE,y),x!==g&&(g?this.modal.dispatch(o.Modal.Action.OPEN):this.modal.dispatch(o.Modal.Action.CLOSE)),!x&&g?this.focusReturnPoint=document.activeElement:x&&!g&&this.focusReturnPoint!=null&&document.contains(this.focusReturnPoint)&&(this.focusReturnPoint.focus(),this.focusReturnPoint=null)},f.prototype.componentWillUnmount=function(){this.modal.unsubscribe(),this.props.open&&this.modal.dispatch(o.Modal.Action.CLOSE)},f.prototype.render=function(){return null},f.prototype.transformProps=function(p){var h=this.props,g=h.title,y=h.size,x=h.message,v=h.src,w=h.primaryAction,S=h.secondaryActions,I=h.loading,E=this.context,R=y==null?void 0:o.Modal.Size[y],T={};return v!=null&&(v.match("^https?://")?T.url=v:T.path=v),e(e({title:g,message:x,size:R},T),{footer:{buttons:i.transformActions(E,{primaryAction:w,secondaryActions:S})},loading:p?void 0:I})},f.contextType=a.AppBridgeContext,f}(r.default.PureComponent);function l(d){return typeof d.url=="string"||typeof d.path=="string"}return _n.default=u,_n}var Ti={},$r={},Cv;function $X(){if(Cv)return $r;Cv=1;var t=$r&&$r.__extends||function(){var a=function(u,l){return a=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,f){d.__proto__=f}||function(d,f){for(var p in f)f.hasOwnProperty(p)&&(d[p]=f[p])},a(u,l)};return function(u,l){a(u,l);function d(){this.constructor=u}u.prototype=l===null?Object.create(l):(d.prototype=l.prototype,new d)}}(),e=$r&&$r.__importDefault||function(a){return a&&a.__esModule?a:{default:a}};Object.defineProperty($r,"__esModule",{value:!0});var n=e(wt()),r=nr(),o=wn(),i=function(a){t(u,a);function u(){return a!==null&&a.apply(this,arguments)||this}return u.prototype.componentDidMount=function(){var l=this.context;this.modalContent=r.ModalContent.create(l),this.syncLoadingStatus()},u.prototype.componentDidUpdate=function(){this.syncLoadingStatus()},u.prototype.syncLoadingStatus=function(){this.modalContent&&(this.props.loading?this.modalContent.loading():this.modalContent.loaded())},u.prototype.render=function(){return null},u.contextType=o.AppBridgeContext,u}(n.default.Component);return $r.default=i,$r}var wv;function RX(){if(wv)return Ti;wv=1;var t=Ti&&Ti.__importDefault||function(n){return n&&n.__esModule?n:{default:n}};Object.defineProperty(Ti,"__esModule",{value:!0});var e=t($X());return Ti.default=e.default,Ti}var Sv;function EX(){return Sv||(Sv=1,function(t){var e=na&&na.__importDefault||function(o){return o&&o.__esModule?o:{default:o}};Object.defineProperty(t,"__esModule",{value:!0});var n=e(IX()),r=RX();Object.defineProperty(t,"ModalContent",{enumerable:!0,get:function(){return r.default}}),t.default=n.default}(na)),na}var Ai={},Pn={},bv;function _X(){if(bv)return Pn;bv=1;var t=Pn&&Pn.__extends||function(){var u=function(l,d){return u=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(f,p){f.__proto__=p}||function(f,p){for(var h in p)p.hasOwnProperty(h)&&(f[h]=p[h])},u(l,d)};return function(l,d){u(l,d);function f(){this.constructor=l}l.prototype=d===null?Object.create(d):(f.prototype=d.prototype,new f)}}(),e=Pn&&Pn.__assign||function(){return e=Object.assign||function(u){for(var l,d=1,f=arguments.length;d<f;d++){l=arguments[d];for(var p in l)Object.prototype.hasOwnProperty.call(l,p)&&(u[p]=l[p])}return u},e.apply(this,arguments)},n=Pn&&Pn.__importDefault||function(u){return u&&u.__esModule?u:{default:u}};Object.defineProperty(Pn,"__esModule",{value:!0});var r=n(wt()),o=nr(),i=wn(),a=function(u){t(l,u);function l(){var d=u!==null&&u.apply(this,arguments)||this;return d.focusReturnPoint=null,d}return l.prototype.componentDidMount=function(){var d=this.props,f=d.open,p=d.resourceType,h=d.onSelection,g=d.onCancel,y=this.context;this.picker=o.ResourcePicker.create(y,{resourceType:o.ResourcePicker.ResourceType[p],options:this.getActionOptions()}),h!=null&&this.picker.subscribe(o.ResourcePicker.Action.SELECT,h),g!=null&&this.picker.subscribe(o.ResourcePicker.Action.CANCEL,g),f&&(this.focusReturnPoint=document.activeElement,this.picker.dispatch(o.ResourcePicker.Action.OPEN))},l.prototype.componentDidUpdate=function(d){var f=d.open,p=this.props,h=p.open,g=p.onCancel,y=p.onSelection;this.picker.unsubscribe(),this.picker.set(this.getActionOptions()),y!=null&&this.picker.subscribe(o.ResourcePicker.Action.SELECT,y),g!=null&&this.picker.subscribe(o.ResourcePicker.Action.CANCEL,g),f!==h&&(h?this.picker.dispatch(o.ResourcePicker.Action.OPEN):this.picker.dispatch(o.ResourcePicker.Action.CLOSE)),!f&&h?this.focusReturnPoint=document.activeElement:f&&!h&&this.focusReturnPoint!=null&&document.contains(this.focusReturnPoint)&&(this.focusReturnPoint.focus(),this.focusReturnPoint=null)},l.prototype.componentWillUnmount=function(){this.picker.unsubscribe()},l.prototype.render=function(){return null},l.prototype.getActionOptions=function(){var d=this.props,f=d.initialQuery,p=d.initialSelectionIds,h=d.showHidden,g=d.allowMultiple,y=d.selectMultiple,x=d.actionVerb,v={initialQuery:f,initialSelectionIds:p,showHidden:h,selectMultiple:y??g,actionVerb:x},w=v;if(this.props.resourceType==="Product"){var S=this.props,I=S.showVariants,E=S.showDraft,R=S.showArchived,T=S.showDraftBadge,k=S.showArchivedBadge,D={showVariants:I,showDraft:E,showArchived:R,showDraftBadge:T,showArchivedBadge:k};w=e(e({},v),D)}return w},l.contextType=i.AppBridgeContext,l.ActionVerb=o.ResourcePicker.ActionVerb,l}(r.default.PureComponent);return Pn.default=a,Pn}var Iv;function PX(){if(Iv)return Ai;Iv=1;var t=Ai&&Ai.__importDefault||function(n){return n&&n.__esModule?n:{default:n}};Object.defineProperty(Ai,"__esModule",{value:!0});var e=t(_X());return Ai.default=e.default,Ai}var Jd={},Rr={},Gn={},Hn={},$v;function kX(){if($v)return Hn;$v=1,Object.defineProperty(Hn,"__esModule",{value:!0}),Hn.getOrigin=Hn.getTopWindow=Hn.getSelfWindow=void 0;function t(){return window.self}Hn.getSelfWindow=t;function e(){return window.top}Hn.getTopWindow=e;function n(){return location.origin}return Hn.getOrigin=n,Hn}var Rv;function tb(){if(Rv)return Gn;Rv=1;var t=Gn&&Gn.__awaiter||function(l,d,f,p){function h(g){return g instanceof f?g:new f(function(y){y(g)})}return new(f||(f=Promise))(function(g,y){function x(S){try{w(p.next(S))}catch(I){y(I)}}function v(S){try{w(p.throw(S))}catch(I){y(I)}}function w(S){S.done?g(S.value):h(S.value).then(x,v)}w((p=p.apply(l,d||[])).next())})},e=Gn&&Gn.__generator||function(l,d){var f={label:0,sent:function(){if(g[0]&1)throw g[1];return g[1]},trys:[],ops:[]},p,h,g,y;return y={next:x(0),throw:x(1),return:x(2)},typeof Symbol=="function"&&(y[Symbol.iterator]=function(){return this}),y;function x(w){return function(S){return v([w,S])}}function v(w){if(p)throw new TypeError("Generator is already executing.");for(;f;)try{if(p=1,h&&(g=w[0]&2?h.return:w[0]?h.throw||((g=h.return)&&g.call(h),0):h.next)&&!(g=g.call(h,w[1])).done)return g;switch(h=0,g&&(w=[w[0]&2,g.value]),w[0]){case 0:case 1:g=w;break;case 4:return f.label++,{value:w[1],done:!1};case 5:f.label++,h=w[1],w=[0];continue;case 7:w=f.ops.pop(),f.trys.pop();continue;default:if(g=f.trys,!(g=g.length>0&&g[g.length-1])&&(w[0]===6||w[0]===2)){f=0;continue}if(w[0]===3&&(!g||w[1]>g[0]&&w[1]<g[3])){f.label=w[1];break}if(w[0]===6&&f.label<g[1]){f.label=g[1],g=w;break}if(g&&f.label<g[2]){f.label=g[2],f.ops.push(w);break}g[2]&&f.ops.pop(),f.trys.pop();continue}w=d.call(l,f)}catch(S){w=[6,S],h=0}finally{p=g=0}if(w[0]&5)throw w[1];return{value:w[0]?w[1]:void 0,done:!0}}};Object.defineProperty(Gn,"__esModule",{value:!0}),Gn.updateHistory=void 0;var n=Yp(),r=nr(),o=kX(),i=["hmac","locale","protocol","session","shop","timestamp","host"];function a(l,d){return t(this,void 0,void 0,function(){var f,p,h,g,y,x,v,w,S;return e(this,function(I){switch(I.label){case 0:return f=o.getSelfWindow(),p=o.getTopWindow(),h=f===p,[4,l.getState("context").then(function(E){return E===n.Context.Main})];case 1:return g=I.sent(),h||!g?[2]:(y=u(d),i.forEach(function(E){return y.searchParams.delete(E)}),x=y.pathname,v=y.search,w=y.hash,S=""+x+v+w,r.History.create(l).dispatch(r.History.Action.REPLACE,S),[2])}})})}Gn.updateHistory=a;function u(l){var d=o.getOrigin();if(typeof l=="string")return new URL(l,d);var f=l.pathname,p=l.search,h=l.hash;return new URL(""+f+p+h,d)}return Gn}var Ev;function TX(){if(Ev)return Rr;Ev=1;var t=Rr&&Rr.__extends||function(){var a=function(u,l){return a=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,f){d.__proto__=f}||function(d,f){for(var p in f)f.hasOwnProperty(p)&&(d[p]=f[p])},a(u,l)};return function(u,l){a(u,l);function d(){this.constructor=u}u.prototype=l===null?Object.create(l):(d.prototype=l.prototype,new d)}}(),e=Rr&&Rr.__importDefault||function(a){return a&&a.__esModule?a:{default:a}};Object.defineProperty(Rr,"__esModule",{value:!0});var n=e(wt()),r=wn(),o=tb(),i=function(a){t(u,a);function u(){return a!==null&&a.apply(this,arguments)||this}return u.prototype.componentDidMount=function(){var l=this.props.location;o.updateHistory(this.context,l)},u.prototype.componentDidUpdate=function(l){var d=l.location,f=this.props.location;f!==d&&o.updateHistory(this.context,f)},u.prototype.render=function(){return null},u.contextType=r.AppBridgeContext,u}(n.default.Component);return Rr.default=i,Rr}var qu={},ra={},_v;function Jp(){if(_v)return ra;_v=1,Object.defineProperty(ra,"__esModule",{value:!0}),ra.useAppBridge=void 0;var t=wt(),e=wn();function n(){var r=t.useContext(e.AppBridgeContext);if(!r)throw new Error("No AppBridge context provided. Your component must be wrapped in the <Provider> component from App Bridge React.");return r}return ra.useAppBridge=n,ra}var Pv;function AX(){if(Pv)return qu;Pv=1,Object.defineProperty(qu,"__esModule",{value:!0});var t=wt(),e=Jp(),n=tb();function r(o){var i=e.useAppBridge();t.useEffect(function(){n.updateHistory(i,o)},[i,o])}return qu.default=r,qu}var kv;function NX(){return kv||(kv=1,function(t){Object.defineProperty(t,"__esModule",{value:!0});var e=TX();Object.defineProperty(t,"RoutePropagator",{enumerable:!0,get:function(){return e.default}});var n=AX();Object.defineProperty(t,"useRoutePropagation",{enumerable:!0,get:function(){return n.default}})}(Jd)),Jd}var ef={},Er={},oa={},Tv;function nb(){if(Tv)return oa;Tv=1,Object.defineProperty(oa,"__esModule",{value:!0}),oa.handleRouteChange=void 0;var t=nr();function e(n,r){return n.subscribe(t.Redirect.Action.APP,function(o){var i=o.path;r.replace(i)})}return oa.handleRouteChange=e,oa}var Av;function OX(){if(Av)return Er;Av=1;var t=Er&&Er.__extends||function(){var a=function(u,l){return a=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,f){d.__proto__=f}||function(d,f){for(var p in f)f.hasOwnProperty(p)&&(d[p]=f[p])},a(u,l)};return function(u,l){a(u,l);function d(){this.constructor=u}u.prototype=l===null?Object.create(l):(d.prototype=l.prototype,new d)}}(),e=Er&&Er.__importDefault||function(a){return a&&a.__esModule?a:{default:a}};Object.defineProperty(Er,"__esModule",{value:!0});var n=e(wt()),r=wn(),o=nb(),i=function(a){t(u,a);function u(){return a!==null&&a.apply(this,arguments)||this}return u.prototype.componentDidMount=function(){var l=this.props.history;this.unsubscribe=o.handleRouteChange(this.context,l)},u.prototype.componentWillUnmount=function(){this.unsubscribe&&this.unsubscribe()},u.prototype.render=function(){return null},u.contextType=r.AppBridgeContext,u}(n.default.Component);return Er.default=i,Er}var Ku={},Nv;function DX(){if(Nv)return Ku;Nv=1,Object.defineProperty(Ku,"__esModule",{value:!0});var t=wt(),e=Jp(),n=nb();function r(o){var i=e.useAppBridge();t.useEffect(function(){return n.handleRouteChange(i,o)},[i,o])}return Ku.default=r,Ku}var Ov;function FX(){return Ov||(Ov=1,function(t){Object.defineProperty(t,"__esModule",{value:!0});var e=OX();Object.defineProperty(t,"ClientRouter",{enumerable:!0,get:function(){return e.default}});var n=DX();Object.defineProperty(t,"useClientRouting",{enumerable:!0,get:function(){return n.default}})}(ef)),ef}var Dv;function LX(){return Dv||(Dv=1,function(t){var e=Zr&&Zr.__createBinding||(Object.create?function(d,f,p,h){h===void 0&&(h=p),Object.defineProperty(d,h,{enumerable:!0,get:function(){return f[p]}})}:function(d,f,p,h){h===void 0&&(h=p),d[h]=f[p]}),n=Zr&&Zr.__exportStar||function(d,f){for(var p in d)p!=="default"&&!f.hasOwnProperty(p)&&e(f,d,p)};Object.defineProperty(t,"__esModule",{value:!0});var r=X6();Object.defineProperty(t,"Provider",{enumerable:!0,get:function(){return r.default}});var o=vX();Object.defineProperty(t,"Loading",{enumerable:!0,get:function(){return o.default}});var i=wX();Object.defineProperty(t,"Toast",{enumerable:!0,get:function(){return i.default}});var a=bX();Object.defineProperty(t,"TitleBar",{enumerable:!0,get:function(){return a.default}});var u=EX();Object.defineProperty(t,"Modal",{enumerable:!0,get:function(){return u.default}}),Object.defineProperty(t,"ModalContent",{enumerable:!0,get:function(){return u.ModalContent}});var l=PX();Object.defineProperty(t,"ResourcePicker",{enumerable:!0,get:function(){return l.default}}),n(NX(),t),n(FX(),t)}(Zr)),Zr}var Fv;function MX(){return Fv||(Fv=1,function(t){var e=Qr&&Qr.__createBinding||(Object.create?function(i,a,u,l){l===void 0&&(l=u),Object.defineProperty(i,l,{enumerable:!0,get:function(){return a[u]}})}:function(i,a,u,l){l===void 0&&(l=u),i[l]=a[u]}),n=Qr&&Qr.__exportStar||function(i,a){for(var u in i)u!=="default"&&!a.hasOwnProperty(u)&&e(a,i,u)};Object.defineProperty(t,"__esModule",{value:!0}),n(LX(),t);var r=wn();Object.defineProperty(t,"Context",{enumerable:!0,get:function(){return r.AppBridgeContext}});var o=Jp();Object.defineProperty(t,"useAppBridge",{enumerable:!0,get:function(){return o.useAppBridge}})}(Qr)),Qr}var BX=MX();const UX={apiKey:"2952dc5db37552715a9de184d1419766",host:new URLSearchParams(window.location.search).get("host"),forceRedirect:!0};iI.render(Be.jsx(J2.StrictMode,{children:Be.jsx(BX.Provider,{config:UX,children:Be.jsx(N6,{})})}),document.getElementById("root"));
